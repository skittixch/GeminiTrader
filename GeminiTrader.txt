--- START FILE: README.md ---
```markdown
# GeminiTrader (Prototype)

A web-based, interactive candlestick chart displaying cryptocurrency data (initially BTC-USD) fetched from a local backend proxying the Coinbase API, with live updates via WebSocket. Built with plain HTML, CSS, and vanilla JavaScript modules.

## Features

*   **Interactive Chart:**
    *   Displays historical candlestick data (OHLCV).
    *   Pan the chart by clicking and dragging the main chart area.
    *   Zoom in/out using the mouse scroll wheel.
    *   Scale the Y-axis (price) by clicking and dragging the price scale vertically.
    *   Scale the X-axis (time) by clicking and dragging the time scale horizontally.
    *   Double-click anywhere on the chart to reset the view to a default zoom level centered on the clicked time.
*   **Live Data:**
    *   Connects to Coinbase WebSocket feed for real-time price updates.
    *   Displays the current ticker price as a line and label on the chart.
    *   Updates the closing price and high/low of the *latest* candle in real-time.
*   **Customization & UI:**
    *   Selectable Candlestick Granularity (5m, 15m, 1h, 6h, 1d).
    *   Logarithmic / Linear Y-axis scale toggle.
    *   Dark / Light theme toggle (respects system preference, saves choice).
    *   12-hour (AM/PM) / 24-hour time format toggle.
    *   Date rollover labels and vertical separator lines on the X-axis.
    *   Clean, minimal dashboard-like styling.
*   **Backend Proxy:**
    *   Simple Python Flask server (`server.py`) fetches historical data from the official Coinbase API, decoupling the frontend from direct API calls.

## Project Goals (Future)

*   [ ] Integrate basic trading features (e.g., placing market/limit orders - **requires authentication and careful security considerations**).
*   [ ] integrate LLM interface to determine trading opportunities and general strategy management.
*   [ ] Display additional data (e.g., volume bars, technical indicators).
*   [ ] Allow selection of different trading pairs (product IDs).


## Tech Stack

*   **Frontend:** HTML5, CSS3, Vanilla JavaScript (ES Modules)
*   **Backend:** Python, Flask, Flask-CORS, Requests
*   **Data Source:** Coinbase Exchange API (REST for historical, WebSocket for live ticker)

## Setup and Running

**Prerequisites:**

*   [Git](https://git-scm.com/)
*   [Python 3](https://www.python.org/) (including `pip`)
*   A modern web browser

**Instructions:**

1.  **Clone the Repository (if applicable):**
    ```bash
    git clone https://github.com/skittixch/GeminiTrader/tree/main.git
    cd GeminiTrader
    ```
    *(If you haven't cloned it yet)*

2.  **Navigate to Project Directory:**
    Open your terminal or command prompt and `cd` into the project's root folder (the one containing `index.html`, `server.py`, etc.).

3.  **Install Python Dependencies:**
    ```bash
    pip install Flask Flask-Cors requests
    ```
    *(Consider using a Python virtual environment: `python -m venv venv`, then activate it before installing)*

4.  **Run the Backend Server:**
    Open a terminal in the project directory and run:
    ```bash
    python server.py
    ```
    Leave this terminal running. You should see output indicating it's running on `http://0.0.0.0:5000/`.

5.  **Run the Frontend Server:**
    Open a *second* terminal in the *same* project directory and run Python's built-in HTTP server (or use VS Code's Live Server):
    ```bash
    python -m http.server 8000
    ```
    *(You can use a different port if 8000 is taken)*. Leave this terminal running.

6.  **Access the Chart:**
    Open your web browser and navigate to:
    ```
    http://localhost:8000
    ```
    *(Use the port number you specified for the frontend server)*.

The chart should load, fetch data from your local backend (which fetches from Coinbase), connect to the WebSocket, and display the live price.

## Code Structure

```
--- END FILE: README.md ---


--- START ALL OTHER PROJECT FILES ---

--- START FILE: chart.js ---
```js
// Encapsulate chart logic in an IIFE
(function () {
  "use strict"; // Enable strict mode

  // --- Theme Handling (Run this early) ---
  const themeToggle = document.getElementById("theme-checkbox");
  const userPrefersDark =
    window.matchMedia &&
    window.matchMedia("(prefers-color-scheme: dark)").matches;
  const currentTheme = localStorage.getItem("theme");
  let theme = "light"; // Default

  if (currentTheme) {
    theme = currentTheme;
  } else if (userPrefersDark) {
    theme = "dark";
  }

  document.documentElement.setAttribute("data-theme", theme);
  if (themeToggle && theme === "dark") {
    themeToggle.checked = true;
  }

  if (themeToggle) {
    themeToggle.addEventListener("change", function () {
      if (this.checked) {
        document.documentElement.setAttribute("data-theme", "dark");
        localStorage.setItem("theme", "dark");
      } else {
        document.documentElement.setAttribute("data-theme", "light");
        localStorage.setItem("theme", "light");
      }
      // Redrawing isn't strictly necessary as CSS handles colors, but uncomment if needed
      // requestAnimationFrame(redrawChart);
    });
  }

  window
    .matchMedia("(prefers-color-scheme: dark)")
    .addEventListener("change", (e) => {
      if (!localStorage.getItem("theme")) {
        const newTheme = e.matches ? "dark" : "light";
        document.documentElement.setAttribute("data-theme", newTheme);
        if (themeToggle) themeToggle.checked = newTheme === "dark";
      }
    });
  // --- End Theme Handling ---

  // --- DOM Elements ---
  const chartContainer = document.getElementById("chart-container");
  const chartWrapper = chartContainer?.querySelector(".chart-wrapper");
  const chartArea = document.getElementById("chart-area");
  const gridContainer = document.getElementById("grid-container");
  const yAxisLabelsContainer = document.getElementById("y-axis-labels");
  const xAxisLabelsContainer = document.getElementById("x-axis-labels");
  const chartMessage = document.getElementById("chart-message");

  if (
    !chartContainer ||
    !chartWrapper ||
    !chartArea ||
    !gridContainer ||
    !yAxisLabelsContainer ||
    !xAxisLabelsContainer ||
    !chartMessage
  ) {
    console.error("Chart initialization failed: DOM elements missing.");
    if (chartMessage)
      chartMessage.textContent = "Error: Chart elements missing!";
    return;
  }

  // --- Chart State ---
  let fullData = [];
  let visibleStartIndex = 0;
  let visibleEndIndex = 0;
  let minVisiblePrice = 0;
  let maxVisiblePrice = 1;
  let isPanning = false;
  let isDraggingYAxis = false;
  let isDraggingXAxis = false; // Scaling X
  let panStartX = 0;
  let panStartY = 0;
  let panStartVisibleIndex = 0;
  let panStartVisibleCount = 0;
  let panStartMinPrice = 0;
  let panStartMaxPrice = 0;
  let lastDrawTime = 0;

  // --- Constants ---
  const ZOOM_FACTOR_X = 0.1;
  const ZOOM_FACTOR_Y = 0.1;
  const MIN_VISIBLE_CANDLES = 5;
  const DEFAULT_RESET_CANDLE_COUNT = 100;
  const MIN_PRICE_RANGE_SPAN = 0.1;
  const Y_AXIS_PRICE_PADDING_FACTOR = 0.05;
  const Y_AXIS_DRAG_SENSITIVITY = 2.0;
  const X_AXIS_DRAG_SENSITIVITY = 2.0;
  const MOUSE_MOVE_THROTTLE = 16;
  const DEBOUNCE_DELAY = 100;

  // --- Utility Functions ---
  function calculateNiceStep(range, maxTicks) {
    if (range <= 0 || maxTicks <= 0) return 1;
    const roughStep = range / maxTicks;
    const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
    const residual = roughStep / magnitude;
    let niceStep;
    if (residual > 5) niceStep = 10 * magnitude;
    else if (residual > 2) niceStep = 5 * magnitude;
    else if (residual > 1) niceStep = 2 * magnitude;
    else niceStep = magnitude;
    return Math.max(niceStep, Number.EPSILON * 10);
  }

  function formatTimestamp(timestamp) {
    const date = new Date(timestamp * 1000);
    const hours = date.getHours().toString().padStart(2, "0");
    const minutes = date.getMinutes().toString().padStart(2, "0");
    return `${hours}:${minutes}`;
  }

  // --- Main Drawing Function ---
  function redrawChart() {
    if (!fullData || !chartArea.offsetHeight || !chartArea.offsetWidth) {
      return;
    }
    const chartHeight = chartArea.offsetHeight;
    const chartWidth = chartArea.offsetWidth;
    const priceRange = maxVisiblePrice - minVisiblePrice;
    const visibleCount = visibleEndIndex - visibleStartIndex;

    if (priceRange <= 0 || visibleCount <= 0) {
      chartArea.innerHTML = "";
      gridContainer.innerHTML = "";
      yAxisLabelsContainer.innerHTML = "";
      xAxisLabelsContainer.innerHTML = "";
      return;
    }

    chartArea.innerHTML = "";
    gridContainer.innerHTML = "";
    yAxisLabelsContainer.innerHTML = "";
    xAxisLabelsContainer.innerHTML = "";

    const scaleY = chartHeight / priceRange;
    const totalCandleWidthRatio = 0.85;
    const candleWidth = Math.max(
      1,
      (chartWidth / visibleCount) * totalCandleWidthRatio
    );
    const candleMargin = Math.max(
      0.5,
      ((chartWidth / visibleCount) * (1 - totalCandleWidthRatio)) / 2
    );
    const candleTotalWidth = candleWidth + candleMargin * 2;

    // Draw Gridlines and Axis Labels
    try {
      const yTickDensity = Math.max(3, Math.round(chartHeight / 40));
      const yTicks = calculateNiceStep(priceRange, yTickDensity);
      const firstYTick =
        yTicks > Number.EPSILON
          ? Math.ceil(minVisiblePrice / yTicks) * yTicks
          : minVisiblePrice;
      for (
        let price = firstYTick;
        price <= maxVisiblePrice + yTicks * 0.1;
        price += yTicks
      ) {
        if (yTicks <= Number.EPSILON || price > maxVisiblePrice + priceRange)
          break;
        const y = chartHeight - (price - minVisiblePrice) * scaleY;
        if (y >= -chartHeight && y <= chartHeight * 2) {
          const hLine = document.createElement("div");
          hLine.className = "grid-line horizontal";
          hLine.style.top = `${y.toFixed(1)}px`;
          gridContainer.appendChild(hLine);
          if (y >= -5 && y <= chartHeight + 5) {
            const yLabel = document.createElement("div");
            yLabel.className = "axis-label y-axis-label";
            yLabel.style.top = `${y.toFixed(1)}px`;
            const decimals =
              priceRange < 10 ? (price < 1 ? 4 : 2) : price < 100 ? 1 : 0;
            yLabel.textContent = price.toFixed(decimals);
            yAxisLabelsContainer.appendChild(yLabel);
          }
        }
        if (price + yTicks <= price) break;
      }

      const xTickDensity = Math.max(3, Math.round(chartWidth / 70));
      const xTicks = Math.max(1, calculateNiceStep(visibleCount, xTickDensity));
      for (let i = 0; i < visibleCount; i++) {
        const dataIndex = visibleStartIndex + i;
        if (dataIndex >= 0 && dataIndex < fullData.length) {
          const isTick = (i + Math.floor(xTicks / 4)) % xTicks === 0;
          if (i === 0 || isTick || (xTicks === 1 && i % 5 === 0)) {
            const candleData = fullData[dataIndex];
            if (!candleData) continue;
            const timestamp = candleData[0];
            const x = i * candleTotalWidth + candleTotalWidth / 2;
            if (x >= -candleTotalWidth && x <= chartWidth + candleTotalWidth) {
              const xLabel = document.createElement("div");
              xLabel.className = "axis-label x-axis-label";
              xLabel.style.left = `${x.toFixed(1)}px`;
              xLabel.textContent = formatTimestamp(timestamp);
              xAxisLabelsContainer.appendChild(xLabel);
            }
          }
        }
      }
    } catch (e) {
      console.error("Error drawing axes/grid:", e);
    }

    // Draw Candles
    try {
      for (let i = 0; i < visibleCount; i++) {
        const dataIndex = visibleStartIndex + i;
        if (dataIndex >= 0 && dataIndex < fullData.length) {
          const candle = fullData[dataIndex];
          if (!candle || candle.length < 5) continue;
          const [timestamp, open, high, low, close] = candle;
          const wickHighY = chartHeight - (high - minVisiblePrice) * scaleY;
          const wickLowY = chartHeight - (low - minVisiblePrice) * scaleY;
          const bodyTopY =
            chartHeight - (Math.max(open, close) - minVisiblePrice) * scaleY;
          const bodyBottomY =
            chartHeight - (Math.min(open, close) - minVisiblePrice) * scaleY;
          const wickHeight = Math.max(1, wickLowY - wickHighY);
          const bodyHeight = Math.max(1, bodyBottomY - bodyTopY);
          const isUp = close >= open;

          const candleElement = document.createElement("div");
          candleElement.className = "candle";
          candleElement.style.width = `${candleWidth}px`;
          candleElement.style.marginLeft = `${
            i === 0 ? candleMargin : candleMargin * 2
          }px`;

          const wickElement = document.createElement("div");
          wickElement.className = "wick";
          wickElement.style.top = `${wickHighY.toFixed(1)}px`;
          wickElement.style.height = `${wickHeight.toFixed(1)}px`;

          const bodyElement = document.createElement("div");
          bodyElement.className = `body ${isUp ? "color-up" : "color-down"}`; // CSS handles color via these classes
          bodyElement.style.top = `${bodyTopY.toFixed(1)}px`;
          bodyElement.style.height = `${bodyHeight.toFixed(1)}px`;

          candleElement.appendChild(wickElement);
          candleElement.appendChild(bodyElement);
          chartArea.appendChild(candleElement);
        }
      }
    } catch (e) {
      console.error("Error drawing candles:", e);
    }
  }

  // --- Event Handlers ---
  function handleZoom(event) {
    event.preventDefault();
    const chartRect = chartArea.getBoundingClientRect();
    const mouseX = event.clientX - chartRect.left;
    const mouseY = event.clientY - chartRect.top;
    const chartHeight = chartArea.offsetHeight;
    const chartWidth = chartArea.offsetWidth;
    if (!chartHeight || !chartWidth) return;

    const priceRange = maxVisiblePrice - minVisiblePrice;
    if (priceRange <= 0) return;

    // Y-Axis Zoom
    const priceAtCursor = maxVisiblePrice - (mouseY / chartHeight) * priceRange;
    const zoomAmountY =
      event.deltaY < 0 ? 1 - ZOOM_FACTOR_Y : 1 + ZOOM_FACTOR_Y;
    let newMinVisiblePrice =
      priceAtCursor - (priceAtCursor - minVisiblePrice) * zoomAmountY;
    let newMaxVisiblePrice =
      priceAtCursor + (maxVisiblePrice - priceAtCursor) * zoomAmountY;
    if (newMaxVisiblePrice - newMinVisiblePrice < MIN_PRICE_RANGE_SPAN) {
      const mid = (newMaxVisiblePrice + newMinVisiblePrice) / 2;
      newMinVisiblePrice = mid - MIN_PRICE_RANGE_SPAN / 2;
      newMaxVisiblePrice = mid + MIN_PRICE_RANGE_SPAN / 2;
    }

    // X-Axis Zoom
    const currentVisibleCount = visibleEndIndex - visibleStartIndex;
    if (currentVisibleCount <= 0) return;
    const indexAtCursor =
      visibleStartIndex + (mouseX / chartWidth) * currentVisibleCount;
    const zoomAmountX =
      event.deltaY < 0 ? 1 - ZOOM_FACTOR_X : 1 + ZOOM_FACTOR_X;
    let newVisibleCount = Math.round(currentVisibleCount * zoomAmountX);
    newVisibleCount = Math.max(
      MIN_VISIBLE_CANDLES,
      Math.min(newVisibleCount, fullData.length * 2)
    );
    let newStartIndex = Math.round(
      indexAtCursor - (mouseX / chartWidth) * newVisibleCount
    );
    let newEndIndex = newStartIndex + newVisibleCount;

    // No clamping for infinite scroll
    visibleStartIndex = newStartIndex;
    visibleEndIndex = newEndIndex;
    minVisiblePrice = newMinVisiblePrice;
    maxVisiblePrice = newMaxVisiblePrice;

    requestAnimationFrame(redrawChart);
  }

  function handleMouseDownChart(event) {
    isPanning = true;
    isDraggingYAxis = false;
    isDraggingXAxis = false;
    panStartX = event.clientX;
    panStartY = event.clientY;
    panStartVisibleIndex = visibleStartIndex;
    panStartMinPrice = minVisiblePrice;
    panStartMaxPrice = maxVisiblePrice;
    panStartVisibleCount = visibleEndIndex - visibleStartIndex;
    chartContainer.classList.add("panning");
  }

  function handleMouseDownYAxis(event) {
    event.stopPropagation();
    isDraggingYAxis = true;
    isPanning = false;
    isDraggingXAxis = false;
    panStartY = event.clientY;
    panStartMinPrice = minVisiblePrice;
    panStartMaxPrice = maxVisiblePrice;
  }

  function handleMouseDownXAxis(event) {
    event.stopPropagation();
    isDraggingXAxis = true;
    isPanning = false;
    isDraggingYAxis = false;
    panStartX = event.clientX;
    panStartVisibleIndex = visibleStartIndex;
    panStartVisibleCount = visibleEndIndex - visibleStartIndex;
  }

  function handleMouseMove(event) {
    if (!isPanning && !isDraggingYAxis && !isDraggingXAxis) return;

    const now = Date.now();
    if (now - lastDrawTime < MOUSE_MOVE_THROTTLE) return;

    let needsRedraw = false;

    if (isDraggingYAxis) {
      const deltaY = event.clientY - panStartY;
      const chartHeight = chartArea.offsetHeight;
      if (!chartHeight) return;
      const initialRange = panStartMaxPrice - panStartMinPrice;
      if (initialRange <= 0) return;
      const midPrice = (panStartMaxPrice + panStartMinPrice) / 2;
      const scaleFactor = Math.pow(
        2,
        (deltaY / chartHeight) * Y_AXIS_DRAG_SENSITIVITY
      );
      let newRange = initialRange * scaleFactor;
      newRange = Math.max(MIN_PRICE_RANGE_SPAN, newRange);
      const newMin = midPrice - newRange / 2;
      const newMax = midPrice + newRange / 2;
      if (
        Math.abs(newMin - minVisiblePrice) > 1e-9 ||
        Math.abs(newMax - maxVisiblePrice) > 1e-9
      ) {
        minVisiblePrice = newMin;
        maxVisiblePrice = newMax;
        needsRedraw = true;
      }
    } else if (isDraggingXAxis) {
      const deltaX = event.clientX - panStartX;
      const chartWidth = chartArea.offsetWidth;
      if (!chartWidth || panStartVisibleCount <= 0) return;
      const centerIndex = panStartVisibleIndex + panStartVisibleCount / 2;
      const scaleFactor = Math.pow(
        2,
        (deltaX / chartWidth) * X_AXIS_DRAG_SENSITIVITY
      );
      let newVisibleCount = Math.round(panStartVisibleCount * scaleFactor);
      newVisibleCount = Math.max(
        MIN_VISIBLE_CANDLES,
        Math.min(newVisibleCount, fullData.length * 2)
      );
      let newStartIndex = Math.round(centerIndex - newVisibleCount / 2);
      let newEndIndex = newStartIndex + newVisibleCount;

      if (
        newStartIndex !== visibleStartIndex ||
        newEndIndex !== visibleEndIndex
      ) {
        visibleStartIndex = newStartIndex;
        visibleEndIndex = newEndIndex;
        needsRedraw = true;
      }
    } else if (isPanning) {
      const deltaX = event.clientX - panStartX;
      const deltaY = event.clientY - panStartY;
      const chartHeight = chartArea.offsetHeight;
      const chartWidth = chartArea.offsetWidth;
      if (!chartWidth || !chartHeight) return;

      let changedX = false;
      let changedY = false;

      if (panStartVisibleCount > 0) {
        const indexDelta = (deltaX / chartWidth) * panStartVisibleCount;
        let newStartIndex = panStartVisibleIndex - Math.round(indexDelta);
        if (newStartIndex !== visibleStartIndex) {
          visibleStartIndex = newStartIndex;
          visibleEndIndex = newStartIndex + panStartVisibleCount;
          changedX = true;
        }
      }

      const initialPriceRange = panStartMaxPrice - panStartMinPrice;
      if (initialPriceRange > 0) {
        const priceDelta = (deltaY / chartHeight) * initialPriceRange;
        const newMinPrice = panStartMinPrice + priceDelta;
        const newMaxPrice = panStartMaxPrice + priceDelta;
        if (
          Math.abs(newMinPrice - minVisiblePrice) > 1e-9 ||
          Math.abs(newMaxPrice - maxVisiblePrice) > 1e-9
        ) {
          minVisiblePrice = newMinPrice;
          maxVisiblePrice = newMaxPrice;
          changedY = true;
        }
      }
      needsRedraw = changedX || changedY;
    }

    if (needsRedraw) {
      lastDrawTime = now;
      requestAnimationFrame(redrawChart);
    }
  }

  function handleMouseUpOrLeave(event) {
    if (isPanning || isDraggingYAxis || isDraggingXAxis) {
      isPanning = false;
      isDraggingYAxis = false;
      isDraggingXAxis = false;
      chartContainer.classList.remove("panning");
    }
  }

  let resizeTimeout;
  function handleResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      requestAnimationFrame(redrawChart);
    }, DEBOUNCE_DELAY);
  }

  function handleDoubleClick(event) {
    if (!fullData.length) return;
    const chartRect = chartArea.getBoundingClientRect();
    const mouseX = event.clientX - chartRect.left;
    const chartWidth = chartArea.offsetWidth;
    if (!chartWidth) return;

    const currentVisibleCount = visibleEndIndex - visibleStartIndex;
    const fractionalIndex =
      visibleStartIndex + (mouseX / chartWidth) * currentVisibleCount;
    let targetIndex = Math.round(fractionalIndex);
    targetIndex = Math.max(0, Math.min(targetIndex, fullData.length - 1));

    let newVisibleCount = Math.min(DEFAULT_RESET_CANDLE_COUNT, fullData.length);
    let newStartIndex = Math.round(targetIndex - newVisibleCount / 2);
    newStartIndex = Math.max(
      0,
      Math.min(newStartIndex, fullData.length - newVisibleCount)
    );
    let newEndIndex = Math.min(
      fullData.length,
      newStartIndex + newVisibleCount
    );
    newStartIndex = Math.max(0, newEndIndex - newVisibleCount);

    let newMin = Infinity,
      newMax = -Infinity;
    for (let i = newStartIndex; i < newEndIndex; i++) {
      if (!fullData[i] || fullData[i].length < 4) continue;
      newMin = Math.min(newMin, fullData[i][3]);
      newMax = Math.max(newMax, fullData[i][2]);
    }
    if (newMin === Infinity) {
      newMin = 0;
      newMax = 1;
    }

    const padding = Math.max(
      MIN_PRICE_RANGE_SPAN * 0.1,
      (newMax - newMin) * Y_AXIS_PRICE_PADDING_FACTOR
    );
    let newMinPrice = Math.max(0, newMin - padding);
    let newMaxPrice = newMax + padding;
    if (newMaxPrice - newMinPrice < MIN_PRICE_RANGE_SPAN) {
      const mid = (newMaxPrice + newMinPrice) / 2;
      newMinPrice = mid - MIN_PRICE_RANGE_SPAN / 2;
      newMaxPrice = mid + MIN_PRICE_RANGE_SPAN / 2;
    }

    visibleStartIndex = newStartIndex;
    visibleEndIndex = newEndIndex;
    minVisiblePrice = newMinPrice;
    maxVisiblePrice = newMaxPrice;

    requestAnimationFrame(redrawChart);
  }

  // --- Initialization ---
  function initializeChart(data) {
    fullData = data;
    if (!fullData.length) {
      chartMessage.textContent = "No data loaded.";
      chartMessage.style.display = "block";
      return;
    }
    const initialVisibleCount = Math.min(
      DEFAULT_RESET_CANDLE_COUNT,
      fullData.length
    );
    visibleStartIndex = Math.max(0, fullData.length - initialVisibleCount);
    visibleEndIndex = fullData.length;

    let initialMin = Infinity,
      initialMax = -Infinity;
    for (let i = visibleStartIndex; i < visibleEndIndex; i++) {
      if (!fullData[i] || fullData[i].length < 4) continue;
      initialMin = Math.min(initialMin, fullData[i][3]);
      initialMax = Math.max(initialMax, fullData[i][2]);
    }
    if (initialMin === Infinity) {
      initialMin = 0;
      initialMax = 1;
    }
    const padding = Math.max(
      MIN_PRICE_RANGE_SPAN * 0.1,
      (initialMax - initialMin) * Y_AXIS_PRICE_PADDING_FACTOR
    );
    minVisiblePrice = Math.max(0, initialMin - padding);
    maxVisiblePrice = initialMax + padding;
    if (maxVisiblePrice - minVisiblePrice < MIN_PRICE_RANGE_SPAN) {
      const mid = (maxVisiblePrice + minVisiblePrice) / 2;
      minVisiblePrice = mid - MIN_PRICE_RANGE_SPAN / 2;
      maxVisiblePrice = mid + MIN_PRICE_RANGE_SPAN / 2;
    }

    chartContainer.addEventListener("wheel", handleZoom, { passive: false });
    chartContainer.addEventListener("mousedown", handleMouseDownChart);
    yAxisLabelsContainer.addEventListener("mousedown", handleMouseDownYAxis);
    xAxisLabelsContainer.addEventListener("mousedown", handleMouseDownXAxis);
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUpOrLeave);
    window.addEventListener("resize", handleResize);
    chartContainer.addEventListener("dblclick", handleDoubleClick);

    chartMessage.style.display = "none";
    requestAnimationFrame(redrawChart);
  }

  // --- Data Fetching and Startup ---
  document.addEventListener("DOMContentLoaded", () => {
    fetch("btc_data.json")
      .then((response) => {
        if (!response.ok) {
          throw new Error(
            `HTTP error ${response.status} (${response.statusText}) loading btc_data.json`
          );
        }
        return response.json();
      })
      .then((data) => {
        if (Array.isArray(data)) {
          console.log(`Loaded ${data.length} data points.`);
          initializeChart(data.slice().reverse());
        } else {
          throw new Error("Loaded data is not an array.");
        }
      })
      .catch((error) => {
        console.error("Chart Error:", error);
        chartMessage.textContent = `Error: ${error.message}. Check console & network tab. Ensure using web server.`;
        chartMessage.style.display = "block";
      });
  });
})(); // End IIFE

```
--- END FILE: chart.js ---


--- START FILE: create_context.sh ---
```sh
#!/bin/bash

# --- Configuration ---
OUTPUT_FILE="GeminiTrader.txt"
README_FILE="README.md" # Define the README filename

# File extensions/names to include
INCLUDE_PATTERNS='\.py$|\.js$|\.jsx$|\.ts$|\.tsx$|\.html$|\.css$|\.scss$|\.md$|\.json$|\.yaml$|\.yml$|\.txt$|\.sh$|Dockerfile|Makefile'

# Directory/file patterns to exclude (uses grep -E syntax)
# Add README_FILE to the base exclusion for the main loop later
BASE_EXCLUDE_PATTERNS='/\.git/|/node_modules/|/dist/|/build/|/venv/|/\.venv/|/__pycache__/|/\.vscode/|/\.idea/|/coverage/|/\.DS_Store|^./'"${OUTPUT_FILE}"'$'

# --- Script ---
echo "Creating context file with readme and code blocks: $OUTPUT_FILE" # Updated message
# Clear the output file
> "$OUTPUT_FILE"

# --- 1. README File --- (Moved to be the first section)
if [ -f "$README_FILE" ]; then
    echo "Processing: $README_FILE (as introduction)"
    echo "--- START FILE: $README_FILE ---" >> "$OUTPUT_FILE"
    echo "\`\`\`markdown" >> "$OUTPUT_FILE"
    cat "$README_FILE" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE" # Ensure newline before fence
    echo "\`\`\`" >> "$OUTPUT_FILE"
    echo "--- END FILE: $README_FILE ---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
else
    echo "[ $README_FILE not found in project root, starting with other files. ]" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
fi

# --- 2. Individual Files --- (Renumbered section)
echo "--- START ALL OTHER PROJECT FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# Add README_FILE to exclusions for the main find command
# Use printf for safer path construction if README_FILE had special chars
EXCLUDE_PATTERNS_FOR_FIND="${BASE_EXCLUDE_PATTERNS}"
printf -v readme_pattern '|^./%s$' "$README_FILE"
EXCLUDE_PATTERNS_FOR_FIND+="${readme_pattern}"

# Find all files, filter out excluded patterns, filter for included patterns
find . -type f -print0 | grep -zEv "$EXCLUDE_PATTERNS_FOR_FIND" | grep -zE "$INCLUDE_PATTERNS" | while IFS= read -r -d $'\0' file; do
    # Clean file path for display (remove leading ./)
    display_file="${file#./}"
    echo "Processing: $display_file"

    # --- Determine Language Hint ---
    ext_raw="${file##*.}"
    base_name=$(basename "$file")
    lang_hint="text"
    if [[ "$ext_raw" != "$base_name" ]] && [[ ! -z "$ext_raw" ]]; then
        lang_hint=$(echo "$ext_raw" | tr '[:upper:]' '[:lower:]')
        case "$lang_hint" in
            "mjs"|"jsx") lang_hint="javascript" ;;
            "tsx") lang_hint="typescript" ;;
            "yml") lang_hint="yaml" ;;
            # Add other specific mappings
        esac
    else
        case "$base_name" in
            "Dockerfile") lang_hint="dockerfile" ;;
            "Makefile") lang_hint="makefile" ;;
        esac
        if [[ "$lang_hint" == "text" ]] && [[ "$base_name" == .* ]]; then
            case "$base_name" in
                ".bashrc"|".profile") lang_hint="bash" ;;
                ".gitignore") lang_hint="gitignore" ;;
                ".env") lang_hint="dotenv" ;;
                # Add more hidden file types
            esac
        fi
    fi

    # --- Append to Output File ---
    echo "--- START FILE: $display_file ---" >> "$OUTPUT_FILE"
    echo "\`\`\`${lang_hint}" >> "$OUTPUT_FILE"
    cat "$file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE" # Ensure newline before fence
    echo "\`\`\`" >> "$OUTPUT_FILE"
    echo "--- END FILE: $display_file ---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"

done

echo "--- END ALL OTHER PROJECT FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "Finished creating $OUTPUT_FILE"
```
--- END FILE: create_context.sh ---


--- START FILE: credentials/cdp_api_key.json ---
```json
{
   "name": "organizations/be8ab444-9ab3-40f7-ae48-5cac5ea99bf7/apiKeys/384cfa64-a2de-4c9f-ac83-4aa59e394e89",
   "privateKey": "-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEICuKcV0qXSCOIXObz6jaMCjP+T+QxbHR8GS8uW6qSQeRoAoGCCqGSM49\nAwEHoUQDQgAEOCSdUfcZksYetcpjP9rmjOR5ighwLO309cWchcxnPZ99vo+U51fX\nF3T+N4snZD/14Yhr2RRVwEykKVA+ygmJFQ==\n-----END EC PRIVATE KEY-----\n"
}
```
--- END FILE: credentials/cdp_api_key.json ---


--- START FILE: credentials/cdp_api_key_example.json ---
```json
{
   "name": "organizations/XXXXXXXXXXXXXXXXXXXXXXXX",
   "privateKey": "-----BEGIN EC PRIVATE KEY-----\nXXXXXXXXXXXXXXXXXXXXXXXX\n-----END EC PRIVATE KEY-----\n"
}
```
--- END FILE: credentials/cdp_api_key_example.json ---


--- START FILE: index.html ---
```html
<!DOCTYPE html>
<html lang="en"> <!-- data-theme attribute will be set by JS -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive BTC Candlestick Chart</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="main-layout">

        <!-- Header Area -->
        <div class="header-area">
            <div class="top-left-info">
                <div class="status-indicator">
                    API Status: <span id="api-status-indicator">Checking...</span>
                </div>
            </div>
            <div class="header-content">
                <h1>Interactive BTC/USD Candlestick Chart</h1>
                <p class="instructions">Scroll=Zoom | Drag Chart=Pan | Drag Axes=Scale | Dbl-Click=Reset | Hover=Info/Crosshair</p>
            </div>
            <div class="header-controls">
                <div class="granularity-controls" id="granularity-controls">
                    <span>Interval:</span>
                    <button data-granularity="300">5m</button>
                    <button data-granularity="900">15m</button>
                    <button data-granularity="3600" class="active">1h</button>
                    <button data-granularity="21600">6h</button>
                    <button data-granularity="86400">1d</button>
                </div>
                <div class="settings-group">
                    <button id="settings-button" class="icon-button" title="Chart Settings">⚙️</button>
                    <div id="settings-dropdown" class="dropdown-menu">
                        <div class="dropdown-item">
                            <span>Dark Theme</span>
                            <div class="theme-switch-wrapper">
                                <label class="theme-switch" for="theme-checkbox">
                                    <input type="checkbox" id="theme-checkbox" />
                                    <div class="slider"></div>
                                </label>
                            </div>
                        </div>
                        <div class="dropdown-item">
                             <span>Log Scale (Y-Axis)</span>
                            <div class="log-scale-switch-wrapper">
                                <label class="theme-switch" for="log-scale-checkbox">
                                    <input type="checkbox" id="log-scale-checkbox" />
                                    <div class="slider"></div>
                                </label>
                            </div>
                        </div>
                        <div class="dropdown-item">
                             <span>12-Hour Time (AM/PM)</span>
                            <div class="time-format-switch-wrapper">
                                <label class="theme-switch" for="time-format-checkbox">
                                    <input type="checkbox" id="time-format-checkbox" />
                                    <div class="slider"></div>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <!-- Content Area -->
        <div class="content-area" id="content-area">

            <!-- Top Pane (Now includes Main Chart + Volume) -->
            <div class="chart-pane" id="chart-pane">
                 <!-- Main Candlestick Chart Container -->
                <div class="chart-container" id="chart-container">
                    <div class="chart-wrapper">
                        <div class="grid-container" id="grid-container"></div>
                        <div class="chart-area" id="chart-area"></div>
                        <div class="y-axis-labels" id="y-axis-labels"></div>
                        <div class="x-axis-labels" id="x-axis-labels"></div>
                        <div class="current-price-line" id="current-price-line" style="display: none;"></div>
                        <div class="current-price-label" id="current-price-label" style="display: none;">-</div>
                        <div class="crosshair-line-x" id="crosshair-line-x" style="display: none;"></div>
                        <div class="crosshair-label-y" id="crosshair-label-y" style="display: none;">-</div>
                        <div class="chart-tooltip" id="chart-tooltip" style="display: none; opacity: 0;"></div>
                    </div>
                    <div id="chart-message">Loading data...</div>
                </div>

                <!-- <<< Volume Chart Container >>> -->
                <div class="sub-chart-container volume-chart-container" id="volume-chart-container">
                    <canvas id="volume-chart-canvas"></canvas>
                     <div class="sub-chart-y-axis-labels" id="volume-y-axis-labels"></div>
                </div>
                 <!-- <<< END Volume Chart Container >>> -->

            </div>

            <!-- Resizer Handle -->
            <div class="resizer" id="resizer"></div>

            <!-- Bottom Pane (Tabbed Interface) -->
            <div class="tab-container" id="bottom-pane">
                <div class="tab-bar" id="bottom-tab-bar">
                    <button class="tab-button active" data-target="positions-content">Positions</button>
                    <button class="tab-button" data-target="open-orders-content">Open Orders</button>
                    <button class="tab-button" data-target="order-history-content">Order History</button>
                    <button class="tab-button" data-target="prompt-content">Prompt</button>
                </div>
                <div class="tab-content-area">
                    <div id="positions-content" class="tab-content active">
                        <div class="balance-content">
                             <ul class="balance-list" id="balance-list">
                                 <li class="loading">Loading balances...</li>
                             </ul>
                             <div class="balance-total" id="balance-total">
                                 <span>Approx. Total (USD):</span>
                                 <span id="total-usd-value">--.--</span>
                                 <small id="total-usd-partial-notice" style="display: none;"> (Partial)</small>
                             </div>
                        </div>
                    </div>
                    <div id="open-orders-content" class="tab-content">
                        <!-- Content dynamically generated by js/orders.js -->
                    </div>
                    <div id="order-history-content" class="tab-content">
                         <div class="pane-placeholder">
                             <p>Order History will be displayed here.</p>
                             <small>(Requires backend implementation)</small>
                         </div>
                    </div>
                    <div id="prompt-content" class="tab-content">
                         <textarea id="prompt-textarea" placeholder="Enter your strategy prompt or notes here..."></textarea>
                    </div>
                </div>
            </div>

        </div>

    </div>

    <script type="module" src="js/main.js" defer></script>
    {/* Volume chart now initialized via main.js import */}

</body>
</html>
```
--- END FILE: index.html ---


--- START FILE: js/balance.js ---
```js
// js/balance.js

import * as dom from "./domElements.js";
import { formatCurrency, formatQuantity } from "./utils.js";
import { BALANCE_DUST_THRESHOLD_USD } from "./config.js"; // Import threshold
import state, { updateLatestPrice } from "./state.js"; // Import state and price update function

const DUST_SUMMARY_CLASS = "balance-list-dust-summary";
const DUST_ITEM_CLASS = "balance-list-dust-item";
const DUST_VISIBLE_CLASS = "dust-visible"; // Class added to UL when dust is shown

/**
 * Fetches the current ticker price for a single product ID from the backend.
 * @param {string} productId (e.g., "ETH-USD")
 * @returns {Promise<number|null>} Resolves with the price number or null.
 */
async function fetchTickerPrice(productId) {
  if (!productId) return null;
  const url = `http://localhost:5000/api/ticker?product_id=${productId}`;
  try {
    const response = await fetch(url);
    if (!response.ok) {
      console.warn(
        `Ticker fetch failed for ${productId}: ${response.status} ${response.statusText}`
      );
      try {
        const errorData = await response.json();
        console.warn(
          ` -> API Error: ${errorData?.message || response.statusText}`
        );
      } catch {}
      return null;
    }
    const data = await response.json();
    const price = parseFloat(data?.price);
    return !isNaN(price) ? price : null;
  } catch (error) {
    console.error(`Network error fetching ticker for ${productId}:`, error);
    return null;
  }
}

/**
 * Renders a single balance list item.
 * Stores currency and quantity in data attributes for later updates.
 * @param {object} acc - The processed account object (with totalBalance, usdValue).
 * @param {boolean} isDustItem - Flag to add the dust item class.
 */
function renderBalanceItem(acc, isDustItem = false) {
  const { currency, totalBalance, usdValue } = acc;

  const li = document.createElement("li");
  // Store currency and quantity for easy access during live updates
  li.dataset.currency = currency;
  li.dataset.quantity = totalBalance.toString(); // Store as string
  if (isDustItem) {
    li.classList.add(DUST_ITEM_CLASS);
  }

  const codeSpan = document.createElement("span");
  codeSpan.className = "asset-code";
  codeSpan.textContent = currency;

  const qtySpan = document.createElement("span");
  qtySpan.className = "asset-qty";
  qtySpan.textContent = formatQuantity(totalBalance);

  const valueSpan = document.createElement("span");
  valueSpan.className = "asset-value";
  if (usdValue !== null && Number.isFinite(usdValue)) {
    // Check finiteness
    valueSpan.textContent = formatCurrency(usdValue);
  } else {
    valueSpan.textContent = `(?.?? USD)`;
  }

  li.appendChild(codeSpan);
  li.appendChild(qtySpan);
  li.appendChild(valueSpan);
  dom.balanceList.appendChild(li);
}

/**
 * Updates the balance pane HTML with fetched account data and prices.
 * Partitions into Main/Dust, sorts, and renders with collapsible dust section.
 * @param {Array} accounts - Array of account objects from the API.
 * @param {Map<string, number>} prices - Map of currency codes (UPPERCASE) to their initial USD prices.
 */
function updateBalancePaneUI(accounts, prices) {
  if (!dom.balanceList || !dom.balanceTotalValue || !dom.balancePartialNotice) {
    console.error("Balance pane DOM elements not found for UI update.");
    return;
  }
  dom.balanceList.innerHTML = ""; // Clear previous list items
  dom.balanceList.classList.remove(DUST_VISIBLE_CLASS);
  let totalUsdValue = 0;
  let partialTotal = false;

  if (!Array.isArray(accounts)) {
    dom.balanceList.innerHTML =
      '<li class="error">Invalid account data structure received.</li>';
    console.error("updateBalancePaneUI expected an array, got:", accounts);
    accounts = [];
  }

  const ZERO_THRESHOLD = 1e-9;
  const mainBalances = [];
  const dustBalances = [];

  // 1. Map accounts, calculate values, and partition into main/dust
  accounts.forEach((acc) => {
    const currency = acc?.currency?.toUpperCase();
    const availableString = acc?.available_balance?.value ?? "0";
    const holdString = acc?.hold?.value ?? "0";
    const availableBalance = parseFloat(availableString);
    const holdBalance = parseFloat(holdString);

    if (!currency || isNaN(availableBalance) || isNaN(holdBalance)) {
      return; // Skip invalid account data
    }

    const totalBalance = availableBalance + holdBalance;

    if (Math.abs(totalBalance) < ZERO_THRESHOLD) {
      return; // Skip zero balance
    }

    let usdValue = null;
    if (currency === "USD") {
      usdValue = totalBalance;
    } else if (currency === "USDT" || currency === "USDC") {
      usdValue = totalBalance * 1.0;
    } else {
      const price = prices.get(currency); // Use initial prices map here
      if (price !== undefined && price !== null && Number.isFinite(price)) {
        usdValue = totalBalance * price;
      } else {
        partialTotal = true;
      }
    }

    // Accumulate total value (do this *before* partitioning)
    if (usdValue !== null && Number.isFinite(usdValue)) {
      totalUsdValue += usdValue;
    }

    const processedAcc = {
      ...acc,
      currency,
      totalBalance,
      usdValue, // Initial USD value
    };

    // Partition based on USD value
    if (
      usdValue !== null &&
      Number.isFinite(usdValue) &&
      usdValue < BALANCE_DUST_THRESHOLD_USD
    ) {
      dustBalances.push(processedAcc);
    } else {
      mainBalances.push(processedAcc);
    }
  });

  // 2. Sort the main balances
  mainBalances.sort((a, b) => {
    if (a.currency === "USD") return -1;
    if (b.currency === "USD") return 1;
    const valueA = a.usdValue ?? -Infinity;
    const valueB = b.usdValue ?? -Infinity;
    if (valueB !== valueA) return valueB - valueA; // Desc value
    return (a.currency || "").localeCompare(b.currency || ""); // Asc currency
  });

  // 3. Sort the dust balances
  dustBalances.sort((a, b) => {
    return (a.currency || "").localeCompare(b.currency || ""); // Asc currency
  });

  // 4. Render Main Balances
  mainBalances.forEach((acc) => renderBalanceItem(acc, false));

  // 5. Render Dust Section
  if (dustBalances.length > 0) {
    const dustLi = document.createElement("li");
    dustLi.classList.add(DUST_SUMMARY_CLASS);
    dustLi.innerHTML = `
          <span class="asset-code">Dust</span>
          <span class="asset-qty">(${dustBalances.length} items)</span>
          <span class="asset-value">(click to show)</span> <!-- Initial text -->
      `;
    dom.balanceList.appendChild(dustLi);
    dustBalances.forEach((acc) => renderBalanceItem(acc, true));
  }

  // --- Final UI Updates ---
  if (dom.balanceList.children.length === 0) {
    dom.balanceList.innerHTML = '<li class="info">No balances found.</li>';
  } else if (mainBalances.length === 0 && dustBalances.length === 0) {
    dom.balanceList.innerHTML =
      '<li class="info">No non-zero balances found.</li>';
  }

  dom.balanceTotalValue.textContent = formatCurrency(totalUsdValue);
  dom.balancePartialNotice.style.display = partialTotal ? "inline" : "none";
}

/**
 * Updates ONLY the USD values and total in the already rendered balance list.
 * Reads quantities and currencies from data attributes.
 * Uses latest prices from the global state.
 */
export function updateBalanceValuesUI() {
  if (!dom.balanceList || !dom.balanceTotalValue || !dom.balancePartialNotice) {
    // console.warn("Cannot update balance values: UI elements missing.");
    return;
  }
  // console.log("Updating balance values..."); // Debug

  let newTotalUsdValue = 0;
  let partialTotal = false; // Re-evaluate if any prices are missing now

  const listItems = dom.balanceList.querySelectorAll(
    "li[data-currency][data-quantity]"
  );

  listItems.forEach((li) => {
    const currency = li.dataset.currency;
    const quantity = parseFloat(li.dataset.quantity);
    const valueSpan = li.querySelector(".asset-value");

    if (!currency || isNaN(quantity) || !valueSpan) {
      console.warn(
        "Skipping update for list item, missing data or element:",
        li
      );
      return; // Skip malformed items
    }

    let usdValue = null;
    if (currency === "USD") {
      usdValue = quantity;
    } else if (currency === "USDT" || currency === "USDC") {
      usdValue = quantity * 1.0;
    } else {
      // Get the LATEST price from global state
      const price = state.latestPrices.get(currency);

      if (price !== undefined && price !== null && Number.isFinite(price)) {
        usdValue = quantity * price;
      } else {
        // console.log(`No valid price found in state for ${currency}`); // Debug
        partialTotal = true; // If price is missing now, total is partial
      }
    }

    // Update the value span text
    if (usdValue !== null && Number.isFinite(usdValue)) {
      valueSpan.textContent = formatCurrency(usdValue);
      newTotalUsdValue += usdValue; // Add to the new total
    } else {
      valueSpan.textContent = `(?.?? USD)`; // Keep placeholder if value unknown
    }

    // Re-check dust partitioning? (More complex - maybe skip for now)
    // If an item *becomes* dust or *stops being* dust due to price changes,
    // it would require moving the element in the DOM or re-rendering.
    // For simplicity, let's just update values in place for now.
    // Re-partitioning could be added later if needed.
  });

  // Update the total value display
  dom.balanceTotalValue.textContent = formatCurrency(newTotalUsdValue);
  dom.balancePartialNotice.style.display = partialTotal ? "inline" : "none";
}

/**
 * Attaches the click listener for the dust category toggle using event delegation.
 */
function attachDustToggleListener() {
  if (!dom.balanceList) return;
  dom.balanceList.removeEventListener("click", handleDustClick);
  dom.balanceList.addEventListener("click", handleDustClick);
  console.log("Dust toggle listener attached.");
}

/**
 * Handles clicks on the balance list, specifically toggling dust visibility.
 * @param {Event} event - The click event object.
 */
function handleDustClick(event) {
  const summaryItem = event.target.closest(`.${DUST_SUMMARY_CLASS}`);
  if (summaryItem) {
    dom.balanceList.classList.toggle(DUST_VISIBLE_CLASS);
    // console.log("Dust visibility toggled:", dom.balanceList.classList.contains(DUST_VISIBLE_CLASS));
    const valueSpan = summaryItem.querySelector(".asset-value");
    if (valueSpan) {
      valueSpan.textContent = dom.balanceList.classList.contains(
        DUST_VISIBLE_CLASS
      )
        ? "(click to hide)"
        : "(click to show)";
    }
  }
}

/**
 * Main function to orchestrate fetching account data AND necessary ticker prices,
 * then updating the balance pane UI. Exported for use in main.js.
 */
export async function initializeBalances() {
  console.log("Initializing balances...");
  if (dom.balanceList)
    dom.balanceList.innerHTML = '<li class="loading">Loading balances...</li>';
  if (dom.balanceTotalValue) dom.balanceTotalValue.textContent = "--.--";
  if (dom.balancePartialNotice) dom.balancePartialNotice.style.display = "none";

  attachDustToggleListener();

  try {
    // 1. Fetch Accounts
    const accountsResponse = await fetch("http://localhost:5000/api/accounts");
    const accountsResult = await (async () => {
      const status = accountsResponse.status;
      try {
        const data = await accountsResponse.json();
        if (data && data.accounts && Array.isArray(data.accounts)) {
          return {
            ok: accountsResponse.ok,
            status: status,
            data: data.accounts,
          };
        } else if (Array.isArray(data)) {
          return { ok: accountsResponse.ok, status: status, data: data };
        } else {
          throw new Error("API response does not contain an accounts array.");
        }
      } catch (e) {
        console.error(
          "Failed to parse accounts response or invalid format:",
          e
        );
        let textResponse = "(Could not read text)";
        try {
          textResponse = await accountsResponse.text();
        } catch {}
        throw new Error(
          `Received non-JSON or invalid response (Status: ${status}). Body: ${textResponse}`
        );
      }
    })();

    if (!accountsResult.ok) {
      throw new Error(
        accountsResult.data?.error ||
          `Account API Error (${accountsResult.status})`
      );
    }
    const accounts = accountsResult.data;

    // 2. Identify non-zero crypto assets needing prices
    const cryptoAssetsToPrice = new Set();
    const ZERO_THRESHOLD = 1e-9;
    const stablecoins = new Set(["USD", "USDT", "USDC", "EUR", "GBP"]);

    accounts.forEach((acc) => {
      const currency = acc?.currency?.toUpperCase();
      const availableString = acc?.available_balance?.value ?? "0";
      const holdString = acc?.hold?.value ?? "0";
      const availableBalance = parseFloat(availableString);
      const holdBalance = parseFloat(holdString);

      if (isNaN(availableBalance) || isNaN(holdBalance)) return;
      const totalBalance = availableBalance + holdBalance;

      const isPricableCrypto = currency && !stablecoins.has(currency);
      const isNonZero = Math.abs(totalBalance) >= ZERO_THRESHOLD;

      if (isPricableCrypto && isNonZero) {
        cryptoAssetsToPrice.add(currency);
      }
    });
    console.log("Assets to Fetch Prices For:", Array.from(cryptoAssetsToPrice));

    // 3. Fetch prices concurrently
    const pricePromises = Array.from(cryptoAssetsToPrice).map((currency) => {
      const productId = `${currency}-USD`;
      return fetchTickerPrice(productId).then((price) => ({ currency, price }));
    });
    const priceResults = await Promise.all(pricePromises);

    // 4. Create Price Map AND Update Global State
    const initialPrices = new Map();
    priceResults.forEach((result) => {
      if (result.price !== null && Number.isFinite(result.price)) {
        initialPrices.set(result.currency, result.price);
        // ---> Populate global state with initial prices <---
        updateLatestPrice(result.currency, result.price);
      }
    });
    // Add stablecoins to global state map (price is 1.0)
    updateLatestPrice("USD", 1.0);
    updateLatestPrice("USDC", 1.0);
    updateLatestPrice("USDT", 1.0);
    // Add others if needed

    console.log("Fetched Valid Prices:", Object.fromEntries(initialPrices));
    console.log(
      "Initial Global Prices State:",
      Object.fromEntries(state.latestPrices)
    );

    // 5. Update UI using the initial prices map
    updateBalancePaneUI(accounts, initialPrices);
  } catch (error) {
    console.error("Error initializing balances:", error);
    if (dom.balanceList)
      dom.balanceList.innerHTML = `<li class="error">Error loading balances: ${error.message}</li>`;
    if (dom.balanceTotalValue)
      dom.balanceTotalValue.textContent = formatCurrency(0);
    if (dom.balancePartialNotice)
      dom.balancePartialNotice.style.display = "none";
  }
}

```
--- END FILE: js/balance.js ---


--- START FILE: js/config.js ---
```js
// js/config.js

// --- NEW: Define Theme Background Colors ---
export const LIGHT_MODE_BG_COLOR = "#f0f0f0"; // Default light theme background
export const DARK_MODE_BG_COLOR = "#0f0f19"; // Desired dark theme background (Corrected typo if any)
// --- End Theme Background Colors ---

// Chart configuration constants
export const ZOOM_FACTOR_X = 0.1;
export const ZOOM_FACTOR_Y = 0.1;
export const MIN_VISIBLE_CANDLES = 5;
export const DEFAULT_RESET_CANDLE_COUNT = 100;
export const MIN_PRICE_RANGE_SPAN = 0.1; // Smallest linear price diff allowed
export const Y_AXIS_PRICE_PADDING_FACTOR = 0.05; // Linear scale padding (used for initial load, maybe keep?)
export const Y_AXIS_LOG_PADDING_FACTOR = 0.08; // Multiplicative padding for log scale (used for initial load, maybe keep?)
export const Y_AXIS_RESET_FILL_FACTOR = 0.85; // Target fill % of chart height on double-click reset (e.g., 85%)
export const BALANCE_DUST_THRESHOLD_USD = 0.5; // USD value below which balances are considered "dust"
export const Y_AXIS_DRAG_SENSITIVITY = 2.0;
export const X_AXIS_DRAG_SENSITIVITY = 2.0;
export const MOUSE_MOVE_THROTTLE = 16; // ~60fps
export const DEBOUNCE_DELAY = 100; // Resize debounce
export const TOOLTIP_SHOW_DELAY = 300; // ms delay before showing tooltip
export const TOOLTIP_HIDE_DELAY = 100; // ms delay before hiding tooltip

// API Defaults (used in main.js)
export const DEFAULT_GRANULARITY = 3600; // 1 hour (must be a number)
export const DEFAULT_PRODUCT_ID = "BTC-USD"; // This should be a string

```
--- END FILE: js/config.js ---


--- START FILE: js/domElements.js ---
```js
// js/domElements.js

// Layout Structure
export const mainLayout = document.querySelector(".main-layout");
export const headerArea = document.querySelector(".header-area");
export const contentArea = document.getElementById("content-area");
export const chartPane = document.getElementById("chart-pane");
export const resizer = document.getElementById("resizer");
export const bottomPane = document.getElementById("bottom-pane");

// Chart Specific
export const chartContainer = document.getElementById("chart-container");
export const chartWrapper = chartContainer?.querySelector(".chart-wrapper");
export const chartArea = document.getElementById("chart-area");
export const gridContainer = document.getElementById("grid-container");
export const yAxisLabelsContainer = document.getElementById("y-axis-labels");
export const xAxisLabelsContainer = document.getElementById("x-axis-labels");
export const chartMessage = document.getElementById("chart-message");
export const currentPriceLine = document.getElementById("current-price-line");
export const currentPriceLabel = document.getElementById("current-price-label");
export const chartTooltip = document.getElementById("chart-tooltip");
export const crosshairLineX = document.getElementById("crosshair-line-x");
export const crosshairLabelY = document.getElementById("crosshair-label-y");

// --- UNCOMMENTED: Volume Chart Elements ---
export const volumeChartContainer = document.getElementById(
  "volume-chart-container"
);
export const volumeChartCanvas = document.getElementById("volume-chart-canvas");
export const volumeYAxisLabels = document.getElementById(
  "volume-y-axis-labels"
); // Optional
// --- END UNCOMMENTED ---

// Controls (Header / Settings Menu)
export const headerControls = document.querySelector(".header-controls");
export const granularityControls = document.getElementById(
  "granularity-controls"
);
export const settingsButton = document.getElementById("settings-button");
export const settingsDropdown = document.getElementById("settings-dropdown");

// Switches (Now potentially inside dropdown)
export const themeToggle = document.getElementById("theme-checkbox");
export const logScaleToggle = document.getElementById("log-scale-checkbox");
export const timeFormatToggle = document.getElementById("time-format-checkbox");

// Other UI
export const apiStatusIndicator = document.getElementById(
  "api-status-indicator"
);

// Bottom Pane Tabs
export const bottomTabBar = document.getElementById("bottom-tab-bar");
export const positionsContent = document.getElementById("positions-content");
export const openOrdersContent = document.getElementById("open-orders-content");
export const orderHistoryContent = document.getElementById(
  "order-history-content"
);
export const promptContent = document.getElementById("prompt-content");
export const promptTextarea = document.getElementById("prompt-textarea");

// Balance Pane Specific (Now inside positionsContent)
export const balanceList = document.getElementById("balance-list");
export const balanceTotalValue = document.getElementById("total-usd-value");
export const balancePartialNotice = document.getElementById(
  "total-usd-partial-notice"
);

// Exported map for checkElements to get names
const elementMap = {
  mainLayout,
  headerArea,
  contentArea,
  chartPane,
  resizer,
  bottomPane, // Layout
  chartContainer,
  chartWrapper,
  chartArea,
  gridContainer,
  yAxisLabelsContainer, // Chart Core
  xAxisLabelsContainer,
  chartMessage,
  currentPriceLine,
  currentPriceLabel,
  chartTooltip,
  crosshairLineX,
  crosshairLabelY,
  // --- UNCOMMENTED Volume elements ---
  volumeChartContainer,
  volumeChartCanvas,
  volumeYAxisLabels,
  // --- End Volume elements ---
  headerControls,
  granularityControls,
  settingsButton,
  settingsDropdown, // Header/Settings
  themeToggle,
  logScaleToggle,
  timeFormatToggle, // Switches
  apiStatusIndicator, // Other UI
  bottomTabBar,
  positionsContent,
  openOrdersContent,
  orderHistoryContent,
  promptContent, // Tabs
  promptTextarea, // Prompt Input
  balanceList,
  balanceTotalValue,
  balancePartialNotice, // Balance List (nested)
};

export function checkElements() {
  const missingElements = Object.entries(elementMap)
    .filter(([name, el]) => {
      // Check if the element variable itself is null/undefined
      return !el;
    })
    .map(([name]) => name);

  if (missingElements.length > 0) {
    const missingNames = missingElements.join(", ");
    console.error(
      `Initialization failed: Essential DOM elements missing: ${missingNames}`
    );
    if (chartMessage) {
      chartMessage.textContent = `Error: Missing DOM elements! (${missingNames})`;
      chartMessage.style.display = "block";
      chartMessage.style.color = "red";
    } else {
      alert(
        `Error: Critical DOM elements missing: ${missingNames}! Cannot initialize app. Check console.`
      );
    }
    return false;
  }
  console.log("All essential DOM elements found.");
  return true;
}

```
--- END FILE: js/domElements.js ---


--- START FILE: js/drawing.js ---
```js
// js/drawing.js

import * as config from "./config.js";
import state from "./state.js";
import * as dom from "./domElements.js";
import { drawVolumeChart } from "./volumeChart.js";
import {
  calculateNiceStep,
  formatTimestamp,
  formatDate,
  getYCoordinate,
  MIN_LOG_VALUE,
} from "./utils.js";

const SECONDS_PER_DAY = 86400;
const MIN_PIXELS_PER_LABEL = 60; // Minimum space between labels
const Y_AXIS_MAX_ITERATIONS = 500;

// --- Live Price Indicator ---
function updateLivePriceIndicatorUI(price, chartHeight) {
  /* ... no changes ... */
}

// --- Helper to draw a single Y-axis tick/label ---
function drawYTick(priceValue, chartHeight, minVisible, maxVisible) {
  // Keep previous logging inside this helper for Y-axis issues if they return
  // console.log(`[drawYTick] Trying price: ${priceValue}`);
  if (priceValue <= MIN_LOG_VALUE) {
    return;
  }
  const y = getYCoordinate(priceValue, chartHeight);
  // console.log(`[drawYTick] Calculated Y for ${priceValue}: ${y}`);
  if (y === null || !Number.isFinite(y)) {
    return;
  }
  if (y >= -chartHeight * 0.1 && y <= chartHeight * 1.1) {
    const hLine = document.createElement("div");
    hLine.className = "grid-line horizontal";
    hLine.style.top = `${y.toFixed(1)}px`;
    dom.gridContainer.appendChild(hLine);
  }
  if (y >= -5 && y <= chartHeight + 5) {
    const yLabel = document.createElement("div");
    yLabel.className = "axis-label y-axis-label";
    yLabel.style.top = `${y.toFixed(1)}px`;
    let decimals = 0;
    if (priceValue < 0.01) decimals = 6;
    else if (priceValue < 1) decimals = 4;
    else if (priceValue < 100) decimals = 2;
    else if (priceValue < 10000) decimals = 1;
    else decimals = 0;
    decimals = Math.max(0, decimals);
    yLabel.textContent = priceValue.toFixed(decimals);
    try {
      // Wrap appendChild for safety
      dom.yAxisLabelsContainer.appendChild(yLabel);
      // console.log(`[drawYTick] Appended label for ${priceValue}`);
    } catch (e) {
      console.error(
        `[drawYTick] Error appending Y label for ${priceValue}:`,
        e
      );
    }
  }
}

// --- Main Chart Redraw ---
export function redrawChart() {
  // console.log(`[redrawChart] Function called.`); // Reduce noise

  if (
    !dom.chartArea ||
    !dom.gridContainer ||
    !dom.yAxisLabelsContainer ||
    !dom.xAxisLabelsContainer
  ) {
    console.error("[redrawChart] Missing drawing containers.");
    return;
  }

  dom.chartArea.innerHTML = "";
  dom.gridContainer.innerHTML = "";
  dom.yAxisLabelsContainer.innerHTML = "";
  dom.xAxisLabelsContainer.innerHTML = "";
  if (dom.volumeYAxisLabels) dom.volumeYAxisLabels.innerHTML = "";

  const chartHeight = dom.chartArea.offsetHeight;
  const chartWidth = dom.chartArea.offsetWidth;

  if (!state.fullData || state.fullData.length === 0) {
    console.warn("[redrawChart] No data.");
    return;
  }
  if (chartHeight <= 0 || chartWidth <= 0) {
    console.warn(`[redrawChart] Invalid dimensions.`);
    return;
  }

  const {
    minVisiblePrice,
    maxVisiblePrice,
    isLogScale,
    visibleStartIndex,
    visibleEndIndex,
  } = state;
  const visibleCount = visibleEndIndex - visibleStartIndex;

  if (
    isNaN(minVisiblePrice) ||
    isNaN(maxVisiblePrice) ||
    !Number.isFinite(minVisiblePrice) ||
    !Number.isFinite(maxVisiblePrice) ||
    maxVisiblePrice <= minVisiblePrice ||
    (isLogScale && minVisiblePrice <= 0)
  ) {
    console.error("[redrawChart] Invalid price range.");
    return;
  }
  if (visibleCount <= 0) {
    console.warn(`[redrawChart] visibleCount is ${visibleCount}.`);
    return;
  }

  const candleTotalWidth = chartWidth / visibleCount;
  const candleBodyWidthRatio = 0.7;
  const candleWidth = Math.max(1, candleTotalWidth * candleBodyWidthRatio);
  const candleMargin = Math.max(0.5, (candleTotalWidth - candleWidth) / 2);

  // --- Draw Grid & Y-Axis ---
  try {
    const yTickDensity = Math.max(3, Math.round(chartHeight / 40));
    let iterationCount = 0;
    const linearRange = maxVisiblePrice - minVisiblePrice;
    const linearTicks =
      linearRange > 0 && Number.isFinite(linearRange)
        ? calculateNiceStep(linearRange, yTickDensity)
        : 1;
    if (!linearTicks || linearTicks <= 0 || !Number.isFinite(linearTicks)) {
      /* Handle error */
    } else {
      let firstLinearTick;
      if (minVisiblePrice >= 0) {
        firstLinearTick =
          linearTicks > 0
            ? Math.ceil(minVisiblePrice / linearTicks) * linearTicks
            : minVisiblePrice;
      } else {
        firstLinearTick =
          linearTicks > 0
            ? Math.floor(minVisiblePrice / linearTicks) * linearTicks
            : minVisiblePrice;
      }
      if (
        linearTicks > 0 &&
        firstLinearTick - minVisiblePrice > linearTicks * 0.99
      ) {
        firstLinearTick -= linearTicks;
      }
      if (minVisiblePrice > 0 && firstLinearTick < 0) {
        firstLinearTick = 0;
      }
      const loopUpperBound = maxVisiblePrice + linearTicks * 0.1;
      for (
        let currentPrice = firstLinearTick;
        currentPrice <= loopUpperBound &&
        iterationCount < Y_AXIS_MAX_ITERATIONS;
        currentPrice =
          linearTicks > 0 ? currentPrice + linearTicks : loopUpperBound + 1
      ) {
        iterationCount++;
        drawYTick(currentPrice, chartHeight, minVisiblePrice, maxVisiblePrice);
        if (
          linearTicks > Number.EPSILON &&
          currentPrice + linearTicks <= currentPrice
        ) {
          break;
        }
      }
    }
  } catch (e) {
    console.error("[redrawChart] Error drawing Y grid/axis:", e);
  }

  // --- Draw X-Axis & Separators ---
  let xAxisLabelsDrawnCount = 0;
  try {
    // console.log("[redrawChart] Drawing X-Axis..."); // Reduce noise
    const xTickDensity = Math.max(3, Math.round(chartWidth / 70));
    const xTicks =
      visibleCount > 0
        ? Math.max(1, calculateNiceStep(visibleCount, xTickDensity))
        : 1;
    let lastLabelX = -Infinity;

    for (let i = 0; i < visibleCount; i++) {
      const dataIndex = visibleStartIndex + i;
      if (dataIndex < 0 || dataIndex >= state.fullData.length) continue;
      const candleData = state.fullData[dataIndex];
      if (!candleData || candleData.length < 1 || isNaN(candleData[0]))
        continue;
      const timestamp = candleData[0];

      const isFirst = i === 0;
      const isLast = i === visibleCount - 1;
      const isTickCandidate =
        xTicks > 0 && (i + Math.floor(xTicks / 2)) % xTicks === 0;

      if (isFirst || isLast || isTickCandidate) {
        const x = (i + 0.5) * candleTotalWidth;
        const spacingCondition = x - lastLabelX > MIN_PIXELS_PER_LABEL;

        if (spacingCondition || isFirst || isLast) {
          if (x >= -candleTotalWidth && x <= chartWidth + candleTotalWidth) {
            const xLabel = document.createElement("div");
            xLabel.className = "axis-label x-axis-label";
            xLabel.style.left = `${x.toFixed(1)}px`;

            // <<< Wrap formatTimestamp and appendChild in try...catch >>>
            try {
              const formattedTime = formatTimestamp(timestamp);
              if (formattedTime && formattedTime !== "Time Error") {
                // Check for valid formatted time
                xLabel.textContent = formattedTime;
                dom.xAxisLabelsContainer.appendChild(xLabel);
                xAxisLabelsDrawnCount++;
                lastLabelX = x;
                // console.log(`[X-Axis Tick ${i}] Appended label "${formattedTime}" at X=${x.toFixed(1)}`); // Optional log on success
              } else {
                console.warn(
                  `[X-Axis Tick ${i}] formatTimestamp returned invalid: "${formattedTime}" for timestamp ${timestamp}`
                );
              }
            } catch (labelError) {
              console.error(
                `[X-Axis Tick ${i}] Error formatting or appending label for timestamp ${timestamp}:`,
                labelError
              );
              // Continue to the next iteration even if one label fails
            }
            // <<< End try...catch wrapper >>>
          }
        }
      }
    }
    // console.log(`[redrawChart] X-Axis drawing finished. Appended Label Count: ${xAxisLabelsDrawnCount}`); // Reduce noise
  } catch (e) {
    // Catch errors in the main X-axis loop setup (less likely now)
    console.error("[redrawChart] Error drawing X grid/axis:", e);
  }

  // --- Draw Candles ---
  let candlesDrawn = 0;
  let candlesSkippedInvalidCoords = 0;
  try {
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < visibleCount; i++) {
      const dataIndex = visibleStartIndex + i;
      if (dataIndex < 0 || dataIndex >= state.fullData.length) continue;
      const candle = state.fullData[dataIndex];
      if (
        !candle ||
        candle.length < 5 ||
        candle.slice(0, 5).some((v) => isNaN(v) || !Number.isFinite(v))
      ) {
        continue;
      }
      const [timestamp, low, high, open, close] = candle;
      const isUp = close >= open;
      const wickHighY = getYCoordinate(high, chartHeight);
      const wickLowY = getYCoordinate(low, chartHeight);
      const bodyOpenY = getYCoordinate(open, chartHeight);
      const bodyCloseY = getYCoordinate(close, chartHeight);
      if (
        wickHighY === null ||
        !Number.isFinite(wickHighY) ||
        wickLowY === null ||
        !Number.isFinite(wickLowY) ||
        bodyOpenY === null ||
        !Number.isFinite(bodyOpenY) ||
        bodyCloseY === null ||
        !Number.isFinite(bodyCloseY)
      ) {
        candlesSkippedInvalidCoords++;
        continue; // Skip this candle
      }
      const bodyTopY = Math.min(bodyOpenY, bodyCloseY);
      const bodyBottomY = Math.max(bodyOpenY, bodyCloseY);
      const wickHeight = Math.max(1, wickLowY - wickHighY);
      const bodyHeight = Math.max(1, bodyBottomY - bodyTopY);
      const candleElement = document.createElement("div");
      candleElement.className = "candle";
      candleElement.style.width = `${candleWidth.toFixed(1)}px`;
      const candleLeft = i * candleTotalWidth + candleMargin;
      candleElement.style.left = `${candleLeft.toFixed(1)}px`;
      let wickElement = null;
      if (wickHeight >= 1 && wickLowY >= wickHighY) {
        wickElement = document.createElement("div");
        wickElement.className = `wick ${isUp ? "color-up" : "color-down"}`;
        wickElement.style.top = `${wickHighY.toFixed(1)}px`;
        wickElement.style.height = `${wickHeight.toFixed(1)}px`;
      }
      let bodyElement = null;
      if (bodyHeight >= 1 && bodyBottomY >= bodyTopY) {
        bodyElement = document.createElement("div");
        bodyElement.className = `body ${isUp ? "color-up" : "color-down"}`;
        bodyElement.style.top = `${bodyTopY.toFixed(1)}px`;
        bodyElement.style.height = `${bodyHeight.toFixed(1)}px`;
      }
      if (wickElement) {
        candleElement.appendChild(wickElement);
      }
      if (bodyElement) {
        candleElement.appendChild(bodyElement);
      }
      if (candleElement.childNodes.length > 0) {
        fragment.appendChild(candleElement);
        candlesDrawn++;
      }
    }
    dom.chartArea.appendChild(fragment);
    // console.log(`[redrawChart] Candle drawing finished. Drawn: ${candlesDrawn}, Skipped: ${candlesSkippedInvalidCoords}`); // Reduce noise
  } catch (e) {
    console.error("[redrawChart] Error drawing candles:", e);
  }

  // --- Update Live Price Indicator ---
  let priceForIndicator = state.lastTickerPrice; /* ... existing logic ... */
  if (priceForIndicator !== null && Number.isFinite(priceForIndicator)) {
    updateLivePriceIndicatorUI(priceForIndicator, chartHeight);
  } else {
    if (dom.currentPriceLabel) dom.currentPriceLabel.style.display = "none";
    if (dom.currentPriceLine) dom.currentPriceLine.style.display = "none";
  }
  // console.log(`[redrawChart] Live price indicator updated/hidden.`); // Reduce noise

  // --- Draw Volume Chart ---
  try {
    drawVolumeChart(state, chartWidth);
  } catch (e) {
    console.error("[redrawChart] Error calling drawVolumeChart:", e);
    if (dom.volumeChartCanvas && dom.volumeChartCanvas.getContext) {
      const volCtx = dom.volumeChartCanvas.getContext("2d");
      if (volCtx) {
        volCtx.clearRect(
          0,
          0,
          dom.volumeChartCanvas.width,
          dom.volumeChartCanvas.height
        );
      }
    }
  }

  // console.log(`[redrawChart] Function finished completely.`); // Reduce noise
} // End of redrawChart function

```
--- END FILE: js/drawing.js ---


--- START FILE: js/interactions.js ---
```js
// js/interactions.js

import * as config from "./config.js"; // Import config
import state, { updateState } from "./state.js";
import * as dom from "./domElements.js";
import { redrawChart } from "./drawing.js";
import {
  calculateNiceStep,
  getYCoordinate,
  formatDate,
  formatTimestamp,
  getPriceFromYCoordinate,
  MIN_LOG_VALUE, // Import MIN_LOG_VALUE
} from "./utils.js"; // <<< ENSURE IMPORT IS HERE

// Tooltip State
let hoveredCandleIndex = null;
let tooltipShowTimeout = null;
let tooltipHideTimeout = null;

// Log Scale Helpers
const log = Math.log;
const exp = Math.exp;
// const MIN_LOG_VALUE = 1e-9; // Defined and imported from utils.js now
function safeLog(value) {
  return log(Math.max(MIN_LOG_VALUE, value));
}

// --- Tooltip Functions ---
// ... (showTooltip, hideTooltip - no changes needed) ...
function showTooltip(dataIndex, mouseX, mouseY) {
  if (!dom.chartTooltip || !dom.chartArea) return;

  if (dataIndex < 0 || dataIndex >= state.fullData.length) {
    hideTooltip();
    return;
  }

  const candleData = state.fullData[dataIndex];
  // Need timestamp[0], low[1], high[2], open[3], close[4] for tooltip
  if (
    !candleData ||
    candleData.length < 5 ||
    candleData.slice(0, 5).some((v) => isNaN(v) || !Number.isFinite(v))
  ) {
    hideTooltip();
    return;
  }

  const [timestamp, low, high, open, close] = candleData;
  const chartRect = dom.chartArea.getBoundingClientRect();
  const chartHeight = dom.chartArea.offsetHeight; // Use offsetHeight
  const chartContainerRect = dom.chartContainer.getBoundingClientRect(); // Use container for positioning relative to it

  // Formatting
  const dateStr = formatDate(timestamp);
  const timeStr = formatTimestamp(timestamp);
  const priceRange = state.maxVisiblePrice - state.minVisiblePrice;
  let decimals = 0;
  if (priceRange < 0.1) decimals = 4;
  else if (priceRange < 1) decimals = 3;
  else if (priceRange < 10 || close < 10) decimals = 2;
  else if (close < 1000) decimals = 1;
  else decimals = 0;
  decimals = Math.max(0, decimals); // Ensure non-negative

  // Update Tooltip Content
  dom.chartTooltip.innerHTML = `
    <div class="date">${dateStr}, ${timeStr}</div>
    <div><span class="label">O:</span> <span class="value">${open.toFixed(
      decimals
    )}</span></div>
    <div><span class="label">H:</span> <span class="value">${high.toFixed(
      decimals
    )}</span></div>
    <div><span class="label">L:</span> <span class="value">${low.toFixed(
      decimals
    )}</span></div>
    <div><span class="label">C:</span> <span class="value">${close.toFixed(
      decimals
    )}</span></div>
    `;
  // Optionally add Volume:
  // ${candleData.length > 5 && !isNaN(candleData[5]) && Number.isFinite(candleData[5]) ? `<div><span class="label">Vol:</span> <span class="value">${candleData[5].toLocaleString()}</span></div>` : ''}

  // Calculate Tooltip Position
  // Get tooltip dimensions *after* setting content
  const tooltipElementHeight = dom.chartTooltip.offsetHeight;
  const tooltipElementWidth = dom.chartTooltip.offsetWidth;

  // Default position: above and slightly to the right of the cursor
  let tooltipY = mouseY - tooltipElementHeight - 10; // 10px offset above
  let tooltipX = mouseX + 15; // 15px offset right

  // Adjust if too high (flip below cursor)
  if (tooltipY < 10) {
    // 10px margin from top of chart area
    tooltipY = mouseY + 20; // 20px offset below
  }

  // Adjust if too far right (flip left of cursor)
  // Calculate right boundary within the chart container (excluding Y axis label width)
  const yAxisWidth = dom.yAxisLabelsContainer?.offsetWidth || 55; // Estimate width if not available
  const rightBoundary = dom.chartContainer.offsetWidth - yAxisWidth - 10; // 10px margin
  if (tooltipX + tooltipElementWidth > rightBoundary) {
    tooltipX = mouseX - tooltipElementWidth - 15; // 15px offset left
  }

  // Adjust if too far left
  if (tooltipX < 10) {
    // 10px margin from left edge
    tooltipX = 10;
  }

  // Apply position relative to the chart container
  const containerRelativeX =
    tooltipX + chartRect.left - chartContainerRect.left;
  const containerRelativeY = tooltipY + chartRect.top - chartContainerRect.top;

  dom.chartTooltip.style.left = `${containerRelativeX.toFixed(0)}px`;
  dom.chartTooltip.style.top = `${containerRelativeY.toFixed(0)}px`;

  // Show Tooltip with fade-in effect
  dom.chartTooltip.style.display = "block"; // Make it take space for measurements if needed?
  dom.chartTooltip.style.visibility = "visible"; // Make it visible
  dom.chartTooltip.style.opacity = 1; // Start fade-in (or ensure it's fully visible)
  dom.chartTooltip.classList.add("visible"); // Add class if transition relies on it
}

function hideTooltip() {
  if (dom.chartTooltip) {
    dom.chartTooltip.style.opacity = 0;
    dom.chartTooltip.style.visibility = "hidden";
    dom.chartTooltip.classList.remove("visible");
  }
  hoveredCandleIndex = null; // Reset hovered index when hiding
}

// --- Crosshair Update Functions ---
// ... (updateCrosshair, hideCrosshair - no changes needed) ...
function updateCrosshair(mouseX, mouseY, chartHeight, chartWidth) {
  if (
    !dom.crosshairLineX ||
    !dom.crosshairLabelY ||
    mouseX === null ||
    mouseY === null ||
    chartHeight <= 0
  ) {
    hideCrosshair();
    return;
  }

  // Clamp mouse Y to chart boundaries for price calculation and line position
  const clampedMouseY = Math.max(0, Math.min(mouseY, chartHeight));

  const priceAtCursor = getPriceFromYCoordinate(clampedMouseY, chartHeight);

  if (priceAtCursor !== null && Number.isFinite(priceAtCursor)) {
    // Position horizontal line
    dom.crosshairLineX.style.top = `${clampedMouseY.toFixed(1)}px`;
    dom.crosshairLineX.style.display = "block";

    // Update and position price label
    const priceRange = state.maxVisiblePrice - state.minVisiblePrice;
    let decimals = 0;
    if (priceRange < 0.1) decimals = 4;
    else if (priceRange < 1) decimals = 3;
    else if (priceRange < 10 || priceAtCursor < 10) decimals = 2;
    else if (priceAtCursor < 1000) decimals = 1;
    else decimals = 0;
    decimals = Math.max(0, decimals); // Ensure non-negative

    dom.crosshairLabelY.textContent = priceAtCursor.toFixed(decimals);
    dom.crosshairLabelY.style.top = `${clampedMouseY.toFixed(1)}px`; // Align label with line
    dom.crosshairLabelY.style.display = "block";
  } else {
    // Hide if price calculation failed
    hideCrosshair();
  }
}

function hideCrosshair() {
  if (dom.crosshairLineX) dom.crosshairLineX.style.display = "none";
  if (dom.crosshairLabelY) dom.crosshairLabelY.style.display = "none";
}

// --- Interaction Handlers ---
// ... (handleMouseMoveForTooltip, handleMouseLeaveChartArea - no changes needed) ...
function handleMouseMoveForTooltip(event) {
  if (!dom.chartArea) return;

  const chartRect = dom.chartArea.getBoundingClientRect();
  const mouseX = event.clientX - chartRect.left;
  const mouseY = event.clientY - chartRect.top;
  const chartWidth = dom.chartArea.offsetWidth;
  const chartHeight = dom.chartArea.offsetHeight;

  // Hide crosshair and tooltip immediately if panning/dragging
  if (state.isPanning || state.isDraggingXAxis || state.isDraggingYAxis) {
    hideCrosshair();
    clearTimeout(tooltipShowTimeout);
    clearTimeout(tooltipHideTimeout);
    tooltipHideTimeout = null; // Reset hide timeout flag
    hideTooltip();
    return;
  }

  // Check if mouse is within chart bounds
  const isInsideChart =
    mouseX >= 0 && mouseX <= chartWidth && mouseY >= 0 && mouseY <= chartHeight;

  if (
    isInsideChart &&
    chartWidth > 0 &&
    chartHeight > 0 &&
    state.fullData.length > 0
  ) {
    // Update Crosshair
    updateCrosshair(mouseX, mouseY, chartHeight, chartWidth);

    // --- Tooltip Logic ---
    const visibleCount = state.visibleEndIndex - state.visibleStartIndex;
    if (visibleCount <= 0) {
      hideTooltip(); // Hide if no candles visible
      return;
    }

    const candleTotalWidth = chartWidth / visibleCount;
    // Calculate index based on mouse position
    const currentSlotIndex = Math.floor(mouseX / candleTotalWidth);
    const currentDataIndex = state.visibleStartIndex + currentSlotIndex;

    // Check if the calculated index is valid
    if (currentDataIndex >= 0 && currentDataIndex < state.fullData.length) {
      if (currentDataIndex !== hoveredCandleIndex) {
        // Mouse moved to a new candle index
        clearTimeout(tooltipShowTimeout); // Cancel any pending show
        clearTimeout(tooltipHideTimeout); // Cancel any pending hide
        tooltipHideTimeout = null;
        hideTooltip(); // Hide previous tooltip immediately

        hoveredCandleIndex = currentDataIndex; // Update hovered index

        // Set timeout to show the new tooltip after a delay
        tooltipShowTimeout = setTimeout(() => {
          showTooltip(hoveredCandleIndex, mouseX, mouseY);
          tooltipShowTimeout = null; // Clear the timeout ID once shown
        }, config.TOOLTIP_SHOW_DELAY);
      } else {
        // Mouse is still over the same candle index
        clearTimeout(tooltipHideTimeout); // Cancel hide timeout if mouse re-enters quickly
        tooltipHideTimeout = null;
        // Optional: Update tooltip position while hovering over the same candle?
        // showTooltip(hoveredCandleIndex, mouseX, mouseY); // This would make it follow cursor exactly
      }
    } else {
      // Mouse is inside chart but not over a valid candle index (e.g., padding areas)
      clearTimeout(tooltipShowTimeout); // Cancel pending show
      tooltipShowTimeout = null;
      hoveredCandleIndex = null; // No candle is hovered

      // Start hide timeout if tooltip is currently visible
      if (dom.chartTooltip && dom.chartTooltip.style.visibility === "visible") {
        if (!tooltipHideTimeout) {
          // Only start hide timer if not already running
          tooltipHideTimeout = setTimeout(() => {
            hideTooltip();
            tooltipHideTimeout = null;
          }, config.TOOLTIP_HIDE_DELAY);
        }
      } else {
        hideTooltip(); // Hide immediately if not visible
      }
    }
  } else {
    // Mouse is outside chart bounds
    hideCrosshair();
    clearTimeout(tooltipShowTimeout); // Cancel pending show
    tooltipShowTimeout = null;
    clearTimeout(tooltipHideTimeout); // Cancel pending hide
    tooltipHideTimeout = null;
    hoveredCandleIndex = null; // No candle hovered
    hideTooltip(); // Hide immediately
  }
}

function handleMouseLeaveChartArea(event) {
  // Handles BOTH crosshair and tooltip when mouse leaves the specific chartArea element
  hideCrosshair();
  clearTimeout(tooltipShowTimeout);
  tooltipShowTimeout = null;
  clearTimeout(tooltipHideTimeout);
  tooltipHideTimeout = null;
  hoveredCandleIndex = null;
  hideTooltip();
}

// --- Chart Interaction Handlers (Zoom, Pan, Scale, Resize, DoubleClick) ---
// ... (handleZoom, handleMouseMove, handleMouseDownChart, etc. - no changes needed) ...
export function handleZoom(event) {
  event.preventDefault();
  if (!dom.chartArea) return;

  const chartRect = dom.chartArea.getBoundingClientRect();
  const mouseX = event.clientX - chartRect.left;
  const mouseY = event.clientY - chartRect.top;
  const chartHeight = dom.chartArea.offsetHeight;
  const chartWidth = dom.chartArea.offsetWidth;

  if (!chartHeight || !chartWidth || !state.fullData.length) return;

  const zoomDirection = event.deltaY < 0 ? -1 : 1; // -1 for zoom in, 1 for zoom out
  let newState = {};

  // --- Y-Axis Zoom ---
  const currentMinY = state.minVisiblePrice;
  const currentMaxY = state.maxVisiblePrice;

  if (state.isLogScale) {
    const logMin = safeLog(currentMinY);
    const logMax = safeLog(currentMaxY);
    const logRange = logMax - logMin;

    // Check if range is valid for zooming
    if (logRange > 0 && Number.isFinite(logRange)) {
      const logAtCursor = logMax - (mouseY / chartHeight) * logRange; // Price (in log space) at cursor Y
      const zoomAmountY = 1 + zoomDirection * config.ZOOM_FACTOR_Y;

      // Calculate new log min/max based on zooming around the cursor position
      let newLogMin = logAtCursor - (logAtCursor - logMin) * zoomAmountY;
      let newLogMax = logAtCursor + (logMax - logAtCursor) * zoomAmountY;

      // Convert back to linear scale and ensure min is positive
      newState.minVisiblePrice = Math.max(MIN_LOG_VALUE, exp(newLogMin));
      newState.maxVisiblePrice = exp(newLogMax);

      // Prevent excessive zoom-in (minimum ratio)
      if (newState.maxVisiblePrice / newState.minVisiblePrice < 1.001) {
        const midPriceLog = (newLogMin + newLogMax) / 2;
        const halfRangeLog = Math.log(1.0005); // ~0.05% ratio
        newState.minVisiblePrice = Math.max(
          MIN_LOG_VALUE,
          exp(midPriceLog - halfRangeLog)
        );
        newState.maxVisiblePrice = exp(midPriceLog + halfRangeLog);
      }
    }
  } else {
    // Linear Scale Zoom
    const linearRange = currentMaxY - currentMinY;

    if (linearRange > 0 && Number.isFinite(linearRange)) {
      const priceAtCursor = currentMaxY - (mouseY / chartHeight) * linearRange;
      const zoomAmountY = 1 + zoomDirection * config.ZOOM_FACTOR_Y;

      let newMin = priceAtCursor - (priceAtCursor - currentMinY) * zoomAmountY;
      let newMax = priceAtCursor + (currentMaxY - priceAtCursor) * zoomAmountY;

      // Ensure minimum price span and non-negative min
      if (newMax - newMin < config.MIN_PRICE_RANGE_SPAN) {
        const mid = (newMax + newMin) / 2;
        newMin = mid - config.MIN_PRICE_RANGE_SPAN / 2;
        newMax = mid + config.MIN_PRICE_RANGE_SPAN / 2;
      }
      newState.minVisiblePrice = Math.max(0, newMin); // Clamp min at 0
      newState.maxVisiblePrice = newMax;
    }
  }

  // --- X-Axis Zoom ---
  const currentVisibleCount = state.visibleEndIndex - state.visibleStartIndex;
  if (currentVisibleCount > 0) {
    // Calculate the data index under the cursor
    const indexAtCursorFloat =
      state.visibleStartIndex + (mouseX / chartWidth) * currentVisibleCount;
    const zoomAmountX = 1 + zoomDirection * config.ZOOM_FACTOR_X;

    // Calculate new number of visible candles
    let newVisibleCount = Math.round(currentVisibleCount * zoomAmountX);
    newVisibleCount = Math.max(
      config.MIN_VISIBLE_CANDLES,
      // Limit zoom out to maybe 5x the total data length? Prevents excessive range.
      Math.min(newVisibleCount, state.fullData.length * 5)
    );
    // Clamp further to not exceed total data length when zooming in fully
    newVisibleCount = Math.min(newVisibleCount, state.fullData.length);

    // Calculate new start index to keep the index under the cursor stationary
    let newStartIndex = Math.round(
      indexAtCursorFloat - (mouseX / chartWidth) * newVisibleCount
    );

    // Clamp start/end indices to valid range [0, fullData.length]
    newStartIndex = Math.max(0, newStartIndex);
    let newEndIndex = newStartIndex + newVisibleCount;

    // Adjust if end index exceeds data bounds
    if (newEndIndex > state.fullData.length) {
      newEndIndex = state.fullData.length;
      newStartIndex = Math.max(0, newEndIndex - newVisibleCount); // Recalculate start index based on clamped end
    }
    // Final clamp on start index (shouldn't be needed if logic above is correct, but safe)
    newStartIndex = Math.max(0, newStartIndex);

    newState.visibleStartIndex = newStartIndex;
    newState.visibleEndIndex = newEndIndex;
  }

  // Apply the combined state changes
  if (Object.keys(newState).length > 0) {
    updateState(newState);
    requestAnimationFrame(redrawChart);
  }
}

export function handleMouseMove(event) {
  if (!state.isPanning && !state.isDraggingYAxis && !state.isDraggingXAxis) {
    // If not dragging/panning, delegate to tooltip/crosshair handler
    // handleMouseMoveForTooltip(event); // This causes issues if mouse moves outside chartArea
    return;
  }

  // Throttle redraw calls during drag/pan
  const now = Date.now();
  if (now - state.lastDrawTime < config.MOUSE_MOVE_THROTTLE) return;

  let needsRedraw = false;
  let newState = {};
  const chartHeight = dom.chartArea?.offsetHeight;
  const chartWidth = dom.chartArea?.offsetWidth;

  // --- Y-Axis Scaling (Dragging Y Axis) ---
  if (state.isDraggingYAxis) {
    const deltaY = event.clientY - state.panStartY;
    if (!chartHeight || chartHeight <= 0) return;

    if (state.isLogScale) {
      const logMinStart = safeLog(state.panStartMinPrice);
      const logMaxStart = safeLog(state.panStartMaxPrice);
      const logRangeStart = logMaxStart - logMinStart;

      if (logRangeStart > 0 && Number.isFinite(logRangeStart)) {
        const midLogPrice = (logMaxStart + logMinStart) / 2;
        // Exponential scaling based on drag distance
        const scaleFactor = Math.pow(
          2,
          (deltaY / chartHeight) * config.Y_AXIS_DRAG_SENSITIVITY
        );
        let newLogRange = logRangeStart * scaleFactor;

        // Prevent excessive zoom-in (minimum ratio ~0.1%)
        if (exp(newLogRange) < 1.001) {
          newLogRange = log(1.001);
        }

        const newLogMin = midLogPrice - newLogRange / 2;
        const newLogMax = midLogPrice + newLogRange / 2;

        const newMin = Math.max(MIN_LOG_VALUE, exp(newLogMin));
        const newMax = exp(newLogMax);

        // Check if changes are significant enough to redraw
        if (
          Math.abs(newMin - state.minVisiblePrice) > 1e-9 ||
          Math.abs(newMax - state.maxVisiblePrice) > 1e-9
        ) {
          newState.minVisiblePrice = newMin;
          newState.maxVisiblePrice = newMax;
          needsRedraw = true;
        }
      }
    } else {
      // Linear Scale Y-Axis Drag
      const initialRange = state.panStartMaxPrice - state.panStartMinPrice;
      if (initialRange > 0 && Number.isFinite(initialRange)) {
        const midPrice = (state.panStartMaxPrice + state.panStartMinPrice) / 2;
        const scaleFactor = Math.pow(
          2,
          (deltaY / chartHeight) * config.Y_AXIS_DRAG_SENSITIVITY
        );
        let newRange = initialRange * scaleFactor;
        newRange = Math.max(config.MIN_PRICE_RANGE_SPAN, newRange); // Enforce min span

        const newMin = midPrice - newRange / 2;
        const newMax = midPrice + newRange / 2;

        // Check if changes are significant
        if (
          Math.abs(newMin - state.minVisiblePrice) > 1e-9 ||
          Math.abs(newMax - state.maxVisiblePrice) > 1e-9
        ) {
          newState.minVisiblePrice = Math.max(0, newMin); // Clamp min at 0
          newState.maxVisiblePrice = newMax;
          needsRedraw = true;
        }
      }
    }
  }
  // --- X-Axis Scaling (Dragging X Axis) ---
  else if (state.isDraggingXAxis) {
    const deltaX = event.clientX - state.panStartX;
    if (!chartWidth || chartWidth <= 0 || state.panStartVisibleCount <= 0)
      return;

    const centerIndex =
      state.panStartVisibleIndex + state.panStartVisibleCount / 2;
    const scaleFactor = Math.pow(
      2,
      (deltaX / chartWidth) * config.X_AXIS_DRAG_SENSITIVITY
    );

    let newVisibleCount = Math.round(state.panStartVisibleCount * scaleFactor);
    // Clamp new count: min candles, max data length * factor, max total data length
    newVisibleCount = Math.max(config.MIN_VISIBLE_CANDLES, newVisibleCount);
    newVisibleCount = Math.min(newVisibleCount, state.fullData.length * 5); // Limit zoom out
    newVisibleCount = Math.min(newVisibleCount, state.fullData.length); // Cannot show more than exist

    let newStartIndex = Math.round(centerIndex - newVisibleCount / 2);

    // Clamp start/end indices
    newStartIndex = Math.max(0, newStartIndex);
    let newEndIndex = newStartIndex + newVisibleCount;
    if (newEndIndex > state.fullData.length) {
      newEndIndex = state.fullData.length;
      newStartIndex = Math.max(0, newEndIndex - newVisibleCount);
    }
    newStartIndex = Math.max(0, newStartIndex); // Final start clamp

    // Check if indices changed
    if (
      newStartIndex !== state.visibleStartIndex ||
      newEndIndex !== state.visibleEndIndex
    ) {
      newState.visibleStartIndex = newStartIndex;
      newState.visibleEndIndex = newEndIndex;
      needsRedraw = true;
    }
  }
  // --- Chart Panning ---
  else if (state.isPanning) {
    const deltaX = event.clientX - state.panStartX;
    const deltaY = event.clientY - state.panStartY;
    if (!chartWidth || !chartHeight || chartWidth <= 0 || chartHeight <= 0)
      return;

    let changedX = false;
    let changedY = false;

    // Pan X (Time)
    if (state.panStartVisibleCount > 0) {
      const indexDelta = (deltaX / chartWidth) * state.panStartVisibleCount;
      let newStartIndex = state.panStartVisibleIndex - Math.round(indexDelta);

      // Clamp panning within data bounds [0, N - visibleCount]
      const maxStartIndex = state.fullData.length - state.panStartVisibleCount;
      newStartIndex = Math.max(0, Math.min(newStartIndex, maxStartIndex));

      if (newStartIndex !== state.visibleStartIndex) {
        newState.visibleStartIndex = newStartIndex;
        newState.visibleEndIndex = newStartIndex + state.panStartVisibleCount;
        changedX = true;
      }
    }

    // Pan Y (Price)
    if (state.isLogScale) {
      const logMinStart = safeLog(state.panStartMinPrice);
      const logMaxStart = safeLog(state.panStartMaxPrice);
      const logRangeStart = logMaxStart - logMinStart;

      if (logRangeStart > 0 && Number.isFinite(logRangeStart)) {
        const logDelta = (deltaY / chartHeight) * logRangeStart;
        const newLogMin = logMinStart + logDelta;
        const newLogMax = logMaxStart + logDelta;

        const newMin = Math.max(MIN_LOG_VALUE, exp(newLogMin));
        const newMax = exp(newLogMax);

        // Check for significant change
        if (
          Math.abs(newMin - state.minVisiblePrice) > 1e-9 ||
          Math.abs(newMax - state.maxVisiblePrice) > 1e-9
        ) {
          newState.minVisiblePrice = newMin;
          newState.maxVisiblePrice = newMax;
          changedY = true;
        }
      }
    } else {
      // Linear Scale Pan Y
      const initialPriceRange = state.panStartMaxPrice - state.panStartMinPrice;
      if (initialPriceRange > 0 && Number.isFinite(initialPriceRange)) {
        const priceDelta = (deltaY / chartHeight) * initialPriceRange;
        const newMinPrice = state.panStartMinPrice + priceDelta;
        const newMaxPrice = state.panStartMaxPrice + priceDelta;

        // Check for significant change
        if (
          Math.abs(newMinPrice - state.minVisiblePrice) > 1e-9 ||
          Math.abs(newMaxPrice - state.maxVisiblePrice) > 1e-9
        ) {
          newState.minVisiblePrice = Math.max(0, newMinPrice); // Clamp min at 0
          newState.maxVisiblePrice = newMaxPrice;
          changedY = true;
        }
      }
    }
    needsRedraw = changedX || changedY;
  }

  // If changes occurred, update state and request redraw
  if (needsRedraw) {
    updateState({ ...newState, lastDrawTime: now });
    requestAnimationFrame(redrawChart);
  }
}

export function handleMouseDownChart(event) {
  // Only initiate panning if the click is directly on the chart area/wrapper
  // or potentially on grid lines, but NOT on axis labels or other controls within container
  const target = event.target;
  if (!dom.chartArea || !dom.chartWrapper || !dom.gridContainer) return;

  if (
    target === dom.chartArea ||
    target === dom.chartWrapper ||
    target === dom.gridContainer ||
    target.classList.contains("grid-line") ||
    target.classList.contains("candle")
  ) {
    updateState({
      isPanning: true,
      isDraggingYAxis: false,
      isDraggingXAxis: false,
      panStartX: event.clientX,
      panStartY: event.clientY,
      panStartVisibleIndex: state.visibleStartIndex,
      panStartMinPrice: state.minVisiblePrice,
      panStartMaxPrice: state.maxVisiblePrice,
      panStartVisibleCount: state.visibleEndIndex - state.visibleStartIndex,
    });
    if (dom.chartContainer) dom.chartContainer.classList.add("panning");
  } else {
    // If click wasn't on a pannable element, ensure panning state is false
    if (state.isPanning) {
      updateState({ isPanning: false });
      if (dom.chartContainer) dom.chartContainer.classList.remove("panning");
    }
  }
}

export function handleMouseDownYAxis(event) {
  event.stopPropagation(); // Prevent chart panning
  updateState({
    isDraggingYAxis: true,
    isPanning: false,
    isDraggingXAxis: false,
    panStartY: event.clientY,
    panStartMinPrice: state.minVisiblePrice,
    panStartMaxPrice: state.maxVisiblePrice,
    // No need for X axis pan start info here
  });
}

export function handleMouseDownXAxis(event) {
  event.stopPropagation(); // Prevent chart panning
  updateState({
    isDraggingXAxis: true,
    isPanning: false,
    isDraggingYAxis: false,
    panStartX: event.clientX,
    panStartVisibleIndex: state.visibleStartIndex,
    panStartVisibleCount: state.visibleEndIndex - state.visibleStartIndex,
    // No need for Y axis pan start info here
  });
}

export function handleMouseUpOrLeave(event) {
  // This handles mouseup anywhere on the window or leaving the window
  if (state.isPanning || state.isDraggingYAxis || state.isDraggingXAxis) {
    updateState({
      isPanning: false,
      isDraggingYAxis: false,
      isDraggingXAxis: false,
    });
    if (dom.chartContainer) dom.chartContainer.classList.remove("panning");
  }
  // Note: handleMouseLeaveChartArea handles leaving the specific chart drawing area
  // for hiding tooltips/crosshairs. This handler is for drag/pan state globally.
}

let resizeTimeout;
export function handleResize() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    // Redrawing handles canvas resizing internally now
    requestAnimationFrame(redrawChart);
  }, config.DEBOUNCE_DELAY);
}

// --- Double Click Handler with Dynamic Y-Axis Scaling ---
export function handleDoubleClick(event) {
  if (!state.fullData.length || !dom.chartArea) return;
  const chartHeight = dom.chartArea.offsetHeight;
  if (!chartHeight || chartHeight <= 0) return; // Need height for scaling

  // --- Reset X-Axis (Time) ---
  const totalDataCount = state.fullData.length;
  let newVisibleCount = Math.min(
    config.DEFAULT_RESET_CANDLE_COUNT,
    totalDataCount
  );
  let newEndIndex = totalDataCount; // Show up to the latest candle
  let newStartIndex = Math.max(0, newEndIndex - newVisibleCount);
  newVisibleCount = newEndIndex - newStartIndex; // Recalculate actual count

  // --- Find Actual Data Range (Y-Axis) in the New Time Window ---
  let newMinY = Infinity,
    newMaxY = -Infinity;
  for (let i = newStartIndex; i < newEndIndex; i++) {
    if (!state.fullData[i] || state.fullData[i].length < 5) continue;
    const low = state.fullData[i][1];
    const high = state.fullData[i][2];
    if (!isNaN(low) && Number.isFinite(low)) {
      newMinY = Math.min(newMinY, low);
    }
    if (!isNaN(high) && Number.isFinite(high)) {
      newMaxY = Math.max(newMaxY, high);
    }
  }

  // Handle cases where range couldn't be determined or is invalid
  let dataRangeY;
  const minValidRange = 1e-9; // A very small number to represent effectively zero range

  if (
    newMinY === Infinity ||
    newMaxY === -Infinity ||
    newMaxY - newMinY < minValidRange
  ) {
    console.warn(
      "Could not determine valid price range for reset view or range too small, using fallback."
    );
    // Center around last price or a default value
    const lastCandle = state.fullData[state.fullData.length - 1];
    const centerPrice =
      lastCandle && lastCandle.length >= 5 && Number.isFinite(lastCandle[4])
        ? lastCandle[4]
        : (state.minVisiblePrice + state.maxVisiblePrice) / 2 || 100;

    // Use a small default span based on scale type
    if (state.isLogScale) {
      newMinY = Math.max(MIN_LOG_VALUE, centerPrice / 1.01); // +/- 1%
      newMaxY = centerPrice * 1.01;
    } else {
      const halfSpan = config.MIN_PRICE_RANGE_SPAN / 2 || 0.05;
      newMinY = Math.max(0, centerPrice - halfSpan);
      newMaxY = centerPrice + halfSpan;
    }
    dataRangeY = newMaxY - newMinY; // Recalculate data range for fallback
    if (dataRangeY < minValidRange) dataRangeY = minValidRange; // Ensure positive range
  } else {
    dataRangeY = newMaxY - newMinY;
  }

  // Ensure minimums are positive for log scale calculations
  newMinY = Math.max(MIN_LOG_VALUE, newMinY);
  newMaxY = Math.max(newMinY + minValidRange, newMaxY); // Ensure max > min

  // --- Calculate Required Total Y-Range for Target Fill ---
  let newMinPrice, newMaxPrice;
  const targetFill = config.Y_AXIS_RESET_FILL_FACTOR; // e.g., 0.85
  const inverseFill = 1.0 / targetFill;

  if (state.isLogScale) {
    // Log Scale Calculation
    const safeMinY = Math.max(MIN_LOG_VALUE, newMinY);
    const safeMaxY = Math.max(safeMinY * 1.0001, newMaxY); // Ensure Max > Min slightly

    const logDataRangeY = safeLog(safeMaxY) - safeLog(safeMinY);

    if (!Number.isFinite(logDataRangeY) || logDataRangeY <= 0) {
      // Fallback if log range calculation fails
      console.warn(
        "Log range calculation failed in reset, using simple padding."
      );
      const logPadding = 1 + config.Y_AXIS_LOG_PADDING_FACTOR;
      newMinPrice = Math.max(MIN_LOG_VALUE, safeMinY / logPadding);
      newMaxPrice = safeMaxY * logPadding;
    } else {
      const logTotalRange = logDataRangeY * inverseFill;
      const logPaddingTotal = logTotalRange - logDataRangeY;
      const logPaddingAmount = logPaddingTotal / 2.0;

      const newLogMin = safeLog(safeMinY) - logPaddingAmount;
      const newLogMax = safeLog(safeMaxY) + logPaddingAmount;

      newMinPrice = Math.max(MIN_LOG_VALUE, exp(newLogMin));
      newMaxPrice = exp(newLogMax);

      // Ensure minimum range ratio after calculation
      if (newMaxPrice / newMinPrice < 1.01) {
        const midLog = (newLogMax + newLogMin) / 2;
        const halfRangeLog = Math.log(1.005);
        newMinPrice = Math.max(MIN_LOG_VALUE, exp(midLog - halfRangeLog));
        newMaxPrice = exp(midLog + halfRangeLog);
      }
    }
  } else {
    // Linear Scale Calculation
    if (dataRangeY <= 0) {
      // Should be handled by fallback above, but double check
      console.warn("Linear range is zero in reset, using simple padding.");
      const halfSpan = config.MIN_PRICE_RANGE_SPAN / 2 || 0.05;
      newMinPrice = Math.max(0, newMinY - halfSpan);
      newMaxPrice = newMaxY + halfSpan;
    } else {
      const totalRange = dataRangeY * inverseFill;
      const paddingTotal = totalRange - dataRangeY;
      const paddingAmount = paddingTotal / 2.0;

      newMinPrice = Math.max(0, newMinY - paddingAmount); // Clamp at 0
      newMaxPrice = newMaxY + paddingAmount;

      // Ensure minimum linear range span
      if (newMaxPrice - newMinPrice < config.MIN_PRICE_RANGE_SPAN) {
        const mid = (newMaxPrice + newMinPrice) / 2;
        newMinPrice = Math.max(0, mid - config.MIN_PRICE_RANGE_SPAN / 2);
        newMaxPrice = mid + config.MIN_PRICE_RANGE_SPAN / 2;
      }
    }
  }

  // Update state with new X and Y ranges
  updateState({
    visibleStartIndex: newStartIndex,
    visibleEndIndex: newEndIndex,
    minVisiblePrice: newMinPrice,
    maxVisiblePrice: newMaxPrice,
    // DO NOT reset isLogScale or is12HourFormat here
  });

  // Request redraw with the new state
  requestAnimationFrame(redrawChart);
}
// --- End of Double Click Handler ---

export function handleLogScaleToggle() {
  const isChecked = dom.logScaleToggle.checked;
  updateState({ isLogScale: isChecked });
  localStorage.setItem("logScalePref", isChecked.toString());
  // Recalculate Y range based on the center price of the *current* view
  // to make the transition smoother.
  const centerY = dom.chartArea.offsetHeight / 2;
  const centerPrice = getPriceFromYCoordinate(
    centerY,
    dom.chartArea.offsetHeight
  );

  if (centerPrice !== null && Number.isFinite(centerPrice)) {
    const currentMin = state.minVisiblePrice;
    const currentMax = state.maxVisiblePrice;
    let newMin, newMax;

    if (isChecked) {
      // Switching TO Log
      const linearRange = currentMax - currentMin;
      const logCenter = safeLog(centerPrice);
      // Estimate equivalent log range (this is approximate)
      const logRangeEstimate = safeLog(currentMax) - safeLog(currentMin); // Use current log range

      if (Number.isFinite(logRangeEstimate) && logRangeEstimate > 0) {
        const halfLogRange = logRangeEstimate / 2;
        newMin = Math.max(MIN_LOG_VALUE, exp(logCenter - halfLogRange));
        newMax = exp(logCenter + halfLogRange);
      } else {
        // Fallback if range fails
        newMin = Math.max(MIN_LOG_VALUE, centerPrice / 1.1);
        newMax = centerPrice * 1.1;
      }
      // Ensure min log ratio
      if (newMax / newMin < 1.01) {
        const midLog = (safeLog(newMax) + safeLog(newMin)) / 2;
        newMin = Math.max(MIN_LOG_VALUE, exp(midLog - Math.log(1.005)));
        newMax = exp(midLog + Math.log(1.005));
      }
    } else {
      // Switching TO Linear
      const logRange = safeLog(currentMax) - safeLog(currentMin);
      // Estimate equivalent linear range based on center price (approximate)
      const linearRatio = currentMax / currentMin; // Ratio
      const linearRangeEstimate = centerPrice * (linearRatio - 1); // Very rough estimate
      let halfLinearRange = linearRangeEstimate / 2;

      // Use a more stable fallback if estimate is bad
      if (
        !Number.isFinite(halfLinearRange) ||
        halfLinearRange <= config.MIN_PRICE_RANGE_SPAN / 2
      ) {
        halfLinearRange =
          (currentMax - currentMin) / 2 || config.MIN_PRICE_RANGE_SPAN; // Use current linear diff or default
      }
      halfLinearRange = Math.max(
        config.MIN_PRICE_RANGE_SPAN / 2,
        halfLinearRange
      );

      newMin = Math.max(0, centerPrice - halfLinearRange);
      newMax = centerPrice + halfLinearRange;
      // Ensure min linear span
      if (newMax - newMin < config.MIN_PRICE_RANGE_SPAN) {
        const mid = (newMax + newMin) / 2;
        newMin = Math.max(0, mid - config.MIN_PRICE_RANGE_SPAN / 2);
        newMax = mid + config.MIN_PRICE_RANGE_SPAN / 2;
      }
    }

    updateState({ minVisiblePrice: newMin, maxVisiblePrice: newMax });
  } else {
    console.warn("Could not get center price for scale toggle adjustment.");
  }

  requestAnimationFrame(redrawChart);
}

export function handleTimeFormatToggle() {
  const isChecked = dom.timeFormatToggle.checked;
  updateState({ is12HourFormat: isChecked });
  localStorage.setItem("timeFormatPref", isChecked.toString());
  requestAnimationFrame(redrawChart); // Redraw to update X-axis labels
}

// --- Attach Listeners ---
export function attachInteractionListeners() {
  if (
    !dom.chartContainer ||
    !dom.yAxisLabelsContainer ||
    !dom.xAxisLabelsContainer ||
    !dom.chartArea
  ) {
    console.error(
      "Cannot attach interaction listeners: Essential chart DOM elements missing."
    );
    return;
  }

  // Chart container handles wheel (zoom), main panning mousedown, and double click reset
  dom.chartContainer.addEventListener("wheel", handleZoom, { passive: false });
  dom.chartContainer.addEventListener("mousedown", handleMouseDownChart);
  dom.chartContainer.addEventListener("dblclick", handleDoubleClick);

  // Axis labels handle scaling mousedown
  dom.yAxisLabelsContainer.addEventListener("mousedown", handleMouseDownYAxis);
  dom.xAxisLabelsContainer.addEventListener("mousedown", handleMouseDownXAxis);

  // Window handles mouse move (for drag/pan/scale) and mouseup (to end actions)
  window.addEventListener("mousemove", handleMouseMove);
  window.addEventListener("mouseup", handleMouseUpOrLeave);
  window.addEventListener("mouseleave", handleMouseUpOrLeave); // Handle mouse leaving window during drag

  // Window handles resize
  window.addEventListener("resize", handleResize);

  // Chart area handles mouse move and leave specifically for tooltips/crosshairs
  dom.chartArea.addEventListener("mousemove", handleMouseMoveForTooltip);
  dom.chartArea.addEventListener("mouseleave", handleMouseLeaveChartArea);

  // Settings toggles
  if (dom.logScaleToggle) {
    dom.logScaleToggle.addEventListener("change", handleLogScaleToggle);
  } else {
    console.warn("Log scale toggle checkbox not found.");
  }

  if (dom.timeFormatToggle) {
    dom.timeFormatToggle.addEventListener("change", handleTimeFormatToggle);
  } else {
    console.warn("Time format toggle checkbox not found.");
  }

  console.log("Chart interaction listeners attached.");
}

```
--- END FILE: js/interactions.js ---


--- START FILE: js/layout.js ---
```js
// js/layout.js
import * as dom from "./domElements.js";
import { redrawChart } from "./drawing.js"; // To redraw chart after pane resize

let isResizing = false;
let startY, startChartHeight, startBottomHeight;

// Constants from CSS (or define here)
const MIN_PANE_HEIGHT_PX = 100;
const RESIZER_HEIGHT_PX = 6;
const INITIAL_CHART_FLEX_BASIS = "67%"; // Keep initial percentages
const INITIAL_BOTTOM_FLEX_BASIS = "33%"; // Keep initial percentages

/**
 * Resets the pane heights to their initial percentage basis.
 */
function resetPaneHeights() {
  if (dom.chartPane && dom.bottomPane) {
    console.log("Resetting pane heights to initial percentages.");
    dom.chartPane.style.flexBasis = INITIAL_CHART_FLEX_BASIS;
    dom.bottomPane.style.flexBasis = INITIAL_BOTTOM_FLEX_BASIS;

    // We need to redraw the chart after the layout adjusts
    // Use a short timeout to allow the browser to recalculate layout first
    setTimeout(() => {
      requestAnimationFrame(redrawChart);
    }, 0);
  } else {
    console.error("Cannot reset pane heights: Pane elements not found.");
  }
}

function handleMouseDownResize(event) {
  event.preventDefault();
  isResizing = true;
  startY = event.clientY;

  // Get initial heights in pixels at the start of the drag
  startChartHeight = dom.chartPane.offsetHeight;
  startBottomHeight = dom.bottomPane.offsetHeight;

  document.body.classList.add("resizing");

  window.addEventListener("mousemove", handleMouseMoveResize);
  window.addEventListener("mouseup", handleMouseUpResize);
}

function handleMouseMoveResize(event) {
  if (!isResizing) return;

  const deltaY = event.clientY - startY;

  let newChartHeight = startChartHeight + deltaY;
  let newBottomHeight = startBottomHeight - deltaY;

  const totalPaneHeight = startChartHeight + startBottomHeight;

  // Enforce minimum heights
  if (newChartHeight < MIN_PANE_HEIGHT_PX) {
    newChartHeight = MIN_PANE_HEIGHT_PX;
    newBottomHeight = totalPaneHeight - newChartHeight;
  }
  if (newBottomHeight < MIN_PANE_HEIGHT_PX) {
    newBottomHeight = MIN_PANE_HEIGHT_PX;
    newChartHeight = totalPaneHeight - newBottomHeight;
  }
  if (newChartHeight < MIN_PANE_HEIGHT_PX) newChartHeight = MIN_PANE_HEIGHT_PX;

  // Apply new heights using flex-basis (pixels provide stability during drag)
  dom.chartPane.style.flexBasis = `${newChartHeight}px`;
  dom.bottomPane.style.flexBasis = `${newBottomHeight}px`;

  requestAnimationFrame(redrawChart);
}

function handleMouseUpResize() {
  if (isResizing) {
    isResizing = false;
    document.body.classList.remove("resizing");

    window.removeEventListener("mousemove", handleMouseMoveResize);
    window.removeEventListener("mouseup", handleMouseUpResize);
  }
}

/**
 * Handles the double-click event on the resizer.
 */
function handleDoubleClickResize(event) {
  event.preventDefault(); // Prevent any default dblclick behavior
  resetPaneHeights();
}

export function initializeResizer() {
  // Use the dom reference directly
  const resizer = dom.resizer;

  if (resizer && dom.chartPane && dom.bottomPane && dom.contentArea) {
    // Set initial heights using percentages
    dom.chartPane.style.flexBasis = INITIAL_CHART_FLEX_BASIS;
    dom.bottomPane.style.flexBasis = INITIAL_BOTTOM_FLEX_BASIS;
    console.log(
      `Initial flex-basis set to approx ${INITIAL_CHART_FLEX_BASIS}/${INITIAL_BOTTOM_FLEX_BASIS}`
    );

    // Attach mousedown listener for dragging
    resizer.addEventListener("mousedown", handleMouseDownResize);

    // Attach dblclick listener for resetting *** NEW ***
    resizer.addEventListener("dblclick", handleDoubleClickResize);

    console.log("Resizer initialized with drag and double-click reset.");

    // Removed the optional pixel update timeout as resetting to percentage works well
  } else {
    console.error(
      "Resizer initialization failed: Resizer, chartPane, or bottomPane not found in DOM."
    );
    if (!resizer) console.error("- Resizer missing");
    if (!dom.chartPane) console.error("- Chart Pane missing");
    if (!dom.bottomPane) console.error("- Bottom Pane missing");
    if (!dom.contentArea) console.error("- Content Area missing");
  }
}

```
--- END FILE: js/layout.js ---


--- START FILE: js/liveUpdate.js ---
```js
// js/liveUpdate.js

import state, { updateState, updateLatestPrice } from "./state.js"; // Import state functions
import { redrawChart } from "./drawing.js";
import { updateBalanceValuesUI } from "./balance.js"; // Import the new balance update function
import * as config from "./config.js";
import { getYCoordinate } from "./utils.js"; // Import shared utility
import * as dom from "./domElements.js"; // Import DOM elements

let ws = null;
let chartRedrawTimeout = null;
let balanceUpdateTimeout = null; // <<<--- ADDED: Timeout ID for balance updates
const CHART_REDRAW_THROTTLE_MS = 250;
const BALANCE_UPDATE_THROTTLE_MS = 1500; // <<<--- ADDED: Throttle delay for balances (e.g., 1.5 seconds)

const WEBSOCKET_URL = "wss://ws-feed.exchange.coinbase.com";
let currentProductId = config.DEFAULT_PRODUCT_ID; // Track main chart product ID

/**
 * Updates the UI for the live price indicator.
 * @param {number} price - The current price.
 */
function updateLivePriceIndicatorUI(price) {
  if (!dom.currentPriceLabel || !dom.currentPriceLine || isNaN(price)) {
    if (dom.currentPriceLabel) dom.currentPriceLabel.style.display = "none";
    if (dom.currentPriceLine) dom.currentPriceLine.style.display = "none";
    return;
  }
  const chartHeight = dom.chartArea?.offsetHeight; // Use optional chaining
  if (!chartHeight) return;
  const y = getYCoordinate(price, chartHeight); // Use utility

  if (y !== null && !isNaN(y)) {
    const decimals = price < 1 ? 4 : price < 100 ? 2 : price < 10000 ? 1 : 0;
    dom.currentPriceLabel.textContent = price.toFixed(decimals);
    dom.currentPriceLabel.style.top = `${y.toFixed(1)}px`;
    dom.currentPriceLine.style.top = `${y.toFixed(1)}px`;
    dom.currentPriceLabel.style.display = "block";
    dom.currentPriceLine.style.display = "block";
  } else {
    dom.currentPriceLabel.style.display = "none";
    dom.currentPriceLine.style.display = "none";
  }
}

function connectWebSocket() {
  // Use the product ID currently shown on the chart for the primary WS subscription
  const productIdToSubscribe =
    state.currentProductId || config.DEFAULT_PRODUCT_ID; // Use state or fallback
  console.log(
    `Attempting WS connect: ${WEBSOCKET_URL} for ${productIdToSubscribe}`
  );

  if (
    ws &&
    ws.readyState !== WebSocket.CLOSED &&
    ws.readyState !== WebSocket.CLOSING
  ) {
    console.log("Closing existing WebSocket connection.");
    ws.close(1000, "Reconnecting");
  }
  ws = null; // Clear previous instance

  // Clear any pending timeouts
  if (chartRedrawTimeout) clearTimeout(chartRedrawTimeout);
  if (balanceUpdateTimeout) clearTimeout(balanceUpdateTimeout);
  chartRedrawTimeout = null;
  balanceUpdateTimeout = null;

  ws = new WebSocket(WEBSOCKET_URL);

  ws.onopen = () => {
    console.log(`WS connected for ${productIdToSubscribe}. Subscribing...`);
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(
        JSON.stringify({
          type: "subscribe",
          product_ids: [productIdToSubscribe], // Subscribe only to the main chart's product ID
          channels: ["ticker"], // Only need ticker for live updates
        })
      );
    } else {
      console.warn("WS opened but readyState is not OPEN. Cannot subscribe.");
    }
  };

  ws.onmessage = (event) => {
    // console.log("WS Raw:", event.data); // Uncomment for intense debugging
    try {
      const message = JSON.parse(event.data);

      if (message.type === "ticker" && message.price) {
        const price = parseFloat(message.price);
        const productId = message.product_id; // e.g., "BTC-USD"
        const currencyCode = productId ? productId.split("-")[0] : null; // e.g., "BTC"
        const tickerTime = message.time
          ? new Date(message.time).getTime() / 1000
          : null;

        // --- Update Global Price State ---
        if (currencyCode && !isNaN(price)) {
          updateLatestPrice(currencyCode, price); // Update the price in our global state map

          // --- Trigger Throttled Balance UI Update ---
          if (!balanceUpdateTimeout) {
            balanceUpdateTimeout = setTimeout(() => {
              updateBalanceValuesUI(); // Call the specific UI update function
              balanceUpdateTimeout = null; // Clear timeout ID
            }, BALANCE_UPDATE_THROTTLE_MS);
          }
        }

        // --- Update Chart (Only if message matches the chart's product ID) ---
        if (productId === productIdToSubscribe && !isNaN(price)) {
          updateState({ lastTickerPrice: price }); // Update chart-specific last ticker price
          updateLivePriceIndicatorUI(price); // Update indicator immediately

          // Update last candle logic (if applicable)
          if (tickerTime && state.fullData.length > 0) {
            const lastCandleIndex = state.fullData.length - 1;
            const lastCandle = state.fullData[lastCandleIndex];
            if (lastCandle && lastCandle.length >= 5) {
              // Need at least timestamp and prices
              const candleStartTime = lastCandle[0];
              const candleEndTime = candleStartTime + state.currentGranularity;

              if (tickerTime >= candleStartTime && tickerTime < candleEndTime) {
                let changed = false;
                // Update close price
                if (lastCandle[4] !== price) {
                  lastCandle[4] = price;
                  changed = true;
                }
                // Update high price
                if (price > lastCandle[2]) {
                  lastCandle[2] = price;
                  changed = true;
                }
                // Update low price
                if (price < lastCandle[1]) {
                  lastCandle[1] = price;
                  changed = true;
                }

                // Trigger throttled chart redraw if data changed
                if (changed && !chartRedrawTimeout) {
                  chartRedrawTimeout = setTimeout(() => {
                    requestAnimationFrame(redrawChart);
                    chartRedrawTimeout = null;
                  }, CHART_REDRAW_THROTTLE_MS);
                }
              }
            }
          }
        }
      } else if (message.type === "subscriptions") {
        console.log("WS Subscriptions:", message.channels);
      } else if (message.type === "error") {
        console.error("WS Error Msg:", message.message);
      }
    } catch (error) {
      console.error("Error processing WS msg:", error, event.data);
    }
  };

  ws.onerror = (error) => {
    console.error("WS Error Event:", error);
  };

  ws.onclose = (event) => {
    console.log(
      `WS closed. Code: ${event.code}, Reason: ${
        event.reason || "(No reason provided)"
      }, Clean: ${event.wasClean}`
    );
    ws = null;
    // Clear any pending timeouts on close
    if (chartRedrawTimeout) clearTimeout(chartRedrawTimeout);
    if (balanceUpdateTimeout) clearTimeout(balanceUpdateTimeout);
    chartRedrawTimeout = null;
    balanceUpdateTimeout = null;

    // Hide price indicator
    if (dom.currentPriceLabel) dom.currentPriceLabel.style.display = "none";
    if (dom.currentPriceLine) dom.currentPriceLine.style.display = "none";
    updateState({ lastTickerPrice: null });

    // Optional: Reconnect logic (only if not closed intentionally)
    if (event.code !== 1000) {
      // 1000 = Normal closure
      console.log("Attempting WS reconnect in 5s...");
      setTimeout(connectWebSocket, 5000);
    }
  };
}

// Initialize or Reconnect WebSocket for the main chart product
export function initializeWebSocket(productId = config.DEFAULT_PRODUCT_ID) {
  currentProductId = productId; // Update the tracked product ID
  connectWebSocket(); // Connect/reconnect using the current product ID
}

// Close WebSocket connection manually
export function closeWebSocket() {
  if (ws) {
    console.log("Closing WS manually.");
    // Clear timeouts before closing
    if (chartRedrawTimeout) clearTimeout(chartRedrawTimeout);
    if (balanceUpdateTimeout) clearTimeout(balanceUpdateTimeout);
    chartRedrawTimeout = null;
    balanceUpdateTimeout = null;
    ws.close(1000, "Client initiated closure"); // Use code 1000 for normal closure
    ws = null;
  }
  // UI cleanup might already happen in onclose, but can be done here too
  if (dom.currentPriceLabel) dom.currentPriceLabel.style.display = "none";
  if (dom.currentPriceLine) dom.currentPriceLine.style.display = "none";
  updateState({ lastTickerPrice: null });
}

// Function to update subscription if product ID changes (e.g., if user could select pairs later)
// NOTE: Currently we only subscribe to one product ID (the main chart's).
// If we needed live prices for ALL balances, we'd need to subscribe to multiple product_ids.
export function updateWebSocketSubscription(
  newProductId = config.DEFAULT_PRODUCT_ID
) {
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    console.log(`WS not open or ready, reconnecting for ${newProductId}.`);
    initializeWebSocket(newProductId); // Reconnect with the new product ID
    return;
  }

  if (newProductId !== currentProductId) {
    console.log(
      `Product change detected. Resubscribing from ${currentProductId} to ${newProductId}.`
    );
    // Unsubscribe from the old product ID
    ws.send(
      JSON.stringify({
        type: "unsubscribe",
        product_ids: [currentProductId],
        channels: ["ticker"],
      })
    );
    // Subscribe to the new product ID
    ws.send(
      JSON.stringify({
        type: "subscribe",
        product_ids: [newProductId],
        channels: ["ticker"],
      })
    );
    currentProductId = newProductId; // Update the tracked product ID
    updateState({ currentProductId: newProductId }); // Update state if needed elsewhere
  }
}

```
--- END FILE: js/liveUpdate.js ---


--- START FILE: js/main.js ---
```js
// js/main.js

import * as dom from "./domElements.js";
import state, { updateState } from "./state.js";
import * as config from "./config.js";
import { initializeTheme } from "./theme.js";
import { redrawChart } from "./drawing.js";
import { attachInteractionListeners } from "./interactions.js";
import {
  initializeWebSocket,
  closeWebSocket,
  updateWebSocketSubscription,
} from "./liveUpdate.js";
import { initializeBalances } from "./balance.js";
import { initializeResizer } from "./layout.js";
import { initializeSettingsMenu } from "./settingsMenu.js";
import { initializeTabs } from "./tabs.js";
import { initializePromptTab } from "./promptTab.js";
import { initializeVolumeChart } from "./volumeChart.js"; // Volume chart is back
import { MIN_LOG_VALUE } from "./utils.js";

// --- Status Indicator ---
function updateApiStatusIndicator(loaded, message = null) {
  if (!dom.apiStatusIndicator) return;
  dom.apiStatusIndicator.className = loaded ? "loaded" : "error";
  dom.apiStatusIndicator.textContent = message || (loaded ? "Loaded" : "Error");
}
function checkApiStatus() {
  if (!dom.apiStatusIndicator) return;
  dom.apiStatusIndicator.textContent = "Checking...";
  dom.apiStatusIndicator.className = "loading";
  fetch("http://localhost:5000/api/status")
    .then((response) => {
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      return response.json();
    })
    .then((data) => {
      updateApiStatusIndicator(
        data.credentials_loaded,
        data.credentials_loaded ? null : "Creds Failed"
      );
    })
    .catch((error) => {
      console.error("Error checking API status:", error);
      updateApiStatusIndicator(false, "Unavailable");
    });
}

// --- Initialize Chart View State ---
function initializeChartView(data) {
  console.log("[initializeChartView] Starting."); // Log start
  if (!data || !data.length) {
    console.warn("[initializeChartView] Skipped: No data.");
    return;
  }
  const savedLogPref = localStorage.getItem("logScalePref") === "true";
  const savedTimeFormatPref = localStorage.getItem("timeFormatPref") === "true";
  const totalDataCount = data.length;
  const initialVisibleCount = Math.min(
    config.DEFAULT_RESET_CANDLE_COUNT,
    totalDataCount
  );
  const initialStartIndex = Math.max(0, totalDataCount - initialVisibleCount);
  const initialEndIndex = totalDataCount;
  let initialMinY = Infinity,
    initialMaxY = -Infinity;
  for (let i = initialStartIndex; i < initialEndIndex; i++) {
    if (!data[i] || data[i].length < 5) continue;
    initialMinY = Math.min(initialMinY, data[i][1]); // low
    initialMaxY = Math.max(initialMaxY, data[i][2]); // high
  }
  if (
    initialMinY === Infinity ||
    initialMaxY === -Infinity ||
    initialMinY <= 0
  ) {
    const lastCandle = data[data.length - 1];
    const lastClose =
      lastCandle && lastCandle.length >= 5 && Number.isFinite(lastCandle[4])
        ? lastCandle[4]
        : 100;
    initialMinY = lastClose * 0.9;
    initialMaxY = lastClose * 1.1;
    console.warn("[initializeChartView] Using fallback Y range.");
  }
  initialMinY = Math.max(MIN_LOG_VALUE, initialMinY);
  if (initialMaxY <= initialMinY) {
    initialMaxY = initialMinY * 1.1;
  }
  let initialMinPrice, initialMaxPrice;
  if (savedLogPref) {
    const logPadding = 1 + config.Y_AXIS_LOG_PADDING_FACTOR;
    initialMinPrice = Math.max(MIN_LOG_VALUE, initialMinY / logPadding);
    initialMaxPrice = initialMaxY * logPadding;
    if (initialMaxPrice / initialMinPrice < 1.01) {
      const midLog =
        (Math.log(initialMaxPrice) + Math.log(initialMinPrice)) / 2;
      const halfRangeLog = Math.log(1.005);
      initialMinPrice = Math.max(
        MIN_LOG_VALUE,
        Math.exp(midLog - halfRangeLog)
      );
      initialMaxPrice = Math.exp(midLog + halfRangeLog);
    }
  } else {
    const linearPadding = Math.max(
      config.MIN_PRICE_RANGE_SPAN * 0.1,
      (initialMaxY - initialMinY) * config.Y_AXIS_PRICE_PADDING_FACTOR
    );
    initialMinPrice = Math.max(0, initialMinY - linearPadding);
    initialMaxPrice = initialMaxY + linearPadding;
    if (initialMaxPrice - initialMinPrice < config.MIN_PRICE_RANGE_SPAN) {
      const mid = (initialMaxPrice + initialMinPrice) / 2;
      initialMinPrice = Math.max(0, mid - config.MIN_PRICE_RANGE_SPAN / 2);
      initialMaxPrice = mid + config.MIN_PRICE_RANGE_SPAN / 2;
    }
  }
  updateState({
    visibleStartIndex: initialStartIndex,
    visibleEndIndex: initialEndIndex,
    minVisiblePrice: initialMinPrice,
    maxVisiblePrice: initialMaxPrice,
    isLogScale: savedLogPref,
    is12HourFormat: savedTimeFormatPref,
  });
  if (dom.logScaleToggle) dom.logScaleToggle.checked = savedLogPref;
  if (dom.timeFormatToggle) dom.timeFormatToggle.checked = savedTimeFormatPref;
  console.log(
    `[initializeChartView] Finished. State updated: StartIdx=${initialStartIndex}, EndIdx=${initialEndIndex}, MinPrice=${initialMinPrice.toFixed(
      2
    )}, MaxPrice=${initialMaxPrice.toFixed(2)}, Log=${savedLogPref}`
  );
}

// --- Fetch/Redraw Chart Data ---
function fetchAndRedraw(granularitySeconds) {
  console.log(
    `[fetchAndRedraw] Called with granularity: ${granularitySeconds}s`
  ); // Log entry
  try {
    updateState({ currentGranularity: granularitySeconds });
    const currentProductID = config.DEFAULT_PRODUCT_ID;
    const apiUrl = `http://localhost:5000/api/candles?granularity=${granularitySeconds}&product_id=${currentProductID}`;
    console.log(`[fetchAndRedraw] API URL: ${apiUrl}`);

    if (dom.chartMessage) {
      dom.chartMessage.textContent = `Loading ${currentProductID} ${Math.round(
        granularitySeconds / 60
      )}m data...`;
      dom.chartMessage.style.display = "block";
      console.log("[fetchAndRedraw] Loading message displayed.");
    } else {
      console.warn("[fetchAndRedraw] Chart message element not found.");
    }

    console.log("[fetchAndRedraw] Closing WebSocket before fetch...");
    closeWebSocket();

    console.log(`[fetchAndRedraw] Starting fetch from ${apiUrl}...`);
    fetch(apiUrl)
      .then((response) => {
        console.log(
          `[fetchAndRedraw] Received response status: ${response.status}`
        );
        if (!response.ok) {
          // Try to parse error JSON, otherwise use status text
          return response
            .json()
            .catch(() => ({
              error: `HTTP error ${response.status} (${response.statusText})`,
              details: response.statusText,
            }))
            .then((errData) => {
              const error = new Error(
                errData.error || `API Error ${response.status}`
              );
              error.details = errData.details || `Status: ${response.status}`;
              console.error("[fetchAndRedraw] HTTP error details:", errData); // Log error details
              throw error; // Important to re-throw
            });
        }
        return response.json();
      })
      .then((data) => {
        console.log("[fetchAndRedraw] Received JSON data.");
        if (!Array.isArray(data)) {
          throw new Error(
            "Invalid data format: API response was not an array."
          );
        }
        if (data.length === 0) {
          console.warn(
            `[fetchAndRedraw] No chart data returned for ${currentProductID} at ${granularitySeconds}s interval.`
          );
          updateState({ fullData: [] });
          if (dom.chartMessage)
            dom.chartMessage.textContent = `No data available for this interval.`;
          requestAnimationFrame(redrawChart); // Still redraw empty chart
          console.log("[fetchAndRedraw] Redrawing empty chart (no data).");
          return;
        }

        console.log(`[fetchAndRedraw] Loaded ${data.length} data points.`);
        let processedData = data;
        if (data.length > 1 && data[0][0] > data[data.length - 1][0]) {
          console.warn(
            "[fetchAndRedraw] Data received newest-first. Reversing."
          );
          processedData = data.slice().reverse();
        }
        updateState({ fullData: processedData });
        console.log("[fetchAndRedraw] Updated state with fullData.");

        initializeChartView(processedData); // Set initial view based on data

        if (dom.chartMessage) dom.chartMessage.style.display = "none";
        console.log(
          "[fetchAndRedraw] Requesting animation frame for redraw..."
        );
        requestAnimationFrame(redrawChart); // <<< THE REDRAW CALL
        console.log("[fetchAndRedraw] Requested animation frame.");

        console.log("[fetchAndRedraw] Initializing WebSocket...");
        initializeWebSocket(currentProductID); // Reconnect WebSocket AFTER processing data
      })
      .catch((error) => {
        console.error(
          "[fetchAndRedraw] Chart Data Fetch/Processing Error:",
          error
        );
        if (dom.chartMessage) {
          dom.chartMessage.textContent = `Error loading chart data: ${
            error.message
          }${error.details ? ` (${error.details})` : ""}`;
          dom.chartMessage.style.display = "block";
          dom.chartMessage.style.color = "red";
        }
        updateState({ fullData: [] });
        requestAnimationFrame(redrawChart); // Redraw empty chart on error
      });
  } catch (err) {
    console.error("[fetchAndRedraw] Synchronous error:", err);
    if (dom.chartMessage) {
      dom.chartMessage.textContent = `Error: ${err.message}`;
      dom.chartMessage.style.display = "block";
      dom.chartMessage.style.color = "red";
    }
  }
  console.log("[fetchAndRedraw] Function end."); // Log sync function exit
}

// --- Main Execution ---
document.addEventListener("DOMContentLoaded", () => {
  console.log("[DOMContentLoaded] Starting initialization..."); // Log start

  if (!dom.checkElements()) {
    console.error("[DOMContentLoaded] Aborting due to missing elements.");
    return; // Stop if elements are missing
  }
  console.log("[DOMContentLoaded] Element check passed.");

  try {
    // Wrap initialization steps in try-catch for safety
    initializeTheme();
    console.log("[DOMContentLoaded] Theme initialized.");
    initializeSettingsMenu();
    console.log("[DOMContentLoaded] Settings menu initialized.");
    initializeTabs("#bottom-tab-bar", ".tab-content-area");
    console.log("[DOMContentLoaded] Tabs initialized.");
    initializePromptTab();
    console.log("[DOMContentLoaded] Prompt tab initialized.");
    initializeVolumeChart();
    console.log("[DOMContentLoaded] Volume chart initialized.");
    attachInteractionListeners();
    console.log("[DOMContentLoaded] Interactions attached.");
    initializeResizer();
    console.log("[DOMContentLoaded] Resizer initialized.");
    checkApiStatus(); // Async
    console.log("[DOMContentLoaded] API status check initiated.");
    initializeBalances(); // Async
    console.log("[DOMContentLoaded] Balance initialization initiated.");

    // Setup Granularity Controls
    if (dom.granularityControls) {
      dom.granularityControls.addEventListener("click", (event) => {
        if (event.target.tagName === "BUTTON" && !event.target.disabled) {
          const newGranularity = parseInt(event.target.dataset.granularity, 10);
          if (
            !isNaN(newGranularity) &&
            newGranularity !== state.currentGranularity
          ) {
            console.log(
              `[Granularity] New selection: ${newGranularity}. Fetching...`
            );
            const currentActive =
              dom.granularityControls.querySelector("button.active");
            if (currentActive) currentActive.classList.remove("active");
            event.target.classList.add("active");
            fetchAndRedraw(newGranularity); // Fetch on click
          }
        }
      });
      // Set initial active button
      const initialActiveButton = dom.granularityControls.querySelector(
        `button[data-granularity="${state.currentGranularity}"]`
      );
      if (
        initialActiveButton &&
        !initialActiveButton.classList.contains("active")
      ) {
        const currentActive =
          dom.granularityControls.querySelector("button.active");
        if (currentActive) currentActive.classList.remove("active");
        initialActiveButton.classList.add("active");
      } else if (!initialActiveButton) {
        console.warn(
          `No granularity button found for default: ${state.currentGranularity}`
        );
        const firstButton = dom.granularityControls.querySelector("button");
        if (firstButton) firstButton.classList.add("active");
      }
      console.log("[DOMContentLoaded] Granularity controls set up.");
    } else {
      console.warn(
        "[DOMContentLoaded] Granularity controls element not found."
      );
    }

    // --- Initial data fetch ---
    console.log("[DOMContentLoaded] Performing initial data fetch..."); // Log before call
    fetchAndRedraw(state.currentGranularity); // <<< THE INITIAL CALL SITE
    console.log("[DOMContentLoaded] Initial data fetch function called."); // Log right after call

    window.addEventListener("beforeunload", () => {
      closeWebSocket();
    });

    console.log(
      "[DOMContentLoaded] GeminiTrader Frontend Initialization Sequence Complete."
    ); // Final log
  } catch (initError) {
    console.error(
      "[DOMContentLoaded] CRITICAL ERROR during initialization:",
      initError
    );
    // Display a user-facing error if possible
    if (dom.chartMessage) {
      dom.chartMessage.textContent = `Initialization Error: ${initError.message}`;
      dom.chartMessage.style.display = "block";
      dom.chartMessage.style.color = "red";
    } else {
      alert(`Application Initialization Error: ${initError.message}`);
    }
  }
});

```
--- END FILE: js/main.js ---


--- START FILE: js/orders.js ---
```js
// js/orders.js

import * as dom from "./domElements.js";
import { formatTimestamp, formatCurrency, formatQuantity } from "./utils.js"; // Keep imports

// --- <<<< RESTORE fetchOpenOrders FUNCTION >>>> ---
/**
 * Fetches open orders from the backend API.
 * @returns {Promise<Array|null>} A promise that resolves with an array of order objects or null if an error occurs.
 */
async function fetchOpenOrders() {
  console.log("[fetchOpenOrders] Starting fetch..."); // Add simple log
  const url = "http://localhost:5000/api/open_orders";
  try {
    const response = await fetch(url);
    console.log(`[fetchOpenOrders] Response status: ${response.status}`); // Log status
    const result = await response.json(); // Read JSON regardless of status

    if (!response.ok) {
      console.error(
        `[fetchOpenOrders] Error fetching open orders: ${response.status} ${response.statusText}`,
        result
      );
      throw new Error(
        result.error || `API Error (${response.status})`,
        result.details ? { cause: result.details } : undefined
      );
    }

    if (result && Array.isArray(result.orders)) {
      console.log(`[fetchOpenOrders] Received ${result.orders.length} orders.`);
      return result.orders;
    } else {
      console.warn(
        "[fetchOpenOrders] No 'orders' array found in the response:",
        result
      );
      return []; // Return empty array if structure is unexpected but response was ok
    }
  } catch (error) {
    console.error(
      "[fetchOpenOrders] Failed to fetch or parse open orders:",
      error
    );
    // Display error in the UI - Keep this part
    if (dom.openOrdersContent) {
      dom.openOrdersContent.innerHTML = `
                    <div class="pane-placeholder error">
                        <p>Error loading open orders.</p>
                        <small>${error.message} ${
        error.cause ? `(${error.cause})` : ""
      }</small>
                    </div>`;
    }
    return null; // Indicate failure
  }
}
// --- <<<< END OF RESTORED FUNCTION >>>> ---

/**
 * Renders the fetched open orders into the UI.
 * @param {Array|null} orders - An array of order objects, or null if fetching failed.
 */
function renderOpenOrders(orders) {
  if (!dom.openOrdersContent) {
    console.error("Cannot render orders: Target DOM element not found.");
    return;
  }

  dom.openOrdersContent.innerHTML = ""; // Clear previous

  if (orders === null) return; // Error handled by fetch

  if (!Array.isArray(orders) || orders.length === 0) {
    dom.openOrdersContent.innerHTML = `<div class="pane-placeholder"><p>No open orders found.</p></div>`;
    return;
  }

  const table = document.createElement("table");
  table.className = "orders-table";

  const thead = table.createTHead();
  const headerRow = thead.insertRow();
  const headers = [
    "Created",
    "Pair",
    "Type",
    "Side",
    "Price",
    "Size",
    "Filled",
    "Status",
  ];
  headers.forEach((text) => {
    const th = document.createElement("th");
    th.textContent = text;
    headerRow.appendChild(th);
  });

  const tbody = table.createTBody();
  orders.forEach((order, orderIndex) => {
    // Add index for logging clarity
    const row = tbody.insertRow();

    // --- More Detailed Logging ---
    console.log(
      `%c--- Processing Order ${orderIndex} (ID: ${
        order.order_id || "N/A"
      }) ---`,
      "color: blue; font-weight: bold;"
    );
    console.log(`  Available keys on 'order' object:`, Object.keys(order)); // Log all keys
    const keyToCheck = "created_time"; // Define the key we expect
    const hasKeyDirect = order.hasOwnProperty(keyToCheck); // Check direct ownership
    const valueViaDot = order.create_time; // Try dot notation again for comparison
    const valueViaBracket = order[keyToCheck]; // <<<< Access using bracket notation

    console.log(
      `  Does order directly have property "${keyToCheck}"? ${hasKeyDirect}`
    );
    console.log(
      `  Value via order.create_time:`,
      valueViaDot,
      `(Type: ${typeof valueViaDot})`
    );
    console.log(
      `  Value via order["${keyToCheck}"]:`,
      valueViaBracket,
      `(Type: ${typeof valueViaBracket})`
    ); // <<<< Log bracket access result
    // --- End Detailed Logging ---

    const type = (order.order_type || "UNKNOWN").toUpperCase();
    const side = (order.side || "UNKNOWN").toUpperCase();
    const status = (order.status || "UNKNOWN").toUpperCase();
    const pair = order.product_id || "--";
    const quoteCurrency = pair.includes("-") ? pair.split("-")[1] : "Quote";
    const baseCurrency = pair.includes("-") ? pair.split("-")[0] : "Base";

    // --- Use Bracket Notation for Time Handling ---
    const rawCreateTimeValue = order[keyToCheck]; // <<<< Use bracket notation result
    let createdTime = "--"; // Default
    let dateObject = null;
    try {
      // Check the value obtained via bracket notation
      if (rawCreateTimeValue && typeof rawCreateTimeValue === "string") {
        dateObject = new Date(rawCreateTimeValue);
        if (dateObject instanceof Date && !isNaN(dateObject.getTime())) {
          createdTime = formatTimestamp(dateObject); // Pass Date object
        } else {
          console.warn(
            `Invalid Date from create_time string: "${rawCreateTimeValue}"`
          );
          createdTime = "Invalid Time"; // Show specific error if parsing failed
        }
      } else if (rawCreateTimeValue) {
        console.warn(
          `create_time exists but is not a string:`,
          rawCreateTimeValue
        );
        createdTime = "Format Error";
      } else {
        // This case should now match the log output if valueViaBracket was undefined/null
        createdTime = "Missing Time";
      }
    } catch (e) {
      console.error(`Error processing create_time "${rawCreateTimeValue}":`, e);
      createdTime = "Processing Error";
    }
    console.log(`  Final createdTime for cell = "${createdTime}"`);
    // --- End Time Handling ---

    // --- Other Fields (Using bracket notation for consistency/safety) ---
    let price = "--";
    const orderConfig = order["order_configuration"]; // Use brackets
    if (type === "LIMIT") {
      const limitConfig =
        orderConfig?.limit_limit_gtd || orderConfig?.limit_limit_gtc;
      const limitPriceStr = limitConfig?.limit_price;
      if (limitPriceStr) {
        const num = parseFloat(limitPriceStr);
        if (!isNaN(num)) price = formatCurrency(num);
      }
    } else if (type === "MARKET") {
      price = "Market";
    }
    // Add STOP_LIMIT handling if needed

    let size = "--";
    if (type === "LIMIT" || type === "STOP_LIMIT") {
      const limitConfig =
        orderConfig?.limit_limit_gtd ||
        orderConfig?.limit_limit_gtc; /* || stop limit path */
      const sizeNumStr = limitConfig?.base_size;
      if (sizeNumStr) {
        const num = parseFloat(sizeNumStr);
        if (!isNaN(num)) size = `${formatQuantity(num)} ${baseCurrency}`;
      }
    } else if (type === "MARKET") {
      const marketConfig = orderConfig?.market_market_ioc;
      const baseSizeStr = marketConfig?.base_size;
      const quoteSizeStr = marketConfig?.quote_size;
      if (baseSizeStr) {
        const num = parseFloat(baseSizeStr);
        if (!isNaN(num)) size = `${formatQuantity(num)} ${baseCurrency}`;
      } else if (quoteSizeStr) {
        const num = parseFloat(quoteSizeStr);
        if (!isNaN(num)) size = `${formatCurrency(num, "")} ${quoteCurrency}`;
      }
    }

    let filledSize = formatQuantity(0);
    const filledSizeStr = order["filled_size"]; // Use bracket notation
    if (filledSizeStr) {
      const num = parseFloat(filledSizeStr);
      if (!isNaN(num)) filledSize = `${formatQuantity(num)} ${baseCurrency}`;
    }
    // --- End Other Fields ---

    // Add cells to row
    const cells = [
      createdTime,
      pair,
      type,
      side,
      price,
      size,
      filledSize,
      status,
    ];
    cells.forEach((content, index) => {
      const cell = row.insertCell();
      cell.textContent = content; // Stick with textContent for now
      // Apply Styling Classes
      if (index === 3)
        cell.classList.add(
          side === "BUY"
            ? "side-buy"
            : side === "SELL"
            ? "side-sell"
            : "side-unknown"
        );
      if ([4, 5, 6].includes(index)) {
        cell.style.textAlign = "right";
        cell.style.fontFamily = "monospace";
      }
      if (index === 7) cell.classList.add(`status-${status.toLowerCase()}`);
    });
  });

  dom.openOrdersContent.appendChild(table);
}

/**
 * Initializes the open orders functionality (called by tabs.js).
 */
export async function loadAndDisplayOpenOrders() {
  // Ensure target element exists before showing loading
  if (dom.openOrdersContent) {
    dom.openOrdersContent.innerHTML = `<div class="pane-placeholder"><p>Loading open orders...</p></div>`;
  } else {
    console.error(
      "[loadAndDisplayOpenOrders] Cannot show loading message, target element missing."
    );
    return; // Don't proceed if the container isn't there
  }
  // Now call fetchOpenOrders (which should be defined above)
  const orders = await fetchOpenOrders();
  // Render, even if orders is null (renderOpenOrders handles it)
  renderOpenOrders(orders);
}

```
--- END FILE: js/orders.js ---


--- START FILE: js/promptTab.js ---
```js
// js/promptTab.js
import * as dom from "./domElements.js";

const STORAGE_KEY = "geminiTraderPromptText"; // Key for localStorage
const DEBOUNCE_DELAY = 300; // ms delay before saving after user stops typing

let saveTimeout = null;

/**
 * Saves the current content of the prompt textarea to localStorage.
 */
function savePromptText() {
  if (dom.promptTextarea) {
    try {
      localStorage.setItem(STORAGE_KEY, dom.promptTextarea.value);
      // console.log("Prompt text saved."); // Optional: for debugging
    } catch (error) {
      console.error("Error saving prompt text to localStorage:", error);
      // Handle potential storage errors (e.g., quota exceeded)
    }
  }
}

/**
 * Debounced version of the save function.
 */
function debouncedSavePromptText() {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(savePromptText, DEBOUNCE_DELAY);
}

/**
 * Loads saved prompt text from localStorage on initialization.
 */
function loadPromptText() {
  if (dom.promptTextarea) {
    try {
      const savedText = localStorage.getItem(STORAGE_KEY);
      if (savedText !== null) {
        // Check for null, empty string is valid
        dom.promptTextarea.value = savedText;
        console.log("Prompt text loaded from localStorage.");
      } else {
        console.log("No saved prompt text found in localStorage.");
      }
    } catch (error) {
      console.error("Error loading prompt text from localStorage:", error);
    }
  }
}

/**
 * Initializes the prompt tab functionality: loads saved text and sets up auto-saving.
 */
export function initializePromptTab() {
  if (!dom.promptTextarea) {
    console.warn(
      "Prompt textarea not found. Skipping prompt tab initialization."
    );
    return;
  }

  // Load any previously saved text
  loadPromptText();

  // Add event listener to save text on input (debounced)
  dom.promptTextarea.addEventListener("input", debouncedSavePromptText);

  console.log("Prompt tab initialized.");
}

```
--- END FILE: js/promptTab.js ---


--- START FILE: js/settingsMenu.js ---
```js
// js/settingsMenu.js
import * as dom from "./domElements.js";

/**
 * Initializes the settings dropdown menu functionality.
 */
export function initializeSettingsMenu() {
  // Check if elements exist right at the start
  if (!dom.settingsButton) {
    console.error("Settings Button (#settings-button) not found!");
    return;
  }
  if (!dom.settingsDropdown) {
    console.error("Settings Dropdown (#settings-dropdown) not found!");
    return;
  }
  console.log(
    "Settings menu elements found:",
    dom.settingsButton,
    dom.settingsDropdown
  ); // Log found elements

  // --- Toggle Dropdown on Button Click ---
  dom.settingsButton.addEventListener("click", (event) => {
    console.log("Settings button clicked."); // Log click
    event.stopPropagation(); // Prevent the window click listener from closing it immediately

    const isCurrentlyShown = dom.settingsDropdown.classList.contains("show");
    console.log(`Dropdown 'show' class before toggle: ${isCurrentlyShown}`);

    dom.settingsDropdown.classList.toggle("show");

    const isNowShown = dom.settingsDropdown.classList.contains("show");
    console.log(`Dropdown 'show' class after toggle: ${isNowShown}`); // Log state after toggle
  });

  // --- Close Dropdown on Click Outside ---
  window.addEventListener("click", (event) => {
    // Only run if the dropdown is currently shown
    if (dom.settingsDropdown.classList.contains("show")) {
      // Check if the click was outside the dropdown AND outside the button
      const clickedOutside =
        !dom.settingsDropdown.contains(event.target) &&
        !dom.settingsButton.contains(event.target);

      // console.log("Window clicked while dropdown is shown. Clicked outside:", clickedOutside); // Debug log

      if (clickedOutside) {
        console.log("Clicked outside, removing 'show' class."); // Log closing action
        dom.settingsDropdown.classList.remove("show");
      }
    }
  });

  console.log("Settings menu event listeners attached.");
}

```
--- END FILE: js/settingsMenu.js ---


--- START FILE: js/state.js ---
```js
// js/state.js
import * as config from "./config.js";

const chartState = {
  fullData: [],
  visibleStartIndex: 0,
  visibleEndIndex: 0,
  minVisiblePrice: 0,
  maxVisiblePrice: 1,
  isLogScale: false,
  currentGranularity: config.DEFAULT_GRANULARITY,
  is12HourFormat: false, // Default to 24-hour format
  isPanning: false,
  isDraggingYAxis: false,
  isDraggingXAxis: false,
  panStartX: 0,
  panStartY: 0,
  panStartVisibleIndex: 0,
  panStartVisibleCount: 0,
  panStartMinPrice: 0,
  panStartMaxPrice: 0,
  lastDrawTime: 0,
  lastTickerPrice: null, // Store last known ticker price (for main chart indicator)
  latestPrices: new Map(), // <<<--- ADDED: Map to store latest price for each asset { 'BTC': 65000.12, 'ETH': 3400.50, ... }
};

export function updateState(newState) {
  Object.assign(chartState, newState);
}
export function getState() {
  return { ...chartState };
}
// Helper to update a single price in the map
export function updateLatestPrice(currencyCode, price) {
  if (
    currencyCode &&
    typeof currencyCode === "string" &&
    price !== null &&
    Number.isFinite(price)
  ) {
    chartState.latestPrices.set(currencyCode.toUpperCase(), price);
    // console.log(`Updated price for ${currencyCode}: ${price}`); // Optional debug
  }
}

export default chartState;

```
--- END FILE: js/state.js ---


--- START FILE: js/tabs.js ---
```js
// js/tabs.js
import { loadAndDisplayOpenOrders } from "./orders.js"; // Import the function

/**
 * Initializes tab switching functionality for a given container.
 * @param {string} tabBarSelector - CSS selector for the tab bar container (e.g., '#bottom-tab-bar').
 * @param {string} contentAreaSelector - CSS selector for the area containing the tab content panes (e.g., '.tab-content-area').
 */
export function initializeTabs(tabBarSelector, contentAreaSelector) {
  const tabBar = document.querySelector(tabBarSelector);
  const contentArea = document.querySelector(contentAreaSelector);

  if (!tabBar) {
    console.error(
      `Tab initialization failed: Tab bar not found with selector "${tabBarSelector}"`
    );
    return;
  }
  if (!contentArea) {
    console.error(
      `Tab initialization failed: Content area not found with selector "${contentAreaSelector}"`
    );
    return;
  }

  const tabButtons = tabBar.querySelectorAll(".tab-button");
  const contentPanes = contentArea.querySelectorAll(".tab-content");

  if (tabButtons.length === 0 || contentPanes.length === 0) {
    console.warn(
      "Tab initialization: No tab buttons or content panes found within the specified containers."
    );
    return;
  }

  // Add click listener to the tab bar (event delegation)
  tabBar.addEventListener("click", (event) => {
    const clickedButton = event.target.closest(".tab-button");
    if (!clickedButton) {
      return; // Click was not on a button
    }

    // Prevent unnecessary work if clicking the already active tab
    if (clickedButton.classList.contains("active")) {
      return;
    }

    const targetId = clickedButton.dataset.target;
    if (!targetId) {
      console.warn("Clicked tab button is missing 'data-target' attribute.");
      return;
    }

    const targetPane = contentArea.querySelector(`#${targetId}`);
    if (!targetPane) {
      console.warn(`Target content pane with ID "${targetId}" not found.`);
      return;
    }

    // --- Deactivate currently active elements ---
    const currentActiveButton = tabBar.querySelector(".tab-button.active");
    const currentActivePane = contentArea.querySelector(".tab-content.active");

    if (currentActiveButton) {
      currentActiveButton.classList.remove("active");
    }
    if (currentActivePane) {
      currentActivePane.classList.remove("active");
    }

    // --- Activate the new elements ---
    clickedButton.classList.add("active");
    targetPane.classList.add("active");

    console.log(`Switched tab to: ${targetId}`);

    // --- Trigger fetch/refresh logic when a tab becomes active ---
    if (targetId === "open-orders-content") {
      // Call the function to load and display orders for this specific tab
      loadAndDisplayOpenOrders();
    }
    // Example for future:
    // else if (targetId === 'order-history-content') {
    //   loadAndDisplayOrderHistory();
    // }
    // else if (targetId === 'positions-content') {
    // Optional: Re-fetch balances if needed, though they update via WS now
    // initializeBalances(); // Or a refresh function
    // }
  });

  console.log(`Tabs initialized for container: ${tabBarSelector}`);

  // Optional: Load data for the initially active tab immediately?
  const initiallyActiveButton = tabBar.querySelector(".tab-button.active");
  if (initiallyActiveButton) {
    const initialTargetId = initiallyActiveButton.dataset.target;
    if (initialTargetId === "open-orders-content") {
      // Only load if the default active tab is the orders tab
      // loadAndDisplayOpenOrders(); // Decided against preload, load on click is fine.
    }
  }
}

```
--- END FILE: js/tabs.js ---


--- START FILE: js/theme.js ---
```js
// js/theme.js
import * as dom from "./domElements.js"; // Import domElements
import * as config from "./config.js"; // Import config for colors

/**
 * Applies the selected theme (light/dark) to the application.
 * Sets the data-theme attribute and directly styles the body background.
 * @param {string} theme - The theme to apply ('light' or 'dark').
 */
function applyTheme(theme) {
  if (theme !== "light" && theme !== "dark") {
    console.warn(`Invalid theme specified: ${theme}. Defaulting to light.`);
    theme = "light";
  }

  // 1. Set data-theme attribute for CSS variable switching
  document.documentElement.setAttribute("data-theme", theme);

  // 2. Directly set body background color from config
  const bgColor =
    theme === "dark" ? config.DARK_MODE_BG_COLOR : config.LIGHT_MODE_BG_COLOR;
  document.body.style.backgroundColor = bgColor;

  // 3. Update toggle state if it exists
  if (dom.themeToggle) {
    dom.themeToggle.checked = theme === "dark";
  }

  console.log(`Theme applied: ${theme}, Background set to: ${bgColor}`);
}

/**
 * Initializes the theme based on saved preference, system preference, or default.
 * Attaches event listeners for theme changes.
 */
export function initializeTheme() {
  const userPrefersDark =
    window.matchMedia &&
    window.matchMedia("(prefers-color-scheme: dark)").matches;
  const savedTheme = localStorage.getItem("theme"); // Could be 'light' or 'dark'

  let initialTheme = "light"; // Default

  if (savedTheme === "light" || savedTheme === "dark") {
    initialTheme = savedTheme;
    console.log(`Using saved theme preference: ${initialTheme}`);
  } else if (userPrefersDark) {
    initialTheme = "dark";
    console.log(`Using system theme preference: ${initialTheme}`);
  } else {
    console.log(`Using default theme: ${initialTheme}`);
  }

  applyTheme(initialTheme); // Apply the determined initial theme

  // Listener for the theme toggle checkbox
  if (dom.themeToggle) {
    dom.themeToggle.addEventListener("change", function () {
      const newTheme = this.checked ? "dark" : "light";
      applyTheme(newTheme);
      try {
        localStorage.setItem("theme", newTheme); // Save preference
      } catch (e) {
        console.error("Could not save theme preference to localStorage:", e);
      }
    });
  } else {
    console.warn("Theme toggle checkbox not found.");
  }

  // Listener for changes in system preference (if no user preference is saved)
  window
    .matchMedia("(prefers-color-scheme: dark)")
    .addEventListener("change", (e) => {
      // Only apply system change if the user hasn't explicitly set a theme via toggle
      if (!localStorage.getItem("theme")) {
        const newSystemTheme = e.matches ? "dark" : "light";
        console.log(`System theme changed to: ${newSystemTheme}. Applying...`);
        applyTheme(newSystemTheme);
      } else {
        console.log(
          "System theme changed, but user preference is set. Ignoring system change."
        );
      }
    });
}

```
--- END FILE: js/theme.js ---


--- START FILE: js/utils.js ---
```js
// js/utils.js
import state from "./state.js";
import * as config from "./config.js"; // Import config for MIN_PRICE_RANGE_SPAN

export const MIN_LOG_VALUE = 1e-9; // Ensure this is exported
const MIN_LINEAR_RANGE_EPSILON = 1e-9; // Small value to check against zero range
const MIN_LOG_RANGE_EPSILON = 1e-9; // Small value for log range

export function getYCoordinate(price, chartHeight) {
  if (
    isNaN(price) ||
    isNaN(chartHeight) ||
    chartHeight <= 0 ||
    price < 0 // Allow price to be 0 on linear scale, but handle below
  ) {
    // console.warn("getYCoordinate: Invalid input price or chartHeight", { price, chartHeight });
    return null;
  }

  const { minVisiblePrice, maxVisiblePrice, isLogScale } = state;

  // Stricter validation of the visible price range
  if (
    isNaN(minVisiblePrice) ||
    isNaN(maxVisiblePrice) ||
    !Number.isFinite(minVisiblePrice) ||
    !Number.isFinite(maxVisiblePrice) ||
    maxVisiblePrice <= minVisiblePrice
  ) {
    // console.warn("getYCoordinate: Invalid visible price range in state", { minVisiblePrice, maxVisiblePrice });
    return null;
  }

  if (isLogScale) {
    const safeMinVisiblePrice = Math.max(MIN_LOG_VALUE, minVisiblePrice);
    const safeMaxVisiblePrice = Math.max(MIN_LOG_VALUE, maxVisiblePrice);
    // Ensure price itself is also treated as positive for log calculation
    const safePrice = Math.max(MIN_LOG_VALUE, price);

    if (safeMaxVisiblePrice <= safeMinVisiblePrice) return null; // Should be caught above, but double-check

    const logMin = Math.log(safeMinVisiblePrice);
    const logMax = Math.log(safeMaxVisiblePrice);
    const logPrice = Math.log(safePrice);

    if (
      !Number.isFinite(logMin) ||
      !Number.isFinite(logMax) ||
      !Number.isFinite(logPrice)
    ) {
      // console.warn("getYCoordinate (Log): Non-finite log value", { logMin, logMax, logPrice });
      return null;
    }

    const logRange = logMax - logMin;

    // Check for near-zero or invalid log range
    if (!Number.isFinite(logRange) || logRange < MIN_LOG_RANGE_EPSILON) {
      // If range is effectively zero, map based on comparison to min/max
      if (logPrice <= logMin) return chartHeight;
      if (logPrice >= logMax) return 0;
      return chartHeight / 2; // Fallback for prices within the zero range
    }

    const logScaleY = chartHeight / logRange;
    const yPos = chartHeight - (logPrice - logMin) * logScaleY;

    if (!Number.isFinite(yPos)) {
      // console.warn("getYCoordinate (Log): Calculated yPos is not finite", { price, yPos });
      return null;
    }
    return yPos;
  } else {
    // Linear Scale
    const priceRange = maxVisiblePrice - minVisiblePrice;

    // Check for near-zero or invalid linear range
    if (!Number.isFinite(priceRange) || priceRange < MIN_LINEAR_RANGE_EPSILON) {
      // If range is effectively zero, map based on comparison to min/max
      if (price <= minVisiblePrice) return chartHeight;
      if (price >= maxVisiblePrice) return 0;
      return chartHeight / 2; // Fallback for prices within the zero range
    }

    const scaleY = chartHeight / priceRange;
    const yPos = chartHeight - (price - minVisiblePrice) * scaleY;

    if (!Number.isFinite(yPos)) {
      // console.warn("getYCoordinate (Linear): Calculated yPos is not finite", { price, yPos });
      return null;
    }
    // Let drawing clip if needed, just ensure it's finite
    return yPos;
  }
}

export function getPriceFromYCoordinate(yPos, chartHeight) {
  if (isNaN(yPos) || isNaN(chartHeight) || chartHeight <= 0) return null;

  const { minVisiblePrice, maxVisiblePrice, isLogScale } = state;

  // Stricter validation of the visible price range
  if (
    isNaN(minVisiblePrice) ||
    isNaN(maxVisiblePrice) ||
    !Number.isFinite(minVisiblePrice) ||
    !Number.isFinite(maxVisiblePrice) ||
    maxVisiblePrice <= minVisiblePrice
  ) {
    // console.warn("getPriceFromYCoordinate: Invalid visible price range", { minVisiblePrice, maxVisiblePrice });
    return null;
  }

  // Clamp Y position to chart boundaries before calculation
  const clampedYPos = Math.max(0, Math.min(yPos, chartHeight));
  const fraction = (chartHeight - clampedYPos) / chartHeight; // Fraction from bottom (0) to top (1)

  if (isLogScale) {
    const safeMinVisiblePrice = Math.max(MIN_LOG_VALUE, minVisiblePrice);
    const safeMaxVisiblePrice = Math.max(MIN_LOG_VALUE, maxVisiblePrice);

    if (safeMaxVisiblePrice <= safeMinVisiblePrice) return safeMinVisiblePrice;

    const logMin = Math.log(safeMinVisiblePrice);
    const logMax = Math.log(safeMaxVisiblePrice);

    if (!Number.isFinite(logMin) || !Number.isFinite(logMax)) return null;

    const logRange = logMax - logMin;

    if (!Number.isFinite(logRange) || logRange < MIN_LOG_RANGE_EPSILON) {
      // If range is negligible, return the min price
      return safeMinVisiblePrice;
    }

    const logPrice = logMin + fraction * logRange;
    const price = Math.exp(logPrice);

    // Ensure result is finite
    return Number.isFinite(price) ? price : null;
  } else {
    // Linear Scale
    const priceRange = maxVisiblePrice - minVisiblePrice;

    if (!Number.isFinite(priceRange) || priceRange < MIN_LINEAR_RANGE_EPSILON) {
      // If range is negligible, return the min price
      return minVisiblePrice;
    }

    const price = minVisiblePrice + fraction * priceRange;

    // Ensure price is not negative and is finite
    return Number.isFinite(price) ? Math.max(0, price) : null;
  }
}

export function calculateNiceStep(range, maxTicks) {
  if (
    isNaN(range) ||
    range <= 0 ||
    isNaN(maxTicks) ||
    maxTicks <= 0 ||
    !Number.isFinite(range)
  ) {
    return 1; // Return a default step if input is invalid
  }

  const roughStep = range / Math.max(1, maxTicks);
  if (roughStep <= 0 || isNaN(roughStep) || !Number.isFinite(roughStep)) {
    return 1; // Default if rough step calculation fails
  }

  // Handle extremely small rough steps that might cause log10 issues
  if (roughStep < Number.EPSILON) {
    return Number.EPSILON * 10;
  }

  const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
  if (magnitude <= 0 || !Number.isFinite(magnitude)) {
    // Fallback if magnitude calculation fails (e.g., extremely large range)
    return roughStep > 1 ? roughStep : 1;
  }

  const residual = roughStep / magnitude;

  let niceStep;
  if (residual > 5) niceStep = 10 * magnitude;
  else if (residual > 2) niceStep = 5 * magnitude;
  else if (residual > 1) niceStep = 2 * magnitude;
  else niceStep = magnitude;

  // Ensure the step is a reasonably small fraction of the range if range is tiny
  // and also ensure it's at least a minimum value to prevent near-zero steps.
  const minStep = Math.max(Number.EPSILON * 10, range * 1e-9);

  // Ensure niceStep is finite before returning
  return Number.isFinite(niceStep) ? Math.max(niceStep, minStep) : minStep;
}

// --- Time/Date Formatting ---

/**
 * Formats a timestamp or Date object into a human-readable string.
 * Handles both Unix timestamp (seconds) and JavaScript Date objects.
 * @param {number|Date} timestampOrDate - Unix timestamp (seconds) or Date object.
 * @returns {string} Formatted date/time string or "Invalid Date/Time".
 */
export function formatTimestamp(timestampOrDate) {
  try {
    let date;
    // ** Check input type **
    if (timestampOrDate instanceof Date) {
      date = timestampOrDate; // Use Date object directly
    } else if (
      typeof timestampOrDate === "number" &&
      Number.isFinite(timestampOrDate)
    ) {
      // Assume Unix timestamp in seconds, convert to milliseconds for Date constructor
      date = new Date(timestampOrDate * 1000);
    } else {
      // Handle other invalid inputs
      console.warn(
        "formatTimestamp received invalid input type:",
        typeof timestampOrDate,
        timestampOrDate
      );
      throw new Error(
        "Invalid input type: Expected number (Unix timestamp) or Date object."
      );
    }

    // Validate the resulting Date object
    if (isNaN(date.getTime())) {
      console.warn(
        "formatTimestamp resulted in an Invalid Date for input:",
        timestampOrDate
      );
      throw new Error("Invalid Date object produced");
    }

    // Use Intl.DateTimeFormat
    const options = {
      timeZone: "America/Chicago", // Set specific timezone
      // Adjust format as desired (e.g., remove year, add seconds)
      month: "numeric",
      day: "numeric",
      // year: 'numeric', // Optional: Add year if needed
      hour: "numeric",
      minute: "2-digit",
      // second: '2-digit', // Optional: Add seconds if needed
      hour12: state.is12HourFormat, // Use state setting
    };
    return date.toLocaleString("en-US", options);
  } catch (error) {
    console.error("Error formatting timestamp/date:", error, timestampOrDate);
    return "Time Error"; // More specific fallback
  }
}

export function formatDate(timestamp) {
  // This function primarily used for chart tooltips (assumes Unix timestamp)
  try {
    const date = new Date(timestamp * 1000); // Assumes Unix seconds
    const options = {
      timeZone: "America/Chicago",
      month: "short",
      day: "numeric",
      // Maybe add year?
      // year: 'numeric',
    };
    if (isNaN(date.getTime())) {
      throw new Error("Invalid timestamp resulted in Invalid Date");
    }
    return date.toLocaleDateString("en-US", options);
  } catch (error) {
    console.error("Error formatting date:", error, timestamp);
    return "Date Err";
  }
}

export function formatCurrency(value, currencySymbol = "$", decimals = 2) {
  const numValue = typeof value === "string" ? parseFloat(value) : value;

  if (isNaN(numValue) || numValue === null || !Number.isFinite(numValue)) {
    // Return placeholder but maybe less visually intrusive than '--.--'
    return `?`;
  }
  try {
    // Determine decimals dynamically based on value, suitable for crypto prices
    let dynamicDecimals;
    if (numValue === 0) {
      dynamicDecimals = decimals; // Use default for zero
    } else if (Math.abs(numValue) < 0.0001) {
      dynamicDecimals = 8;
    } else if (Math.abs(numValue) < 0.1) {
      dynamicDecimals = 6;
    } else if (Math.abs(numValue) < 10) {
      dynamicDecimals = 4;
    } else if (Math.abs(numValue) < 1000) {
      dynamicDecimals = 2;
    } else {
      dynamicDecimals = 2; // Default for larger numbers
    }

    // Ensure minimum decimals if explicitly passed higher than dynamic default
    const finalDecimals = Math.max(decimals, dynamicDecimals);

    // Use compact notation for very large or small numbers if desired?
    // const notation = (Math.abs(numValue) > 1e6 || Math.abs(numValue) < 1e-3) ? 'compact' : 'standard';

    return numValue
      .toLocaleString("en-US", {
        style: "currency",
        currency: "USD", // Keep this as USD for the engine
        minimumFractionDigits: finalDecimals,
        maximumFractionDigits: finalDecimals,
        // notation: notation // Example if using compact notation
      })
      .replace("USD", currencySymbol) // Optional: Replace code if symbol is desired
      .replace(/^\$/, currencySymbol); // Ensure the passed symbol is used
  } catch (e) {
    console.error("Currency formatting error:", e, { value, decimals });
    // Fallback formatting
    const safeDecimals = Math.max(0, Math.floor(decimals));
    return `${currencySymbol}${numValue.toFixed(safeDecimals)}`;
  }
}

export function formatQuantity(value) {
  const numValue = typeof value === "string" ? parseFloat(value) : value;

  if (isNaN(numValue) || numValue === null || !Number.isFinite(numValue))
    return "--";

  const absValue = Math.abs(numValue);
  let decimals;

  // Determine decimals based on magnitude, optimized for crypto quantities
  if (absValue === 0) decimals = 2; // Show 0.00
  else if (absValue < 0.00000001)
    decimals = 10; // Even more precision for tiny amounts
  else if (absValue < 0.00001) decimals = 8;
  else if (absValue < 0.01) decimals = 6;
  else if (absValue < 1) decimals = 5;
  else if (absValue < 100) decimals = 4;
  else if (absValue < 10000) decimals = 3;
  else decimals = 2; // Standard for large quantities

  try {
    // Use number formatting for locale-specific separators
    return numValue.toLocaleString("en-US", {
      minimumFractionDigits: 2, // Show at least 2 for visual consistency
      maximumFractionDigits: decimals,
    });
  } catch (e) {
    console.error("Quantity formatting error:", e, { value, decimals });
    // Fallback to fixed decimal places
    return numValue.toFixed(decimals);
  }
}

```
--- END FILE: js/utils.js ---


--- START FILE: js/volumeChart.js ---
```js
// js/volumeChart.js
import * as dom from "./domElements.js";
// No need to import state directly if passed into drawVolumeChart

let ctx = null;
let canvasWidth = 0;
let canvasHeight = 0;

/**
 * Initializes the volume chart canvas context.
 */
export function initializeVolumeChart() {
  if (!dom.volumeChartCanvas) {
    console.error("Volume chart canvas not found. Cannot initialize.");
    return;
  }
  ctx = dom.volumeChartCanvas.getContext("2d");
  if (!ctx) {
    console.error("Failed to get 2D context for volume chart canvas.");
    return;
  }
  console.log("Volume chart initialized.");
}

/**
 * Draws the volume bars based on the main chart's visible data.
 *
 * @param {object} mainChartState - The main chart's state (including fullData, visibleStartIndex, visibleEndIndex).
 * @param {number} mainDrawingAreaWidth - The width of the main chart's drawing area (needed for alignment).
 */
export function drawVolumeChart(mainChartState, mainDrawingAreaWidth) {
  // Ensure context and canvas element exist before proceeding
  if (!ctx || !dom.volumeChartCanvas || !dom.volumeChartContainer) {
    // console.warn("Volume chart draw skipped: Context or Canvas element missing."); // Less noise
    return;
  }

  canvasWidth =
    dom.volumeChartContainer.offsetWidth -
    dom.volumeChartContainer.style.paddingLeft -
    dom.volumeChartContainer.style.paddingRight -
    55; // Calculate usable width (consider padding/axis)
  canvasHeight = dom.volumeChartContainer.offsetHeight; // Use container height

  // Ensure canvas has valid dimensions to draw on
  if (canvasWidth <= 0 || canvasHeight <= 0) {
    if (dom.volumeChartCanvas.width > 0 || dom.volumeChartCanvas.height > 0) {
      dom.volumeChartCanvas.width = 0;
      dom.volumeChartCanvas.height = 0;
    }
    return;
  }

  // Ensure canvas internal resolution matches display size
  if (
    dom.volumeChartCanvas.width !== canvasWidth ||
    dom.volumeChartCanvas.height !== canvasHeight
  ) {
    dom.volumeChartCanvas.width = canvasWidth;
    dom.volumeChartCanvas.height = canvasHeight;
  }

  // Clear the canvas for redrawing
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  const { fullData, visibleStartIndex, visibleEndIndex } = mainChartState;
  const visibleCount = visibleEndIndex - visibleStartIndex;

  // Ensure there is data and visible candles to process
  if (
    !fullData ||
    visibleCount <= 0 ||
    fullData.length === 0 ||
    mainDrawingAreaWidth <= 0
  ) {
    return; // Nothing to draw
  }

  // --- Calculate Volume Scale ---
  let maxVisibleVolume = 0;
  for (let i = visibleStartIndex; i < visibleEndIndex; i++) {
    if (
      fullData[i] &&
      fullData[i].length > 5 &&
      typeof fullData[i][5] === "number" &&
      !isNaN(fullData[i][5])
    ) {
      maxVisibleVolume = Math.max(maxVisibleVolume, fullData[i][5]);
    }
  }

  // Avoid division by zero
  if (maxVisibleVolume <= 0) {
    return;
  }
  const volumeScaleY = canvasHeight / maxVisibleVolume; // Scale based on canvas height

  // --- Calculate Bar Width and Alignment ---
  // Use the main chart's drawing area width for alignment calculation
  const barTotalWidth = mainDrawingAreaWidth / visibleCount;
  const barWidthRatio = 0.7;
  const barWidth = Math.max(1, barTotalWidth * barWidthRatio);

  // --- Get Colors and Opacity ---
  const styles = getComputedStyle(document.documentElement);
  const colorUp = styles.getPropertyValue("--candle-up").trim();
  const colorDown = styles.getPropertyValue("--candle-down").trim();
  const barOpacity = parseFloat(
    styles.getPropertyValue("--volume-bar-opacity").trim() || 0.6
  ); // Adjusted default

  ctx.globalAlpha = barOpacity;

  // --- Draw Bars ---
  for (let i = 0; i < visibleCount; i++) {
    const dataIndex = visibleStartIndex + i;
    if (dataIndex < 0 || dataIndex >= fullData.length) continue;

    const candle = fullData[dataIndex];
    // Need open[3], close[4], volume[5]
    if (
      !candle ||
      candle.length < 6 ||
      typeof candle[3] !== "number" ||
      isNaN(candle[3]) ||
      typeof candle[4] !== "number" ||
      isNaN(candle[4]) ||
      typeof candle[5] !== "number" ||
      isNaN(candle[5]) ||
      candle[5] <= 0
    ) {
      continue; // Skip invalid or zero volume candles
    }

    const open = candle[3];
    const close = candle[4];
    const volume = candle[5];
    const barHeight = Math.max(1, volume * volumeScaleY);
    const isUp = close >= open;

    // Calculate X position based on the main chart's drawing area width
    const barCenterX = (i + 0.5) * barTotalWidth;
    const barLeft = barCenterX - barWidth / 2;

    ctx.fillStyle = isUp ? colorUp : colorDown;

    const yPos = Math.max(0, canvasHeight - barHeight);
    const drawHeight = Math.min(barHeight, canvasHeight - yPos); // Prevent drawing past bottom
    ctx.fillRect(barLeft, yPos, barWidth, drawHeight);
  }

  ctx.globalAlpha = 1.0;

  // Optional: Draw Y-Axis Labels for Volume (Simple Example)
  if (dom.volumeYAxisLabels) {
    dom.volumeYAxisLabels.innerHTML = ""; // Clear old labels
    const maxVolFormatted = formatVolumeLabel(maxVisibleVolume);
    const midVolFormatted = formatVolumeLabel(maxVisibleVolume / 2);

    // Max Label (Top)
    const maxLabel = document.createElement("div");
    maxLabel.className = "axis-label y-axis-label";
    maxLabel.style.top = "2px"; // Position near top
    maxLabel.textContent = maxVolFormatted;
    dom.volumeYAxisLabels.appendChild(maxLabel);

    // Mid Label (Approx Middle)
    const midLabel = document.createElement("div");
    midLabel.className = "axis-label y-axis-label";
    midLabel.style.top = `${(canvasHeight / 2).toFixed(0)}px`;
    midLabel.style.transform = "translateY(-50%)"; // Center vertically
    midLabel.textContent = midVolFormatted;
    dom.volumeYAxisLabels.appendChild(midLabel);

    // Zero label is implicitly at the bottom
  }
}

// Helper to format volume labels nicely (e.g., 1.23M, 543K)
function formatVolumeLabel(volume) {
  if (volume >= 1e6) {
    return (volume / 1e6).toFixed(2) + "M";
  } else if (volume >= 1e3) {
    return (volume / 1e3).toFixed(1) + "K";
  } else {
    return volume.toFixed(0); // Show whole numbers for small volumes
  }
}

```
--- END FILE: js/volumeChart.js ---


--- START FILE: server.py ---
```py
# server.py

import os
import json
import requests
import datetime
import time

# Import the correct SDK client
from coinbase.rest import RESTClient

from flask import Flask, request, jsonify
from flask_cors import CORS

# --- Configuration ---
CREDENTIALS_FILE_NAME = "cdp_api_key.json"
CREDENTIALS_FOLDER = "credentials"
PUBLIC_BASE_URL = "https://api.exchange.coinbase.com"  # For candles & public ticker
DEFAULT_PRODUCT_ID = "BTC-USD"
DEFAULT_GRANULARITY = 3600

# --- Load Credentials & Init SDK Client ---
COINBASE_API_KEY_NAME = None
COINBASE_API_PRIVATE_KEY_PEM = None
credentials_loaded = False
rest_client = None
try:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    credentials_path = os.path.join(
        script_dir, CREDENTIALS_FOLDER, CREDENTIALS_FILE_NAME)
    print(f"Attempting to load Cloud API Key from: {credentials_path}")
    if not os.path.exists(credentials_path):
        raise FileNotFoundError(f"File not found: {credentials_path}")
    with open(credentials_path, 'r') as f:
        credentials_data = json.load(f)
    COINBASE_API_KEY_NAME = credentials_data.get('name')
    COINBASE_API_PRIVATE_KEY_PEM = credentials_data.get('privateKey')
    if not COINBASE_API_KEY_NAME or not COINBASE_API_PRIVATE_KEY_PEM:
        raise ValueError("Missing 'name' or 'privateKey' in JSON")
    print("Cloud API Key credentials successfully read from file.")
    credentials_loaded = True
    print(f"  API Key Name: {COINBASE_API_KEY_NAME}")
    # Initialize Client only if credentials loaded
    try:
        print("Initializing coinbase.rest.RESTClient with Cloud Key...")
        rest_client = RESTClient(
            api_key=COINBASE_API_KEY_NAME,
            api_secret=COINBASE_API_PRIVATE_KEY_PEM
        )
        print("REST Client initialized successfully.")
    except Exception as client_e:
        print(f"!!! ERROR Initializing REST Client: {client_e}")
        import traceback
        traceback.print_exc()
        rest_client = None
        credentials_loaded = False  # Failed init means not ready
except Exception as e:
    print(f"\n!!! ERROR Loading Credentials or Initializing Client: {e}\n")
    credentials_loaded = False
if not credentials_loaded or not rest_client:
    print("WARNING: Credentials loading or client initialization failed. Authenticated endpoints will fail.")

# --- Flask App Setup ---
app = Flask(__name__)
CORS(app)

# --- Helper Function to Safely Convert SDK Objects ---


def sdk_object_to_dict(obj):
    """ Converts SDK objects with to_dict() method, handles nested structures. """
    if hasattr(obj, 'to_dict') and callable(obj.to_dict):
        return sdk_object_to_dict(obj.to_dict())  # Recursively convert result
    elif isinstance(obj, dict):
        return {k: sdk_object_to_dict(v) for k, v in obj.items()}
    elif isinstance(obj, list):
        return [sdk_object_to_dict(item) for item in obj]
    else:
        # Convert datetime or other specific types if needed, otherwise return as is
        if isinstance(obj, datetime.datetime):
            return obj.isoformat()  # Example: Convert datetime to ISO string
        return obj


# --- Handle SDK Errors Gracefully ---
def handle_sdk_error(e, context="SDK call"):
    """ Standard way to log and format SDK errors for JSON response. """
    print(f"!!! ERROR during {context}: {e}")
    error_message = f"Failed during {context}: {str(e)}"
    status_code = 500
    details = None
    if hasattr(e, 'response') and e.response is not None:
        status_code = e.response.status_code
        try:
            error_details = e.response.json()
        except json.JSONDecodeError:
            try:
                error_details = e.response.text
            except:
                error_details = "(Could not get error details)"
        print(f"--- SDK API Error Details (Status: {status_code}) ---")
        print(error_details)
        if isinstance(error_details, dict):
            details = error_details.get('message', error_details)
        else:
            details = str(error_details)

        if status_code == 401:
            error_message = f"SDK Auth failed (401): Check Cloud Key Permissions/Clock."
        elif status_code == 429:
            error_message = "SDK Rate Limit Exceeded (429)."
        elif status_code == 400:
            error_message = f"SDK Bad Request (400)"  # Details usually helpful
        else:
            error_message = f"SDK API Error ({status_code})"
    else:
        import traceback
        traceback.print_exc()
    return jsonify({"error": error_message, "details": details}), status_code


# --- API Status Endpoint ---
@app.route('/api/status')
def get_api_status():
    client_ready = credentials_loaded and (rest_client is not None)
    return jsonify({"credentials_loaded": client_ready})

# --- API Endpoint for Chart Data (Public) ---


@app.route('/api/candles')
def get_candles():
    """ Fetches candlestick data (Public). """
    product_id = request.args.get('product_id', DEFAULT_PRODUCT_ID)
    try:
        granularity = int(request.args.get('granularity', DEFAULT_GRANULARITY))
    except ValueError:
        return jsonify({"error": "Invalid granularity value"}), 400
    start_iso = request.args.get('start', None)
    end_iso = request.args.get('end', None)
    endpoint = f"/products/{product_id}/candles"
    url = PUBLIC_BASE_URL + endpoint
    params = {"granularity": granularity}
    if start_iso:
        params["start"] = start_iso
    if end_iso:
        params["end"] = end_iso
    print(f"Fetching candles: {url} with params {params}")
    try:
        response = requests.get(url, params=params, timeout=15)
        response.raise_for_status()
        candles_data = response.json()
        print(f"Coinbase returned {len(candles_data)} candles.")
        return jsonify(candles_data)
    except requests.exceptions.HTTPError as err:
        print(f"HTTP error fetching candles: {err}")
        details = f"HTTP Error {err.response.status_code}"
        try:
            details_json = err.response.json()
            details = details_json.get('message', details_json)
        except:
            pass
        return jsonify({"error": f"API error {err.response.status_code}", "details": details}), err.response.status_code
    except requests.exceptions.RequestException as err:
        print(f"Request error fetching candles: {err}")
        return jsonify({"error": f"Connection error: {err}"}), 502
    except Exception as e:
        print(f"Unexpected error fetching candles: {e}")
        return jsonify({"error": f"Server error: {e}"}), 500

# --- Public Ticker Endpoint ---


@app.route('/api/ticker')
def get_ticker():
    """ Fetches public ticker data for a specific product ID. """
    product_id = request.args.get('product_id')
    if not product_id:
        return jsonify({"error": "Missing 'product_id' query parameter"}), 400
    endpoint = f"/products/{product_id}/ticker"
    url = PUBLIC_BASE_URL + endpoint
    print(f"Fetching public ticker: {url}")
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        ticker_data = response.json()
        price = ticker_data.get('price')
        if price is None:
            return jsonify({"error": f"Could not find price for {product_id}"}), 404
        return jsonify({"product_id": product_id, "price": price})
    except requests.exceptions.HTTPError as err:
        status_code = err.response.status_code
        print(f"HTTP error fetching ticker for {product_id}: {err}")
        if status_code == 404:
            return jsonify({"error": f"Product ID '{product_id}' not found."}), 404
        details = f"HTTP Error {status_code}"
        try:
            details_json = err.response.json()
            details = details_json.get('message', details_json)
        except:
            pass
        return jsonify({"error": f"API error {status_code}", "details": details}), status_code
    except requests.exceptions.RequestException as err:
        print(f"Request error fetching ticker for {product_id}: {err}")
        return jsonify({"error": f"Connection error: {err}"}), 502
    except Exception as e:
        print(f"Unexpected error fetching ticker for {product_id}: {e}")
        return jsonify({"error": f"Server error: {e}"}), 500

# --- Accounts Endpoint (SDK) ---


@app.route('/api/accounts', methods=['GET'])
def get_accounts():
    """ Fetches account balances using SDK. """
    print("Received request for /api/accounts")
    if not rest_client:
        print("-> REST Client not initialized, returning 503.")
        return jsonify({"error": "API Client not ready on server.", "accounts": []}), 503
    try:
        print("Attempting client.get_accounts()...")
        sdk_response = rest_client.get_accounts()
        print(f"Successfully processed SDK response for accounts.")

        # Convert response to dict using helper
        response_dict = sdk_object_to_dict(sdk_response)

        # Extract accounts list (assuming standard structure)
        account_list = response_dict.get('accounts', [])

        print(f"  -> Found {len(account_list)} accounts in response.")
        return jsonify({"accounts": account_list})

    except Exception as e:
        return handle_sdk_error(e, context="get_accounts")

# --- NEW: Open Orders Endpoint (SDK) ---


@app.route('/api/open_orders', methods=['GET'])
def get_open_orders():
    """ Fetches open orders using SDK. """
    print("Received request for /api/open_orders")
    if not rest_client:
        print("-> REST Client not initialized, returning 503.")
        return jsonify({"error": "API Client not ready on server.", "orders": []}), 503
    try:
        print("Attempting client.list_orders(order_status=['OPEN'])...")
        # Fetch only OPEN orders
        # Note: The SDK might use different parameter names/values than the raw API.
        # Check SDK docs if `order_status=['OPEN']` doesn't work.
        # Common alternatives: `open_orders=True` or specific statuses like PENDING, ACTIVE.
        # Based on coinbase-advanced-py source, order_status seems correct.
        sdk_response = rest_client.list_orders(order_status=['OPEN'])
        print("Successfully processed SDK response for open orders.")

        # Convert response to dict using helper
        response_dict = sdk_object_to_dict(sdk_response)

        # Extract orders list
        order_list = response_dict.get('orders', [])

        print(f"  -> Found {len(order_list)} open orders.")
        return jsonify({"orders": order_list})

    except Exception as e:
        return handle_sdk_error(e, context="list_orders (open)")


# --- Order Placement Endpoint (Not Implemented) ---
@app.route('/api/orders', methods=['POST'])
def place_order():
    print("Received request for POST /api/orders")
    if not rest_client:
        return jsonify({"error": "API Client not ready."}), 503
    # --- Order Placement Logic Would Go Here ---
    # 1. Get order details from request.json
    #    product_id = request.json.get('product_id')
    #    side = request.json.get('side') # 'BUY' or 'SELL'
    #    order_type = request.json.get('type') # 'LIMIT' or 'MARKET'
    #    size = request.json.get('size') # Base size
    #    price = request.json.get('price') # For limit orders
    #    client_order_id = str(uuid.uuid4()) # Generate unique ID
    #
    # 2. Validate input
    #
    # 3. Call appropriate SDK method (e.g., client.create_order)
    #    try:
    #        if order_type == 'LIMIT':
    #           sdk_response = rest_client.create_order(
    #               client_order_id=client_order_id,
    #               product_id=product_id,
    #               side=side,
    #               order_configuration={ # Structure depends on SDK version
    #                   "limit_limit_gtd": {
    #                       "base_size": size,
    #                       "limit_price": price,
    #                       "post_only": False, # Example
    #                       # "end_time": ... # For GTD
    #                   }
    #               }
    #           )
    #        elif order_type == 'MARKET':
    #            # Market order structure might differ (quote_size or base_size)
    #            sdk_response = rest_client.create_order(...)
    #        else:
    #            return jsonify({"error": "Unsupported order type"}), 400
    #
    #        response_dict = sdk_object_to_dict(sdk_response)
    #        return jsonify(response_dict), 201 # Created
    #
    #    except Exception as e:
    #        return handle_sdk_error(e, context="create_order")
    #
    print("-> Actual order placement using SDK not implemented. Returning 501.")
    return jsonify({"error": "Order placement not implemented."}), 501


# --- Run App ---
if __name__ == '__main__':
    print("Starting Flask server...")
    app.run(host='0.0.0.0', port=5000, debug=True)

```
--- END FILE: server.py ---


--- START FILE: style.css ---
```css
/* --- General Setup & CSS Variables --- */
:root {
  --bg-color: #f0f0f0; /* Fallback/Initial BG */
  --text-color: #333;
  --subtle-text-color: #555;
  --card-bg: #ffffff; /* Used for distinct elements like header, dropdowns, textarea */
  --border-color: #e0e0e0;
  --grid-color: #eeeeee;
  --axis-label-bg: rgba(
    255,
    255,
    255,
    0.85
  ); /* Semi-transparent for text readability */
  --switch-bg: #ccc;
  --switch-slider: #fff;
  --switch-slider-checked: #26a69a;
  --candle-up: #26a69a;
  --candle-down: #ef5350;
  --shadow-color: rgba(0, 0, 0, 0.05);
  --border-radius-sm: 4px;
  --border-radius-md: 6px;
  --current-price-color: #2962ff;
  --current-price-text-color: #ffffff;
  --resizer-color: #cccccc;
  --resizer-hover-color: #aaaaaa;
  --header-height: auto;
  --resizer-height: 6px;
  --min-pane-height: 100px;
  --tab-button-hover-bg: rgba(0, 0, 0, 0.05);
  /* Volume Chart Vars */
  --volume-bar-opacity: 0.6;
  --sub-chart-height: 80px;
  --sub-chart-y-axis-width: 55px;
}

html[data-theme="dark"] {
  /* --bg-color is set by JS directly on body */
  --text-color: #e0e0e0;
  --subtle-text-color: #aaaaaa;
  --card-bg: #2a2a2a; /* Card background for specific elements */
  --border-color: #444444;
  --grid-color: #383838; /* Grid lines */
  --axis-label-bg: rgba(
    42,
    42,
    42,
    0.85
  ); /* Semi-transparent for text readability */
  --switch-bg: #555;
  --switch-slider: #ccc;
  --shadow-color: rgba(0, 0, 0, 0.4); /* Darker shadow on dark bg */
  --current-price-color: #448aff;
  --current-price-text-color: #ffffff;
  --resizer-color: #444444;
  --resizer-hover-color: #666666;
  --tab-button-hover-bg: rgba(255, 255, 255, 0.08);
}

/* --- Core Layout --- */
html,
body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  /* background-color is set by JavaScript in theme.js */
  color: var(--text-color);
  transition: color 0.3s ease;
}
.main-layout {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
  /* No background */
}

/* --- Header Area --- */
.header-area {
  flex-shrink: 0;
  padding: 5px 15px;
  border-bottom: 1px solid var(--border-color);
  background-color: transparent !important; /* Explicitly transparent */
  position: relative;
  z-index: 110;
  box-shadow: 0 1px 3px var(--shadow-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
  min-height: 50px;
  flex-wrap: wrap;
  gap: 10px;
}
/* ... (rest of header styles remain the same) ... */
.header-content {
  text-align: center;
  flex-grow: 1;
  min-width: 200px;
}
.header-area h1 {
  margin: 0 0 2px 0;
  font-size: 1.3em;
  font-weight: 600;
  line-height: 1.2;
}
.header-area p.instructions {
  margin: 0;
  font-size: 0.8em;
  color: var(--subtle-text-color);
  line-height: 1.2;
}
.header-controls {
  display: flex;
  align-items: center;
  gap: 15px;
  flex-shrink: 0;
}
.granularity-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: nowrap;
}
.granularity-controls span {
  margin-right: 5px;
  font-size: 0.85em;
  color: var(--subtle-text-color);
  white-space: nowrap;
}
.granularity-controls button {
  padding: 5px 10px;
  font-size: 0.85em;
  background-color: var(--card-bg);
  color: var(--subtle-text-color);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  transition: background-color 0.2s ease, color 0.2s ease,
    border-color 0.2s ease;
}
.granularity-controls button:hover {
  border-color: var(--text-color);
  color: var(--text-color);
}
.granularity-controls button.active {
  background-color: var(--switch-slider-checked);
  color: #ffffff;
  border-color: var(--switch-slider-checked);
  font-weight: 500;
}
.settings-group {
  position: relative;
}
.icon-button {
  background: none;
  border: 1px solid transparent;
  color: var(--subtle-text-color);
  font-size: 1.4em;
  padding: 4px 8px;
  cursor: pointer;
  border-radius: var(--border-radius-sm);
  line-height: 1;
  transition: color 0.2s ease, background-color 0.2s ease;
}
.icon-button:hover {
  color: var(--text-color);
  background-color: var(--tab-button-hover-bg);
}
.dropdown-menu {
  position: absolute;
  top: calc(100% + 5px);
  right: 0;
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-md);
  box-shadow: 0 3px 8px var(--shadow-color);
  padding: 10px 15px;
  min-width: 240px;
  z-index: 120;
  display: none;
  transition: background-color 0.3s ease, border-color 0.3s ease;
}
.dropdown-menu.show {
  display: block;
}
.dropdown-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
  border-bottom: 1px solid var(--grid-color);
  font-size: 0.9em;
  transition: border-color 0.3s ease;
}
.dropdown-item:last-child {
  border-bottom: none;
}
.dropdown-item span {
  margin-right: 15px;
  white-space: nowrap;
}
.dropdown-item .theme-switch-wrapper,
.dropdown-item .log-scale-switch-wrapper,
.dropdown-item .time-format-switch-wrapper {
  align-items: center;
}
.theme-switch {
  position: relative;
  display: inline-block;
  width: 44px;
  height: 24px;
}
.theme-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--switch-bg);
  transition: 0.4s;
  border-radius: 24px;
}
.slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: var(--switch-slider);
  transition: 0.4s;
  border-radius: 50%;
}
input:checked + .slider {
  background-color: var(--switch-slider-checked);
}
input:focus + .slider {
  box-shadow: 0 0 1px var(--switch-slider-checked);
}
input:checked + .slider:before {
  transform: translateX(20px);
}

/* --- Top-Left Info --- */
.top-left-info {
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 115;
  background-color: var(--axis-label-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  padding: 5px 8px;
  box-shadow: 0 1px 3px var(--shadow-color);
}
.status-indicator {
  font-size: 0.8em;
  color: var(--subtle-text-color);
  white-space: nowrap;
}
#api-status-indicator {
  font-weight: bold;
}
#api-status-indicator.loaded {
  color: var(--candle-up);
}
#api-status-indicator.error {
  color: var(--candle-down);
}
#api-status-indicator.loading {
  font-style: italic;
}

/* --- Content Area --- */
.content-area {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* --- Chart Pane --- */
.chart-pane {
  flex-grow: 1;
  flex-shrink: 1;
  overflow: hidden;
  position: relative;
  min-height: var(--min-pane-height);
  display: flex;
  flex-direction: column;
}

/* Main Candlestick Chart Container */
.chart-container {
  width: 100%;
  flex-grow: 1;
  border: none;
  padding: 10px 55px 40px 10px;
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
  cursor: grab;
  user-select: none;
  display: flex;
  min-height: 150px;
}
/* ... (rest of chart container styles) ... */
.chart-container.panning {
  cursor: grabbing;
}
.chart-wrapper {
  width: 100%;
  height: 100%;
  position: relative;
}
.chart-area {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  cursor: default;
  overflow: hidden;
}
.grid-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
}
.grid-line {
  position: absolute;
  background-color: var(--grid-color);
  transition: background-color 0.3s ease;
}
.grid-line.horizontal {
  width: 100%;
  height: 1px;
  left: 0;
}

/* --- Axis Label Areas --- */
.y-axis-labels,
.x-axis-labels {
  position: absolute;
  font-size: 11px;
  color: var(--subtle-text-color);
  z-index: 10;
  overflow: hidden;
  background-color: transparent; /* No background */
  border-color: var(--border-color);
  transition: border-color 0.3s ease, color 0.3s ease;
}
.y-axis-labels {
  top: 0;
  right: -55px;
  width: 55px;
  height: 100%;
  cursor: ns-resize;
  border-left: 1px solid var(--border-color);
  padding-left: 2px;
  box-sizing: border-box;
}
.x-axis-labels {
  bottom: -40px;
  left: 0;
  width: 100%;
  height: 40px;
  cursor: ew-resize;
  border-top: 1px solid var(--border-color);
  padding-top: 2px;
  box-sizing: border-box;
}

/* Individual Axis Labels (Text) */
.axis-label {
  position: absolute;
  padding: 1px 4px;
  white-space: nowrap;
  pointer-events: none;
  border-radius: var(--border-radius-sm);
  z-index: 11;
}
.y-axis-label {
  right: 5px;
  transform: translateY(-50%);
  background-color: var(--axis-label-bg);
  color: var(--text-color);
  transition: background-color 0.3s ease, color 0.3s ease;
}
.x-axis-label {
  top: 2px;
  transform: translateX(-50%);
  color: var(--subtle-text-color);
  background-color: transparent;
}
.x-axis-date-label {
  bottom: 2px;
  transform: translateX(-50%);
  color: var(--text-color);
  font-weight: 500;
  background-color: var(--axis-label-bg);
  padding: 1px 6px;
  z-index: 12;
  border: 1px solid var(--border-color);
  transition: background-color 0.3s ease, border-color 0.3s ease,
    color 0.3s ease;
}

/* ... (rest of chart styles) ... */
.day-separator-line {
  position: absolute;
  top: 0;
  height: 100%;
  width: 1px;
  border-left: 1px dashed var(--border-color);
  opacity: 0.6;
  pointer-events: none;
  z-index: 0;
}
.month-separator-line {
  border-left-style: solid;
  opacity: 0.8;
}
.year-separator-line {
  border-left-style: solid;
  border-left-width: 2px;
  opacity: 1;
}
.current-price-line {
  position: absolute;
  left: 0;
  width: 100%;
  height: 1px;
  background-color: var(--current-price-color);
  opacity: 0.75;
  pointer-events: none;
  z-index: 15;
  transition: top 0.1s linear;
}
.current-price-label {
  position: absolute;
  right: -55px;
  width: 53px;
  padding: 1px 4px;
  font-size: 11px;
  font-weight: 500;
  text-align: center;
  background-color: var(--current-price-color);
  color: var(--current-price-text-color);
  pointer-events: none;
  z-index: 20;
  border-radius: var(--border-radius-sm);
  box-sizing: border-box;
  transform: translateY(-50%);
  transition: top 0.1s linear;
  white-space: nowrap;
}
.crosshair-line-x {
  position: absolute;
  left: 0;
  right: 0;
  height: 1px;
  border-top: 1px dashed var(--subtle-text-color);
  pointer-events: none;
  z-index: 20;
  opacity: 0.7;
}
.crosshair-label-y {
  position: absolute;
  right: -55px;
  width: 53px;
  padding: 1px 4px;
  font-size: 11px;
  font-weight: 500;
  text-align: center;
  background-color: var(--subtle-text-color);
  color: var(--bg-color, #0f0f19);
  pointer-events: none;
  z-index: 21;
  border-radius: var(--border-radius-sm);
  box-sizing: border-box;
  transform: translateY(-50%);
  white-space: nowrap;
  transition: background-color 0.3s ease, color 0.3s ease;
}
.candle {
  position: absolute;
  box-sizing: border-box;
  z-index: 1;
}
.wick {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: 1px;
}
.body {
  position: absolute;
  width: 80%;
  left: 10%;
  box-sizing: border-box;
  border-radius: 1px;
}
.body.color-up {
  background-color: var(--candle-up);
}
.body.color-down {
  background-color: var(--candle-down);
}
.wick.color-up {
  background-color: var(--candle-up);
}
.wick.color-down {
  background-color: var(--candle-down);
}
#chart-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--subtle-text-color);
  font-style: italic;
  z-index: 25;
  background-color: var(--axis-label-bg);
  padding: 8px 15px;
  border-radius: var(--border-radius-sm);
  border: 1px solid var(--border-color);
  user-select: text !important;
  cursor: text;
  transition: background-color 0.3s ease, border-color 0.3s ease,
    color 0.3s ease;
}
.chart-tooltip {
  position: absolute;
  background-color: var(--axis-label-bg);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-md);
  padding: 8px 12px;
  font-size: 11px;
  line-height: 1.4;
  white-space: pre;
  pointer-events: none;
  box-shadow: 0 2px 5px var(--shadow-color);
  z-index: 100;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.15s ease-in-out, visibility 0s linear 0.15s;
}
.chart-tooltip.visible {
  opacity: 1;
  visibility: visible;
  transition: opacity 0.15s ease-in-out;
}
.chart-tooltip .date {
  font-weight: bold;
  margin-bottom: 4px;
  color: var(--text-color);
}
.chart-tooltip .label {
  color: var(--subtle-text-color);
  display: inline-block;
  min-width: 25px;
}
.chart-tooltip .value {
  font-weight: 500;
  font-family: monospace;
  margin-left: 5px;
}

/* --- UNCOMMENTED: Sub-Chart (Volume) Styles --- */
.sub-chart-container {
  width: 100%;
  height: var(--sub-chart-height);
  flex-shrink: 0; /* Prevent shrinking */
  margin-top: 5px; /* Space between main chart and volume */
  /* Adjust padding to align canvas correctly, considering axis width */
  padding: 0px var(--sub-chart-y-axis-width) 0px 10px;
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
  border-top: 1px solid var(--border-color); /* Separator line */
}

#volume-chart-canvas {
  display: block;
  position: absolute;
  top: 0;
  left: 10px; /* Match main chart's left padding */
  /* Calculate width based on container's padding/axis */
  width: calc(100% - 10px - var(--sub-chart-y-axis-width));
  height: 100%;
}

#volume-y-axis-labels {
  position: absolute;
  top: 0;
  right: 0; /* Position on the far right */
  width: calc(var(--sub-chart-y-axis-width) - 1px); /* Width minus border */
  height: 100%;
  font-size: 10px;
  color: var(--subtle-text-color);
  border-left: 1px solid var(--border-color);
  padding-left: 2px;
  box-sizing: border-box;
  overflow: hidden;
  pointer-events: none;
  background: transparent; /* Ensure no background */
}
#volume-y-axis-labels .axis-label.y-axis-label {
  background-color: var(--axis-label-bg); /* Semi-transparent for readability */
  color: var(--text-color); /* Use main text color */
  right: 4px;
}
/* --- END UNCOMMENTED --- */

/* --- Resizer Handle --- */
.resizer {
  flex-shrink: 0;
  height: var(--resizer-height);
  background-color: var(--resizer-color);
  cursor: row-resize;
  width: 100%;
  transition: background-color 0.2s ease;
  z-index: 50;
}
.resizer:hover {
  background-color: var(--resizer-hover-color);
}

/* --- Bottom Pane (Tab Container) --- */
.tab-container {
  flex-shrink: 0;
  overflow: hidden;
  border-top: 1px solid var(--border-color);
  box-shadow: 0 -1px 3px var(--shadow-color);
  z-index: 40;
  display: flex;
  flex-direction: column;
  min-height: var(--min-pane-height);
  transition: border-color 0.3s ease;
}
.tab-bar {
  display: flex;
  flex-shrink: 0;
  border-bottom: 1px solid var(--border-color);
  padding: 0 10px;
  background-color: transparent !important;
  transition: border-color 0.3s ease;
}
/* ... (rest of tab styles) ... */
.tab-button {
  padding: 8px 16px;
  font-size: 0.9em;
  font-weight: 500;
  color: var(--subtle-text-color);
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  cursor: pointer;
  transition: color 0.2s ease, border-bottom-color 0.2s ease,
    background-color 0.2s ease;
  margin-bottom: -1px;
  border-radius: var(--border-radius-sm) var(--border-radius-sm) 0 0;
}
.tab-button:hover {
  background-color: var(--tab-button-hover-bg);
  color: var(--text-color);
}
.tab-button.active {
  color: var(--switch-slider-checked);
  border-bottom-color: var(--switch-slider-checked);
  background-color: transparent;
}
.tab-content-area {
  flex-grow: 1;
  overflow: hidden;
  position: relative; /* No background */
}
.tab-content {
  display: none;
  width: 100%;
  height: 100%;
  overflow: auto;
  box-sizing: border-box;
}
.tab-content.active {
  display: block;
}
.pane-placeholder {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100%;
  color: var(--subtle-text-color);
  font-style: italic;
  padding: 10px;
}
.pane-placeholder p {
  margin-bottom: 5px;
}
.pane-placeholder.error {
  color: var(--candle-down);
  font-style: normal;
}
.pane-placeholder.error small {
  font-size: 0.9em;
  margin-top: 5px;
  max-width: 80%;
  text-align: center;
}

/* Prompt Tab Specific Styling */
#prompt-content {
  padding: 5px;
}
#prompt-textarea {
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  resize: none;
  background-color: var(--card-bg);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  padding: 8px;
  font-family: inherit;
  font-size: 0.9em;
  line-height: 1.4;
  outline: none;
  transition: background-color 0.3s ease, color 0.3s ease,
    border-color 0.3s ease;
}
#prompt-textarea:focus {
  border-color: var(--switch-slider-checked);
}

/* Positions/Balance Tab Content Styling */
#positions-content.active {
  padding: 0;
  display: flex;
  flex-direction: column;
}
#positions-content .balance-content {
  flex-grow: 1;
  display: flex;
  overflow: hidden;
  height: 100%;
}
#positions-content .balance-list {
  list-style: none;
  margin: 0;
  padding: 10px 15px;
  overflow-y: auto;
  flex-grow: 1;
  font-size: 0.85em;
}
.balance-list li {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  border-bottom: 1px solid var(--grid-color);
  transition: border-color 0.3s ease;
}
.balance-list li:last-child {
  border-bottom: none;
}
.balance-list li span {
  padding: 0 5px;
  white-space: nowrap;
}
.balance-list li .asset-code {
  font-weight: 600;
  min-width: 45px;
  flex-basis: 45px;
  flex-shrink: 0;
}
.balance-list li .asset-qty {
  text-align: right;
  flex-grow: 1;
  margin: 0 10px;
  font-family: monospace;
}
.balance-list li .asset-value {
  min-width: 90px;
  flex-basis: 90px;
  flex-shrink: 0;
  text-align: right;
  color: var(--subtle-text-color);
  font-family: monospace;
  transition: color 0.3s ease;
}
.balance-list li.loading,
.balance-list li.error,
.balance-list li.info {
  justify-content: center;
  color: var(--subtle-text-color);
  font-style: italic;
  border-bottom: none;
  padding: 10px 0;
}
.balance-list li.error {
  color: var(--candle-down);
  font-style: normal;
}
#positions-content .balance-total {
  flex-shrink: 0;
  width: 200px;
  padding: 10px 15px;
  border-left: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-end;
  font-size: 0.9em;
  transition: border-color 0.3s ease;
  background-color: transparent;
  border-color: var(--border-color);
}
.balance-total span:first-child {
  color: var(--subtle-text-color);
  margin-bottom: 5px;
  transition: color 0.3s ease;
}
#total-usd-value {
  font-size: 1.2em;
  font-weight: 600;
  font-family: monospace;
}
#total-usd-partial-notice {
  font-size: 0.8em;
  color: var(--subtle-text-color);
  font-style: italic;
  transition: color 0.3s ease;
}
.balance-list-dust-summary {
  cursor: pointer;
  color: var(--subtle-text-color);
  border-top: 1px dashed var(--grid-color);
}
.balance-list-dust-summary .asset-code {
  font-size: 0.9em;
  font-weight: 500;
}
.balance-list-dust-summary:hover {
  color: var(--text-color);
}
.balance-list-dust-item {
  display: none;
  opacity: 0.8;
  font-size: 0.95em;
}
ul#balance-list.dust-visible .balance-list-dust-item {
  display: flex;
}
ul#balance-list:not(.dust-visible) .balance-list-dust-item {
  display: none;
}

/* Orders Table Styling */
#open-orders-content {
  padding: 10px;
}
/* ... (rest of orders table styles) ... */
.orders-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85em;
}
.orders-table th,
.orders-table td {
  padding: 6px 8px;
  text-align: left;
  border-bottom: 1px solid var(--grid-color);
  white-space: nowrap;
}
.orders-table th {
  font-weight: 600;
  color: var(--subtle-text-color);
  border-bottom-width: 2px;
  border-bottom-color: var(--border-color);
}
.orders-table tbody tr:hover {
  background-color: var(--tab-button-hover-bg);
}
.orders-table td.side-buy {
  color: var(--candle-up);
  font-weight: 500;
}
.orders-table td.side-sell {
  color: var(--candle-down);
  font-weight: 500;
}
.orders-table th:nth-child(1),
.orders-table td:nth-child(1) {
  min-width: 110px;
}
.orders-table th:nth-child(5),
.orders-table td:nth-child(5),
.orders-table th:nth-child(6),
.orders-table td:nth-child(6),
.orders-table th:nth-child(7),
.orders-table td:nth-child(7) {
  text-align: right;
}
.orders-table td[class^="status-"] {
  font-style: italic;
  color: var(--subtle-text-color);
}
.orders-table td.status-open {
  color: var(--text-color);
  font-style: normal;
}
.orders-table td.status-pending {
  color: orange;
}
.orders-table td.status-filled {
  color: var(--candle-up);
}
.orders-table td.status-cancelled {
  text-decoration: line-through;
}

/* Body cursor change during resize */
body.resizing,
body.resizing * {
  cursor: row-resize !important;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

```
--- END FILE: style.css ---


--- START FILE: test_coinbase_sdk.py ---
```py
# test_coinbase_sdk.py

import os
import json
# Import the correct SDK client
from coinbase.rest import RESTClient
import time

# --- Configuration ---
CREDENTIALS_FILE_NAME = "cdp_api_key.json"  # Ensure this matches your file
CREDENTIALS_FOLDER = "credentials"

# --- Load Credentials ---
api_key_name = None
private_key_pem = None
credentials_loaded = False

try:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    credentials_path = os.path.join(
        script_dir, CREDENTIALS_FOLDER, CREDENTIALS_FILE_NAME)
    print(f"--- Loading Credentials from: {credentials_path} ---")

    if not os.path.exists(credentials_path):
        raise FileNotFoundError(f"File not found at {credentials_path}")

    with open(credentials_path, 'r') as f:
        credentials_data = json.load(f)

    # Use the keys as expected by RESTClient
    # 'name' from JSON goes to 'api_key'
    api_key_name = credentials_data.get('name')
    # 'privateKey' from JSON goes to 'api_secret'
    private_key_pem = credentials_data.get('privateKey')

    if not api_key_name or not private_key_pem:
        raise ValueError("Credentials file is missing 'name' or 'privateKey'.")

    print("Credentials successfully read from file.")
    print(f"  API Key Name (used as api_key): {api_key_name}")
    credentials_loaded = True

except Exception as e:
    print(f"!!! ERROR Loading Credentials: {e}")
    exit(1)


# --- Initialize SDK Client (Using coinbase-advanced-py/RESTClient) ---
rest_client = None  # Renamed variable for clarity
if credentials_loaded:
    try:
        print("\n--- Initializing coinbase.rest.RESTClient ---")
        # Initialize using the correct Client class and arguments
        rest_client = RESTClient(
            api_key=api_key_name,      # 'name' from JSON
            api_secret=private_key_pem  # PEM string from JSON
        )
        print("REST Client initialized successfully.")
    except Exception as e:
        print(f"!!! ERROR Initializing REST Client: {e}")
        import traceback
        traceback.print_exc()
        rest_client = None
else:
    print("Skipping client initialization as credentials failed to load.")


# --- Test API Call (List Accounts) ---
if rest_client:
    try:
        print("\n--- Attempting to List Accounts (client.get_accounts) ---")
        # Use the SDK's get_accounts method
        accounts_data = rest_client.get_accounts()

        # The documentation suggests get_accounts returns a dict directly
        # matching the API response structure, often including an 'accounts' list
        if isinstance(accounts_data, dict) and 'accounts' in accounts_data:
            account_list = accounts_data.get('accounts', [])
            print(f"SUCCESS: Fetched {len(account_list)} accounts.")
            print("--- Accounts Data ---")
            # Pretty print the JSON-like structure
            print(json.dumps(accounts_data, indent=2))

            # Specifically find and print USDT/USD balance if present
            usdt_balance = "Not Found"
            usd_balance = "Not Found"
            for acc in account_list:
                # Accessing values directly based on typical V3 structure
                currency = acc.get('currency')
                # Balances are usually nested under 'available_balance' or similar
                # Use available for trading? Or 'balance'? Check response!
                balance_info = acc.get('available_balance', {})
                value = balance_info.get('value', 'N/A')

                if currency == 'USDT':
                    usdt_balance = value
                elif currency == 'USD':
                    usd_balance = value

            print("\n--- Specific Balances ---")
            print(f"  USD Available Balance: {usd_balance}")
            print(f"  USDT Available Balance: {usdt_balance}")

        else:
            # If the structure is different, print the raw response
            print("SUCCESS: Received response (Unexpected structure?):")
            print(accounts_data)

    except Exception as e:
        print(f"\n!!! ERROR during API call (get_accounts): {e}")
        # Check if the error object has response details (common with requests-based errors)
        if hasattr(e, 'response') and e.response is not None:
            try:
                error_details = e.response.json()
                print("--- API Error Details ---")
                print(json.dumps(error_details, indent=2))
                if e.response.status_code == 401:
                    print(
                        "!!! NOTE: 401 Unauthorized - Check API Key Permissions on CDP Portal (need View/Read for accounts) or Clock Skew.")
            except:
                print(
                    f"--- API Raw Error Response Text (Status: {e.response.status_code}) ---")
                print(e.response.text)
        else:
            # Print general exception info if no response details attached
            import traceback
            traceback.print_exc()

else:
    print("\n--- Skipping API call as REST Client was not initialized. ---")

print("\n--- Test Script Finished ---")

```
--- END FILE: test_coinbase_sdk.py ---


--- START FILE: test_manual_jwt.py ---
```py
# test_manual_jwt.py

import os
import json
import http.client  # Use Python's built-in library
import time
import uuid

# Use PyJWT for JWT creation
import jwt
# Cryptography for loading the key
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_private_key
import datetime  # Need this for JWT timestamps

# --- Configuration ---
CREDENTIALS_FILE_NAME = "cdp_api_key.json"  # Ensure this matches
CREDENTIALS_FOLDER = "credentials"
API_HOST = "api.coinbase.com"  # Host for http.client
SERVICE_NAME = "retail_rest_api_proxy"  # Audience for JWT

# --- Load Credentials ---
api_key_name = None
private_key_pem = None
private_key_obj = None  # Store the loaded key object
credentials_loaded = False

try:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    credentials_path = os.path.join(
        script_dir, CREDENTIALS_FOLDER, CREDENTIALS_FILE_NAME)
    print(f"--- Loading Credentials from: {credentials_path} ---")

    if not os.path.exists(credentials_path):
        raise FileNotFoundError(f"File not found: {credentials_path}")

    with open(credentials_path, 'r') as f:
        credentials_data = json.load(f)
    api_key_name = credentials_data.get('name')
    private_key_pem = credentials_data.get('privateKey')
    if not api_key_name or not private_key_pem:
        raise ValueError("Missing 'name' or 'privateKey'")

    # Load the private key *object*
    try:
        private_key_obj = load_pem_private_key(
            private_key_pem.encode('utf-8'), password=None)
        print("Private key object loaded successfully.")
    except Exception as key_error:
        raise ValueError(f"Could not load key object: {key_error}")

    print("Credentials successfully read.")
    print(f"  API Key Name (kid): {api_key_name}")
    credentials_loaded = True

except Exception as e:
    print(f"!!! ERROR Loading Credentials: {e}")
    exit(1)


# --- Helper Function to Generate JWT ---
def generate_jwt_manual(method, request_path):
    """ Generates a JWT for Coinbase Cloud API authentication (Manual Version). """
    if not credentials_loaded or not private_key_obj:
        print("Error: Cannot generate JWT.")
        return None
    try:
        # e.g., "GET /api/v3/brokerage/accounts"
        uri = f"{method.upper()} {request_path}"
        payload = {
            'sub': api_key_name, 'iss': "coinbase-cloud",
            'nbf': datetime.datetime.now(tz=datetime.timezone.utc),
            'exp': datetime.datetime.now(tz=datetime.timezone.utc) + datetime.timedelta(minutes=2),
            'aud': [SERVICE_NAME], 'uri': uri
        }
        headers = {'alg': 'ES256', 'kid': api_key_name,
                   'nonce': uuid.uuid4().hex}
        token = jwt.encode(payload, private_key_obj,
                           algorithm="ES256", headers=headers)
        # Avoid printing full token
        print(f"--- Generated JWT (first 10 chars): {token[:10]}... ---")
        return token
    except Exception as e:
        print(f"Error generating JWT: {e}")
        return None


# --- Make the Authenticated API Call ---
if credentials_loaded:
    try:
        method = "GET"
        # Define the specific path WITH query parameters if needed
        request_path_with_query = "/api/v3/brokerage/accounts"  # Start with base path
        # Add query params like limit=1 ?
        # query_params = "?limit=1" # Optional: Add query parameters here
        # request_path_with_query += query_params

        print(
            f"\n--- Generating JWT for: {method} {request_path_with_query} ---")
        auth_token = generate_jwt_manual(method, request_path_with_query)

        if not auth_token:
            raise Exception("Failed to generate JWT token.")

        print(
            f"--- Making Request: {method} https://{API_HOST}{request_path_with_query} ---")
        conn = http.client.HTTPSConnection(API_HOST)

        # Prepare headers, including the generated JWT
        request_headers = {
            'Authorization': f'Bearer {auth_token}',  # Use JWT as Bearer token
            'Content-Type': 'application/json'  # Still needed even for GET
        }
        # Don't log token
        print(
            f"  Headers: {{'Authorization': 'Bearer ...', 'Content-Type': ...}}")

        # Make the request (payload is empty for GET)
        payload = ''
        conn.request(method, request_path_with_query, payload, request_headers)

        # Get and process the response
        res = conn.getresponse()
        status = res.status
        reason = res.reason
        print(f"\n--- Response Status: {status} {reason} ---")

        data = res.read()
        conn.close()  # Close the connection

        print("--- Response Body (Decoded) ---")
        response_body_str = data.decode("utf-8")
        print(response_body_str)

        # Try parsing JSON and extracting info
        if 200 <= status < 300:
            print("\n--- SUCCESS ---")
            try:
                response_json = json.loads(response_body_str)
                # Look for USD/USDT
                usd_balance = "Not Found"
                usdt_balance = "Not Found"
                for acc in response_json.get('accounts', []):
                    currency = acc.get('currency')
                    balance_info = acc.get('available_balance', {})
                    value = balance_info.get('value', 'N/A')
                    if currency == 'USD':
                        usd_balance = value
                    elif currency == 'USDT':
                        usdt_balance = value
                print(f"  USD Available: {usd_balance}")
                print(f"  USDT Available: {usdt_balance}")
            except json.JSONDecodeError:
                print("  (Could not parse response body as JSON)")
        else:
            print("\n--- FAILED ---")
            if status == 401:
                print(
                    "!!! NOTE: 401 Unauthorized - Check API Key Permissions or Clock Skew.")
            # Further error details are already printed in the body

    except Exception as e:
        print(f"\n!!! ERROR during API call: {e}")
        import traceback
        traceback.print_exc()

else:
    print("\n--- Skipping API call as credentials failed to load. ---")

print("\n--- Test Script Finished ---")

```
--- END FILE: test_manual_jwt.py ---


--- END ALL OTHER PROJECT FILES ---

