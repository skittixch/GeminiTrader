--- START FILE: README.md ---
```markdown
# GeminiTrader (Prototype)

A web-based, interactive candlestick chart displaying cryptocurrency data (initially BTC-USD) fetched from a local backend proxying the Coinbase API, with live updates via WebSocket. Built with plain HTML, CSS, and vanilla JavaScript modules.

## Features

*   **Interactive Chart:**
    *   Displays historical candlestick data (OHLCV).
    *   Pan the chart by clicking and dragging the main chart area.
    *   Zoom in/out using the mouse scroll wheel.
    *   Scale the Y-axis (price) by clicking and dragging the price scale vertically.
    *   Scale the X-axis (time) by clicking and dragging the time scale horizontally.
    *   Double-click anywhere on the chart to reset the view to a default zoom level centered on the clicked time.
*   **Live Data:**
    *   Connects to Coinbase WebSocket feed for real-time price updates.
    *   Displays the current ticker price as a line and label on the chart.
    *   Updates the closing price and high/low of the *latest* candle in real-time.
*   **Customization & UI:**
    *   Selectable Candlestick Granularity (5m, 15m, 1h, 6h, 1d).
    *   Logarithmic / Linear Y-axis scale toggle.
    *   Dark / Light theme toggle (respects system preference, saves choice).
    *   12-hour (AM/PM) / 24-hour time format toggle.
    *   Date rollover labels and vertical separator lines on the X-axis.
    *   Clean, minimal dashboard-like styling.
*   **Backend Proxy:**
    *   Simple Python Flask server (`server.py`) fetches historical data from the official Coinbase API, decoupling the frontend from direct API calls.

## Project Goals (Future)

*   [ ] Integrate basic trading features (e.g., placing market/limit orders - **requires authentication and careful security considerations**).
*   [ ] integrate LLM interface to determine trading opportunities and general strategy management.
*   [ ] Display additional data (e.g., volume bars, technical indicators).
*   [ ] Allow selection of different trading pairs (product IDs).


## Tech Stack

*   **Frontend:** HTML5, CSS3, Vanilla JavaScript (ES Modules)
*   **Backend:** Python, Flask, Flask-CORS, Requests
*   **Data Source:** Coinbase Exchange API (REST for historical, WebSocket for live ticker)

## Setup and Running

**Prerequisites:**

*   [Git](https://git-scm.com/)
*   [Python 3](https://www.python.org/) (including `pip`)
*   A modern web browser

**Instructions:**

1.  **Clone the Repository (if applicable):**
    ```bash
    git clone https://github.com/skittixch/GeminiTrader/tree/main.git
    cd GeminiTrader
    ```
    *(If you haven't cloned it yet)*

2.  **Navigate to Project Directory:**
    Open your terminal or command prompt and `cd` into the project's root folder (the one containing `index.html`, `server.py`, etc.).

3.  **Install Python Dependencies:**
    ```bash
    pip install Flask Flask-Cors requests
    ```
    *(Consider using a Python virtual environment: `python -m venv venv`, then activate it before installing)*

4.  **Run the Backend Server:**
    Open a terminal in the project directory and run:
    ```bash
    python server.py
    ```
    Leave this terminal running. You should see output indicating it's running on `http://0.0.0.0:5000/`.

5.  **Run the Frontend Server:**
    Open a *second* terminal in the *same* project directory and run Python's built-in HTTP server (or use VS Code's Live Server):
    ```bash
    python -m http.server 8000
    ```
    *(You can use a different port if 8000 is taken)*. Leave this terminal running.

6.  **Access the Chart:**
    Open your web browser and navigate to:
    ```
    http://localhost:8000
    ```
    *(Use the port number you specified for the frontend server)*.

The chart should load, fetch data from your local backend (which fetches from Coinbase), connect to the WebSocket, and display the live price.

## Code Structure

```
--- END FILE: README.md ---


--- START ALL OTHER PROJECT FILES ---

--- START FILE: chart.js ---
```js
// Encapsulate chart logic in an IIFE
(function () {
  "use strict"; // Enable strict mode

  // --- Theme Handling (Run this early) ---
  const themeToggle = document.getElementById("theme-checkbox");
  const userPrefersDark =
    window.matchMedia &&
    window.matchMedia("(prefers-color-scheme: dark)").matches;
  const currentTheme = localStorage.getItem("theme");
  let theme = "light"; // Default

  if (currentTheme) {
    theme = currentTheme;
  } else if (userPrefersDark) {
    theme = "dark";
  }

  document.documentElement.setAttribute("data-theme", theme);
  if (themeToggle && theme === "dark") {
    themeToggle.checked = true;
  }

  if (themeToggle) {
    themeToggle.addEventListener("change", function () {
      if (this.checked) {
        document.documentElement.setAttribute("data-theme", "dark");
        localStorage.setItem("theme", "dark");
      } else {
        document.documentElement.setAttribute("data-theme", "light");
        localStorage.setItem("theme", "light");
      }
      // Redrawing isn't strictly necessary as CSS handles colors, but uncomment if needed
      // requestAnimationFrame(redrawChart);
    });
  }

  window
    .matchMedia("(prefers-color-scheme: dark)")
    .addEventListener("change", (e) => {
      if (!localStorage.getItem("theme")) {
        const newTheme = e.matches ? "dark" : "light";
        document.documentElement.setAttribute("data-theme", newTheme);
        if (themeToggle) themeToggle.checked = newTheme === "dark";
      }
    });
  // --- End Theme Handling ---

  // --- DOM Elements ---
  const chartContainer = document.getElementById("chart-container");
  const chartWrapper = chartContainer?.querySelector(".chart-wrapper");
  const chartArea = document.getElementById("chart-area");
  const gridContainer = document.getElementById("grid-container");
  const yAxisLabelsContainer = document.getElementById("y-axis-labels");
  const xAxisLabelsContainer = document.getElementById("x-axis-labels");
  const chartMessage = document.getElementById("chart-message");

  if (
    !chartContainer ||
    !chartWrapper ||
    !chartArea ||
    !gridContainer ||
    !yAxisLabelsContainer ||
    !xAxisLabelsContainer ||
    !chartMessage
  ) {
    console.error("Chart initialization failed: DOM elements missing.");
    if (chartMessage)
      chartMessage.textContent = "Error: Chart elements missing!";
    return;
  }

  // --- Chart State ---
  let fullData = [];
  let visibleStartIndex = 0;
  let visibleEndIndex = 0;
  let minVisiblePrice = 0;
  let maxVisiblePrice = 1;
  let isPanning = false;
  let isDraggingYAxis = false;
  let isDraggingXAxis = false; // Scaling X
  let panStartX = 0;
  let panStartY = 0;
  let panStartVisibleIndex = 0;
  let panStartVisibleCount = 0;
  let panStartMinPrice = 0;
  let panStartMaxPrice = 0;
  let lastDrawTime = 0;

  // --- Constants ---
  const ZOOM_FACTOR_X = 0.1;
  const ZOOM_FACTOR_Y = 0.1;
  const MIN_VISIBLE_CANDLES = 5;
  const DEFAULT_RESET_CANDLE_COUNT = 100;
  const MIN_PRICE_RANGE_SPAN = 0.1;
  const Y_AXIS_PRICE_PADDING_FACTOR = 0.05;
  const Y_AXIS_DRAG_SENSITIVITY = 2.0;
  const X_AXIS_DRAG_SENSITIVITY = 2.0;
  const MOUSE_MOVE_THROTTLE = 16;
  const DEBOUNCE_DELAY = 100;

  // --- Utility Functions ---
  function calculateNiceStep(range, maxTicks) {
    if (range <= 0 || maxTicks <= 0) return 1;
    const roughStep = range / maxTicks;
    const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
    const residual = roughStep / magnitude;
    let niceStep;
    if (residual > 5) niceStep = 10 * magnitude;
    else if (residual > 2) niceStep = 5 * magnitude;
    else if (residual > 1) niceStep = 2 * magnitude;
    else niceStep = magnitude;
    return Math.max(niceStep, Number.EPSILON * 10);
  }

  function formatTimestamp(timestamp) {
    const date = new Date(timestamp * 1000);
    const hours = date.getHours().toString().padStart(2, "0");
    const minutes = date.getMinutes().toString().padStart(2, "0");
    return `${hours}:${minutes}`;
  }

  // --- Main Drawing Function ---
  function redrawChart() {
    if (!fullData || !chartArea.offsetHeight || !chartArea.offsetWidth) {
      return;
    }
    const chartHeight = chartArea.offsetHeight;
    const chartWidth = chartArea.offsetWidth;
    const priceRange = maxVisiblePrice - minVisiblePrice;
    const visibleCount = visibleEndIndex - visibleStartIndex;

    if (priceRange <= 0 || visibleCount <= 0) {
      chartArea.innerHTML = "";
      gridContainer.innerHTML = "";
      yAxisLabelsContainer.innerHTML = "";
      xAxisLabelsContainer.innerHTML = "";
      return;
    }

    chartArea.innerHTML = "";
    gridContainer.innerHTML = "";
    yAxisLabelsContainer.innerHTML = "";
    xAxisLabelsContainer.innerHTML = "";

    const scaleY = chartHeight / priceRange;
    const totalCandleWidthRatio = 0.85;
    const candleWidth = Math.max(
      1,
      (chartWidth / visibleCount) * totalCandleWidthRatio
    );
    const candleMargin = Math.max(
      0.5,
      ((chartWidth / visibleCount) * (1 - totalCandleWidthRatio)) / 2
    );
    const candleTotalWidth = candleWidth + candleMargin * 2;

    // Draw Gridlines and Axis Labels
    try {
      const yTickDensity = Math.max(3, Math.round(chartHeight / 40));
      const yTicks = calculateNiceStep(priceRange, yTickDensity);
      const firstYTick =
        yTicks > Number.EPSILON
          ? Math.ceil(minVisiblePrice / yTicks) * yTicks
          : minVisiblePrice;
      for (
        let price = firstYTick;
        price <= maxVisiblePrice + yTicks * 0.1;
        price += yTicks
      ) {
        if (yTicks <= Number.EPSILON || price > maxVisiblePrice + priceRange)
          break;
        const y = chartHeight - (price - minVisiblePrice) * scaleY;
        if (y >= -chartHeight && y <= chartHeight * 2) {
          const hLine = document.createElement("div");
          hLine.className = "grid-line horizontal";
          hLine.style.top = `${y.toFixed(1)}px`;
          gridContainer.appendChild(hLine);
          if (y >= -5 && y <= chartHeight + 5) {
            const yLabel = document.createElement("div");
            yLabel.className = "axis-label y-axis-label";
            yLabel.style.top = `${y.toFixed(1)}px`;
            const decimals =
              priceRange < 10 ? (price < 1 ? 4 : 2) : price < 100 ? 1 : 0;
            yLabel.textContent = price.toFixed(decimals);
            yAxisLabelsContainer.appendChild(yLabel);
          }
        }
        if (price + yTicks <= price) break;
      }

      const xTickDensity = Math.max(3, Math.round(chartWidth / 70));
      const xTicks = Math.max(1, calculateNiceStep(visibleCount, xTickDensity));
      for (let i = 0; i < visibleCount; i++) {
        const dataIndex = visibleStartIndex + i;
        if (dataIndex >= 0 && dataIndex < fullData.length) {
          const isTick = (i + Math.floor(xTicks / 4)) % xTicks === 0;
          if (i === 0 || isTick || (xTicks === 1 && i % 5 === 0)) {
            const candleData = fullData[dataIndex];
            if (!candleData) continue;
            const timestamp = candleData[0];
            const x = i * candleTotalWidth + candleTotalWidth / 2;
            if (x >= -candleTotalWidth && x <= chartWidth + candleTotalWidth) {
              const xLabel = document.createElement("div");
              xLabel.className = "axis-label x-axis-label";
              xLabel.style.left = `${x.toFixed(1)}px`;
              xLabel.textContent = formatTimestamp(timestamp);
              xAxisLabelsContainer.appendChild(xLabel);
            }
          }
        }
      }
    } catch (e) {
      console.error("Error drawing axes/grid:", e);
    }

    // Draw Candles
    try {
      for (let i = 0; i < visibleCount; i++) {
        const dataIndex = visibleStartIndex + i;
        if (dataIndex >= 0 && dataIndex < fullData.length) {
          const candle = fullData[dataIndex];
          if (!candle || candle.length < 5) continue;
          const [timestamp, open, high, low, close] = candle;
          const wickHighY = chartHeight - (high - minVisiblePrice) * scaleY;
          const wickLowY = chartHeight - (low - minVisiblePrice) * scaleY;
          const bodyTopY =
            chartHeight - (Math.max(open, close) - minVisiblePrice) * scaleY;
          const bodyBottomY =
            chartHeight - (Math.min(open, close) - minVisiblePrice) * scaleY;
          const wickHeight = Math.max(1, wickLowY - wickHighY);
          const bodyHeight = Math.max(1, bodyBottomY - bodyTopY);
          const isUp = close >= open;

          const candleElement = document.createElement("div");
          candleElement.className = "candle";
          candleElement.style.width = `${candleWidth}px`;
          candleElement.style.marginLeft = `${
            i === 0 ? candleMargin : candleMargin * 2
          }px`;

          const wickElement = document.createElement("div");
          wickElement.className = "wick";
          wickElement.style.top = `${wickHighY.toFixed(1)}px`;
          wickElement.style.height = `${wickHeight.toFixed(1)}px`;

          const bodyElement = document.createElement("div");
          bodyElement.className = `body ${isUp ? "color-up" : "color-down"}`; // CSS handles color via these classes
          bodyElement.style.top = `${bodyTopY.toFixed(1)}px`;
          bodyElement.style.height = `${bodyHeight.toFixed(1)}px`;

          candleElement.appendChild(wickElement);
          candleElement.appendChild(bodyElement);
          chartArea.appendChild(candleElement);
        }
      }
    } catch (e) {
      console.error("Error drawing candles:", e);
    }
  }

  // --- Event Handlers ---
  function handleZoom(event) {
    event.preventDefault();
    const chartRect = chartArea.getBoundingClientRect();
    const mouseX = event.clientX - chartRect.left;
    const mouseY = event.clientY - chartRect.top;
    const chartHeight = chartArea.offsetHeight;
    const chartWidth = chartArea.offsetWidth;
    if (!chartHeight || !chartWidth) return;

    const priceRange = maxVisiblePrice - minVisiblePrice;
    if (priceRange <= 0) return;

    // Y-Axis Zoom
    const priceAtCursor = maxVisiblePrice - (mouseY / chartHeight) * priceRange;
    const zoomAmountY =
      event.deltaY < 0 ? 1 - ZOOM_FACTOR_Y : 1 + ZOOM_FACTOR_Y;
    let newMinVisiblePrice =
      priceAtCursor - (priceAtCursor - minVisiblePrice) * zoomAmountY;
    let newMaxVisiblePrice =
      priceAtCursor + (maxVisiblePrice - priceAtCursor) * zoomAmountY;
    if (newMaxVisiblePrice - newMinVisiblePrice < MIN_PRICE_RANGE_SPAN) {
      const mid = (newMaxVisiblePrice + newMinVisiblePrice) / 2;
      newMinVisiblePrice = mid - MIN_PRICE_RANGE_SPAN / 2;
      newMaxVisiblePrice = mid + MIN_PRICE_RANGE_SPAN / 2;
    }

    // X-Axis Zoom
    const currentVisibleCount = visibleEndIndex - visibleStartIndex;
    if (currentVisibleCount <= 0) return;
    const indexAtCursor =
      visibleStartIndex + (mouseX / chartWidth) * currentVisibleCount;
    const zoomAmountX =
      event.deltaY < 0 ? 1 - ZOOM_FACTOR_X : 1 + ZOOM_FACTOR_X;
    let newVisibleCount = Math.round(currentVisibleCount * zoomAmountX);
    newVisibleCount = Math.max(
      MIN_VISIBLE_CANDLES,
      Math.min(newVisibleCount, fullData.length * 2)
    );
    let newStartIndex = Math.round(
      indexAtCursor - (mouseX / chartWidth) * newVisibleCount
    );
    let newEndIndex = newStartIndex + newVisibleCount;

    // No clamping for infinite scroll
    visibleStartIndex = newStartIndex;
    visibleEndIndex = newEndIndex;
    minVisiblePrice = newMinVisiblePrice;
    maxVisiblePrice = newMaxVisiblePrice;

    requestAnimationFrame(redrawChart);
  }

  function handleMouseDownChart(event) {
    isPanning = true;
    isDraggingYAxis = false;
    isDraggingXAxis = false;
    panStartX = event.clientX;
    panStartY = event.clientY;
    panStartVisibleIndex = visibleStartIndex;
    panStartMinPrice = minVisiblePrice;
    panStartMaxPrice = maxVisiblePrice;
    panStartVisibleCount = visibleEndIndex - visibleStartIndex;
    chartContainer.classList.add("panning");
  }

  function handleMouseDownYAxis(event) {
    event.stopPropagation();
    isDraggingYAxis = true;
    isPanning = false;
    isDraggingXAxis = false;
    panStartY = event.clientY;
    panStartMinPrice = minVisiblePrice;
    panStartMaxPrice = maxVisiblePrice;
  }

  function handleMouseDownXAxis(event) {
    event.stopPropagation();
    isDraggingXAxis = true;
    isPanning = false;
    isDraggingYAxis = false;
    panStartX = event.clientX;
    panStartVisibleIndex = visibleStartIndex;
    panStartVisibleCount = visibleEndIndex - visibleStartIndex;
  }

  function handleMouseMove(event) {
    if (!isPanning && !isDraggingYAxis && !isDraggingXAxis) return;

    const now = Date.now();
    if (now - lastDrawTime < MOUSE_MOVE_THROTTLE) return;

    let needsRedraw = false;

    if (isDraggingYAxis) {
      const deltaY = event.clientY - panStartY;
      const chartHeight = chartArea.offsetHeight;
      if (!chartHeight) return;
      const initialRange = panStartMaxPrice - panStartMinPrice;
      if (initialRange <= 0) return;
      const midPrice = (panStartMaxPrice + panStartMinPrice) / 2;
      const scaleFactor = Math.pow(
        2,
        (deltaY / chartHeight) * Y_AXIS_DRAG_SENSITIVITY
      );
      let newRange = initialRange * scaleFactor;
      newRange = Math.max(MIN_PRICE_RANGE_SPAN, newRange);
      const newMin = midPrice - newRange / 2;
      const newMax = midPrice + newRange / 2;
      if (
        Math.abs(newMin - minVisiblePrice) > 1e-9 ||
        Math.abs(newMax - maxVisiblePrice) > 1e-9
      ) {
        minVisiblePrice = newMin;
        maxVisiblePrice = newMax;
        needsRedraw = true;
      }
    } else if (isDraggingXAxis) {
      const deltaX = event.clientX - panStartX;
      const chartWidth = chartArea.offsetWidth;
      if (!chartWidth || panStartVisibleCount <= 0) return;
      const centerIndex = panStartVisibleIndex + panStartVisibleCount / 2;
      const scaleFactor = Math.pow(
        2,
        (deltaX / chartWidth) * X_AXIS_DRAG_SENSITIVITY
      );
      let newVisibleCount = Math.round(panStartVisibleCount * scaleFactor);
      newVisibleCount = Math.max(
        MIN_VISIBLE_CANDLES,
        Math.min(newVisibleCount, fullData.length * 2)
      );
      let newStartIndex = Math.round(centerIndex - newVisibleCount / 2);
      let newEndIndex = newStartIndex + newVisibleCount;

      if (
        newStartIndex !== visibleStartIndex ||
        newEndIndex !== visibleEndIndex
      ) {
        visibleStartIndex = newStartIndex;
        visibleEndIndex = newEndIndex;
        needsRedraw = true;
      }
    } else if (isPanning) {
      const deltaX = event.clientX - panStartX;
      const deltaY = event.clientY - panStartY;
      const chartHeight = chartArea.offsetHeight;
      const chartWidth = chartArea.offsetWidth;
      if (!chartWidth || !chartHeight) return;

      let changedX = false;
      let changedY = false;

      if (panStartVisibleCount > 0) {
        const indexDelta = (deltaX / chartWidth) * panStartVisibleCount;
        let newStartIndex = panStartVisibleIndex - Math.round(indexDelta);
        if (newStartIndex !== visibleStartIndex) {
          visibleStartIndex = newStartIndex;
          visibleEndIndex = newStartIndex + panStartVisibleCount;
          changedX = true;
        }
      }

      const initialPriceRange = panStartMaxPrice - panStartMinPrice;
      if (initialPriceRange > 0) {
        const priceDelta = (deltaY / chartHeight) * initialPriceRange;
        const newMinPrice = panStartMinPrice + priceDelta;
        const newMaxPrice = panStartMaxPrice + priceDelta;
        if (
          Math.abs(newMinPrice - minVisiblePrice) > 1e-9 ||
          Math.abs(newMaxPrice - maxVisiblePrice) > 1e-9
        ) {
          minVisiblePrice = newMinPrice;
          maxVisiblePrice = newMaxPrice;
          changedY = true;
        }
      }
      needsRedraw = changedX || changedY;
    }

    if (needsRedraw) {
      lastDrawTime = now;
      requestAnimationFrame(redrawChart);
    }
  }

  function handleMouseUpOrLeave(event) {
    if (isPanning || isDraggingYAxis || isDraggingXAxis) {
      isPanning = false;
      isDraggingYAxis = false;
      isDraggingXAxis = false;
      chartContainer.classList.remove("panning");
    }
  }

  let resizeTimeout;
  function handleResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      requestAnimationFrame(redrawChart);
    }, DEBOUNCE_DELAY);
  }

  function handleDoubleClick(event) {
    if (!fullData.length) return;
    const chartRect = chartArea.getBoundingClientRect();
    const mouseX = event.clientX - chartRect.left;
    const chartWidth = chartArea.offsetWidth;
    if (!chartWidth) return;

    const currentVisibleCount = visibleEndIndex - visibleStartIndex;
    const fractionalIndex =
      visibleStartIndex + (mouseX / chartWidth) * currentVisibleCount;
    let targetIndex = Math.round(fractionalIndex);
    targetIndex = Math.max(0, Math.min(targetIndex, fullData.length - 1));

    let newVisibleCount = Math.min(DEFAULT_RESET_CANDLE_COUNT, fullData.length);
    let newStartIndex = Math.round(targetIndex - newVisibleCount / 2);
    newStartIndex = Math.max(
      0,
      Math.min(newStartIndex, fullData.length - newVisibleCount)
    );
    let newEndIndex = Math.min(
      fullData.length,
      newStartIndex + newVisibleCount
    );
    newStartIndex = Math.max(0, newEndIndex - newVisibleCount);

    let newMin = Infinity,
      newMax = -Infinity;
    for (let i = newStartIndex; i < newEndIndex; i++) {
      if (!fullData[i] || fullData[i].length < 4) continue;
      newMin = Math.min(newMin, fullData[i][3]);
      newMax = Math.max(newMax, fullData[i][2]);
    }
    if (newMin === Infinity) {
      newMin = 0;
      newMax = 1;
    }

    const padding = Math.max(
      MIN_PRICE_RANGE_SPAN * 0.1,
      (newMax - newMin) * Y_AXIS_PRICE_PADDING_FACTOR
    );
    let newMinPrice = Math.max(0, newMin - padding);
    let newMaxPrice = newMax + padding;
    if (newMaxPrice - newMinPrice < MIN_PRICE_RANGE_SPAN) {
      const mid = (newMaxPrice + newMinPrice) / 2;
      newMinPrice = mid - MIN_PRICE_RANGE_SPAN / 2;
      newMaxPrice = mid + MIN_PRICE_RANGE_SPAN / 2;
    }

    visibleStartIndex = newStartIndex;
    visibleEndIndex = newEndIndex;
    minVisiblePrice = newMinPrice;
    maxVisiblePrice = newMaxPrice;

    requestAnimationFrame(redrawChart);
  }

  // --- Initialization ---
  function initializeChart(data) {
    fullData = data;
    if (!fullData.length) {
      chartMessage.textContent = "No data loaded.";
      chartMessage.style.display = "block";
      return;
    }
    const initialVisibleCount = Math.min(
      DEFAULT_RESET_CANDLE_COUNT,
      fullData.length
    );
    visibleStartIndex = Math.max(0, fullData.length - initialVisibleCount);
    visibleEndIndex = fullData.length;

    let initialMin = Infinity,
      initialMax = -Infinity;
    for (let i = visibleStartIndex; i < visibleEndIndex; i++) {
      if (!fullData[i] || fullData[i].length < 4) continue;
      initialMin = Math.min(initialMin, fullData[i][3]);
      initialMax = Math.max(initialMax, fullData[i][2]);
    }
    if (initialMin === Infinity) {
      initialMin = 0;
      initialMax = 1;
    }
    const padding = Math.max(
      MIN_PRICE_RANGE_SPAN * 0.1,
      (initialMax - initialMin) * Y_AXIS_PRICE_PADDING_FACTOR
    );
    minVisiblePrice = Math.max(0, initialMin - padding);
    maxVisiblePrice = initialMax + padding;
    if (maxVisiblePrice - minVisiblePrice < MIN_PRICE_RANGE_SPAN) {
      const mid = (maxVisiblePrice + minVisiblePrice) / 2;
      minVisiblePrice = mid - MIN_PRICE_RANGE_SPAN / 2;
      maxVisiblePrice = mid + MIN_PRICE_RANGE_SPAN / 2;
    }

    chartContainer.addEventListener("wheel", handleZoom, { passive: false });
    chartContainer.addEventListener("mousedown", handleMouseDownChart);
    yAxisLabelsContainer.addEventListener("mousedown", handleMouseDownYAxis);
    xAxisLabelsContainer.addEventListener("mousedown", handleMouseDownXAxis);
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUpOrLeave);
    window.addEventListener("resize", handleResize);
    chartContainer.addEventListener("dblclick", handleDoubleClick);

    chartMessage.style.display = "none";
    requestAnimationFrame(redrawChart);
  }

  // --- Data Fetching and Startup ---
  document.addEventListener("DOMContentLoaded", () => {
    fetch("btc_data.json")
      .then((response) => {
        if (!response.ok) {
          throw new Error(
            `HTTP error ${response.status} (${response.statusText}) loading btc_data.json`
          );
        }
        return response.json();
      })
      .then((data) => {
        if (Array.isArray(data)) {
          console.log(`Loaded ${data.length} data points.`);
          initializeChart(data.slice().reverse());
        } else {
          throw new Error("Loaded data is not an array.");
        }
      })
      .catch((error) => {
        console.error("Chart Error:", error);
        chartMessage.textContent = `Error: ${error.message}. Check console & network tab. Ensure using web server.`;
        chartMessage.style.display = "block";
      });
  });
})(); // End IIFE

```
--- END FILE: chart.js ---


--- START FILE: create_context.sh ---
```sh
#!/bin/bash

# --- Configuration ---
OUTPUT_FILE="GeminiTrader.txt"
README_FILE="README.md" # Define the README filename

# File extensions/names to include
INCLUDE_PATTERNS='\.py$|\.js$|\.jsx$|\.ts$|\.tsx$|\.html$|\.css$|\.scss$|\.md$|\.json$|\.yaml$|\.yml$|\.txt$|\.sh$|Dockerfile|Makefile'

# Directory/file patterns to exclude (uses grep -E syntax)
# Add README_FILE to the base exclusion for the main loop later
BASE_EXCLUDE_PATTERNS='/\.git/|/node_modules/|/dist/|/build/|/venv/|/\.venv/|/__pycache__/|/\.vscode/|/\.idea/|/coverage/|/\.DS_Store|^./'"${OUTPUT_FILE}"'$'

# --- Script ---
echo "Creating context file with readme and code blocks: $OUTPUT_FILE" # Updated message
# Clear the output file
> "$OUTPUT_FILE"

# --- 1. README File --- (Moved to be the first section)
if [ -f "$README_FILE" ]; then
    echo "Processing: $README_FILE (as introduction)"
    echo "--- START FILE: $README_FILE ---" >> "$OUTPUT_FILE"
    echo "\`\`\`markdown" >> "$OUTPUT_FILE"
    cat "$README_FILE" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE" # Ensure newline before fence
    echo "\`\`\`" >> "$OUTPUT_FILE"
    echo "--- END FILE: $README_FILE ---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
else
    echo "[ $README_FILE not found in project root, starting with other files. ]" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
fi

# --- 2. Individual Files --- (Renumbered section)
echo "--- START ALL OTHER PROJECT FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

# Add README_FILE to exclusions for the main find command
# Use printf for safer path construction if README_FILE had special chars
EXCLUDE_PATTERNS_FOR_FIND="${BASE_EXCLUDE_PATTERNS}"
printf -v readme_pattern '|^./%s$' "$README_FILE"
EXCLUDE_PATTERNS_FOR_FIND+="${readme_pattern}"

# Find all files, filter out excluded patterns, filter for included patterns
find . -type f -print0 | grep -zEv "$EXCLUDE_PATTERNS_FOR_FIND" | grep -zE "$INCLUDE_PATTERNS" | while IFS= read -r -d $'\0' file; do
    # Clean file path for display (remove leading ./)
    display_file="${file#./}"
    echo "Processing: $display_file"

    # --- Determine Language Hint ---
    ext_raw="${file##*.}"
    base_name=$(basename "$file")
    lang_hint="text"
    if [[ "$ext_raw" != "$base_name" ]] && [[ ! -z "$ext_raw" ]]; then
        lang_hint=$(echo "$ext_raw" | tr '[:upper:]' '[:lower:]')
        case "$lang_hint" in
            "mjs"|"jsx") lang_hint="javascript" ;;
            "tsx") lang_hint="typescript" ;;
            "yml") lang_hint="yaml" ;;
            # Add other specific mappings
        esac
    else
        case "$base_name" in
            "Dockerfile") lang_hint="dockerfile" ;;
            "Makefile") lang_hint="makefile" ;;
        esac
        if [[ "$lang_hint" == "text" ]] && [[ "$base_name" == .* ]]; then
            case "$base_name" in
                ".bashrc"|".profile") lang_hint="bash" ;;
                ".gitignore") lang_hint="gitignore" ;;
                ".env") lang_hint="dotenv" ;;
                # Add more hidden file types
            esac
        fi
    fi

    # --- Append to Output File ---
    echo "--- START FILE: $display_file ---" >> "$OUTPUT_FILE"
    echo "\`\`\`${lang_hint}" >> "$OUTPUT_FILE"
    cat "$file" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE" # Ensure newline before fence
    echo "\`\`\`" >> "$OUTPUT_FILE"
    echo "--- END FILE: $display_file ---" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"
    echo "" >> "$OUTPUT_FILE"

done

echo "--- END ALL OTHER PROJECT FILES ---" >> "$OUTPUT_FILE"
echo "" >> "$OUTPUT_FILE"

echo "Finished creating $OUTPUT_FILE"
```
--- END FILE: create_context.sh ---


--- START FILE: credentials/cdp_api_key.json ---
```json
{
   "name": "organizations/be8ab444-9ab3-40f7-ae48-5cac5ea99bf7/apiKeys/384cfa64-a2de-4c9f-ac83-4aa59e394e89",
   "privateKey": "-----BEGIN EC PRIVATE KEY-----\nMHcCAQEEICuKcV0qXSCOIXObz6jaMCjP+T+QxbHR8GS8uW6qSQeRoAoGCCqGSM49\nAwEHoUQDQgAEOCSdUfcZksYetcpjP9rmjOR5ighwLO309cWchcxnPZ99vo+U51fX\nF3T+N4snZD/14Yhr2RRVwEykKVA+ygmJFQ==\n-----END EC PRIVATE KEY-----\n"
}
```
--- END FILE: credentials/cdp_api_key.json ---


--- START FILE: credentials/cdp_api_key_example.json ---
```json
{
   "name": "organizations/XXXXXXXXXXXXXXXXXXXXXXXX",
   "privateKey": "-----BEGIN EC PRIVATE KEY-----\nXXXXXXXXXXXXXXXXXXXXXXXX\n-----END EC PRIVATE KEY-----\n"
}
```
--- END FILE: credentials/cdp_api_key_example.json ---


--- START FILE: get_context.py ---
```py
import os
import fnmatch
import sys

# --- Configuration ---
# Add directories or file patterns to exclude
# Uses Unix shell-style wildcards (fnmatch)
EXCLUDE_DIRS = {
    ".git",
    "node_modules",
    "dist",
    "build",
    "venv",
    "__pycache__",
    ".vscode",
    ".idea",
    # Add any other directories you want to skip entirely
}
EXCLUDE_FILES = {
    "*.pyc",
    "*.log",
    "*.lock",
    "*.exe", "*.dll", "*.bin", "*.obj", "*.o", "*.so",  # Binaries
    "*.png", "*.jpg", "*.jpeg", "*.gif", "*.svg", "*.ico", "*.webp",  # Images
    "*.zip", "*.tar.gz", "*.rar", "*.7z", "*.jar",  # Archives
    "*.pdf", "*.doc", "*.docx", "*.xls", "*.xlsx", "*.ppt", "*.pptx",  # Documents
    "project_context.txt",  # Exclude the output file itself
    # Add any other file patterns
}

# Mapping file extensions to Markdown language hints
# Add more as needed
LANG_HINTS = {
    "py": "python",
    "js": "javascript",
    "ts": "typescript",
    "cs": "csharp",
    "html": "html",
    "css": "css",
    "scss": "scss",
    "json": "json",
    "md": "markdown",
    "sh": "bash",
    "ps1": "powershell",
    "yaml": "yaml",
    "yml": "yaml",
    "sql": "sql",
    "dockerfile": "dockerfile",
    "txt": "text",
}
# --- End Configuration ---


def get_lang_hint(filename):
    """Gets the markdown language hint based on file extension."""
    _, ext = os.path.splitext(filename)
    return LANG_HINTS.get(ext.lower().lstrip('.'), ext.lstrip('.'))


def should_exclude(path, is_dir):
    """Checks if a file or directory should be excluded."""
    name = os.path.basename(path)
    patterns = EXCLUDE_DIRS if is_dir else EXCLUDE_FILES
    if name in patterns:
        return True
    for pattern in patterns:
        if fnmatch.fnmatch(name, pattern):
            return True
    return False


def print_tree(start_path):
    """Prints a basic directory tree structure."""
    print("Project Directory Tree:")
    print("=======================")
    for root, dirs, files in os.walk(start_path, topdown=True):
        # Filter excluded directories *before* descending into them
        dirs[:] = [d for d in dirs if not should_exclude(
            os.path.join(root, d), True)]

        level = root.replace(start_path, '').count(os.sep)
        indent = ' ' * 4 * level
        print(f"{indent}{os.path.basename(root)}/")

        sub_indent = ' ' * 4 * (level + 1)
        for f in files:
            file_path = os.path.join(root, f)
            if not should_exclude(file_path, False):
                print(f"{sub_indent}{f}")
    print("\n")  # Add a newline


def process_files(start_path):
    """Processes and prints the content of non-excluded files."""
    print("File Contents:")
    print("==============")
    print("")  # Add a newline

    for root, dirs, files in os.walk(start_path, topdown=True):
        # Filter excluded directories again (important for the files loop)
        dirs[:] = [d for d in dirs if not should_exclude(
            os.path.join(root, d), True)]

        for filename in files:
            file_path = os.path.join(root, filename)
            relative_path = os.path.relpath(file_path, start_path)

            if should_exclude(file_path, False):
                continue

            lang_hint = get_lang_hint(filename)

            # Use forward slashes for consistency
            print(f"--- File: {relative_path.replace(os.sep, '/')} ---")
            print(f"```{lang_hint}")
            try:
                # Try reading with UTF-8, fallback to latin-1 if needed
                # Add other encodings if necessary for your project
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
            except UnicodeDecodeError:
                try:
                    with open(file_path, 'r', encoding='latin-1') as f:
                        content = f.read()
                except Exception as e:
                    content = f"[Error reading file: {e}]"
            except Exception as e:
                content = f"[Error reading file: {e}]"

            print(content)
            print("```")
            print("")  # Add a blank line for separation


# --- Main Execution ---
if __name__ == "__main__":
    project_root = os.getcwd()  # Get current working directory
    print_tree(project_root)
    process_files(project_root)
    print("=======================")
    print("--- End of Output ---")
# --- End of Script ---

```
--- END FILE: get_context.py ---


--- START FILE: index.html ---
```html
<!DOCTYPE html>
<html lang="en"> <!-- data-theme attribute will be set by JS -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive BTC Candlestick Chart</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="main-layout">

        <!-- Header Area -->
        <div class="header-area">
            <div class="top-left-info">
                <div class="status-indicator">
                    API Status: <span id="api-status-indicator">Checking...</span>
                </div>
            </div>
            <div class="header-content">
                <h1>Interactive BTC/USD Candlestick Chart</h1>
                <p class="instructions">Scroll=Zoom | Drag Chart=Pan | Drag Axes=Scale | Dbl-Click=Reset | Hover=Info/Crosshair</p>
            </div>
            <div class="header-controls">
                <div class="granularity-controls" id="granularity-controls">
                    <span>Interval:</span>
                    <button data-granularity="300">5m</button>
                    <button data-granularity="900">15m</button>
                    <button data-granularity="3600" class="active">1h</button>
                    <button data-granularity="21600">6h</button>
                    <button data-granularity="86400">1d</button>
                </div>
                <div class="settings-group">
                    <button id="settings-button" class="icon-button" title="Chart Settings">⚙️</button>
                    <div id="settings-dropdown" class="dropdown-menu">
                        <div class="dropdown-item">
                            <span>Dark Theme</span>
                            <div class="theme-switch-wrapper">
                                <label class="theme-switch" for="theme-checkbox">
                                    <input type="checkbox" id="theme-checkbox" />
                                    <div class="slider"></div>
                                </label>
                            </div>
                        </div>
                        <div class="dropdown-item">
                             <span>Log Scale (Y-Axis)</span>
                            <div class="log-scale-switch-wrapper">
                                <label class="theme-switch" for="log-scale-checkbox">
                                    <input type="checkbox" id="log-scale-checkbox" />
                                    <div class="slider"></div>
                                </label>
                            </div>
                        </div>
                        <div class="dropdown-item">
                             <span>12-Hour Time (AM/PM)</span>
                            <div class="time-format-switch-wrapper">
                                <label class="theme-switch" for="time-format-checkbox">
                                    <input type="checkbox" id="time-format-checkbox" />
                                    <div class="slider"></div>
                                </label>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <!-- Content Area -->
        <div class="content-area" id="content-area">

            <!-- Top Pane (Chart Only) -->
            <div class="chart-pane" id="chart-pane">
                 <!-- Main Candlestick Chart Container -->
                <div class="chart-container" id="chart-container">
                    <div class="chart-wrapper">
                        <div class="grid-container" id="grid-container"></div>
                        <div class="chart-area" id="chart-area"></div>
                        <div class="y-axis-labels" id="y-axis-labels"></div>
                        <div class="x-axis-labels" id="x-axis-labels"></div>
                        <div class="current-price-line" id="current-price-line" style="display: none;"></div>
                        <div class="current-price-label" id="current-price-label" style="display: none;">-</div>
                        <div class="crosshair-line-x" id="crosshair-line-x" style="display: none;"></div>
                        <div class="crosshair-label-y" id="crosshair-label-y" style="display: none;">-</div>
                        <div class="chart-tooltip" id="chart-tooltip" style="display: none; opacity: 0;"></div>
                    </div>
                    <div id="chart-message">Loading data...</div>
                </div>
                <!-- Sub-chart container removed -->
            </div>

            <!-- Resizer Handle -->
            <div class="resizer" id="resizer"></div>

            <!-- Bottom Pane (Tabbed Interface) -->
            <div class="tab-container" id="bottom-pane">
                <div class="tab-bar" id="bottom-tab-bar">
                    <button class="tab-button active" data-target="positions-content">Positions</button>
                    <button class="tab-button" data-target="open-orders-content">Open Orders</button>
                    <button class="tab-button" data-target="order-history-content">Order History</button>
                    <button class="tab-button" data-target="prompt-content">Prompt</button>
                </div>
                <div class="tab-content-area">
                    <div id="positions-content" class="tab-content active">
                        <div class="balance-content">
                             <ul class="balance-list" id="balance-list">
                                 <li class="loading">Loading balances...</li>
                             </ul>
                             <div class="balance-total" id="balance-total">
                                 <span>Approx. Total (USD):</span>
                                 <span id="total-usd-value">--.--</span>
                                 <small id="total-usd-partial-notice" style="display: none;"> (Partial)</small>
                             </div>
                        </div>
                    </div>
                    <div id="open-orders-content" class="tab-content">
                        <div class="pane-placeholder">
                            <p>Open Orders will be displayed here.</p>
                            <small>(Requires backend implementation)</small>
                        </div>
                    </div>
                    <div id="order-history-content" class="tab-content">
                         <div class="pane-placeholder">
                             <p>Order History will be displayed here.</p>
                             <small>(Requires backend implementation)</small>
                         </div>
                    </div>
                    <div id="prompt-content" class="tab-content">
                         <textarea id="prompt-textarea" placeholder="Enter your strategy prompt or notes here..."></textarea>
                    </div>
                </div>
            </div>

        </div>

    </div>

    <script type="module" src="js/main.js" defer></script>

</body>
</html>
```
--- END FILE: index.html ---


--- START FILE: js/balance.js ---
```js
// js/balance.js

import * as dom from "./domElements.js";
import { formatCurrency, formatQuantity } from "./utils.js";
import { BALANCE_DUST_THRESHOLD_USD } from "./config.js"; // Import threshold
import state, { updateLatestPrice } from "./state.js"; // Import state and price update function

const DUST_SUMMARY_CLASS = "balance-list-dust-summary";
const DUST_ITEM_CLASS = "balance-list-dust-item";
const DUST_VISIBLE_CLASS = "dust-visible"; // Class added to UL when dust is shown

/**
 * Fetches the current ticker price for a single product ID from the backend.
 * @param {string} productId (e.g., "ETH-USD")
 * @returns {Promise<number|null>} Resolves with the price number or null.
 */
async function fetchTickerPrice(productId) {
  if (!productId) return null;
  const url = `http://localhost:5000/api/ticker?product_id=${productId}`;
  try {
    const response = await fetch(url);
    if (!response.ok) {
      console.warn(
        `Ticker fetch failed for ${productId}: ${response.status} ${response.statusText}`
      );
      try {
        const errorData = await response.json();
        console.warn(
          ` -> API Error: ${errorData?.message || response.statusText}`
        );
      } catch {}
      return null;
    }
    const data = await response.json();
    const price = parseFloat(data?.price);
    return !isNaN(price) ? price : null;
  } catch (error) {
    console.error(`Network error fetching ticker for ${productId}:`, error);
    return null;
  }
}

/**
 * Renders a single balance list item.
 * Stores currency and quantity in data attributes for later updates.
 * @param {object} acc - The processed account object (with totalBalance, usdValue).
 * @param {boolean} isDustItem - Flag to add the dust item class.
 */
function renderBalanceItem(acc, isDustItem = false) {
  const { currency, totalBalance, usdValue } = acc;

  const li = document.createElement("li");
  // Store currency and quantity for easy access during live updates
  li.dataset.currency = currency;
  li.dataset.quantity = totalBalance.toString(); // Store as string
  if (isDustItem) {
    li.classList.add(DUST_ITEM_CLASS);
  }

  const codeSpan = document.createElement("span");
  codeSpan.className = "asset-code";
  codeSpan.textContent = currency;

  const qtySpan = document.createElement("span");
  qtySpan.className = "asset-qty";
  qtySpan.textContent = formatQuantity(totalBalance);

  const valueSpan = document.createElement("span");
  valueSpan.className = "asset-value";
  if (usdValue !== null && Number.isFinite(usdValue)) {
    // Check finiteness
    valueSpan.textContent = formatCurrency(usdValue);
  } else {
    valueSpan.textContent = `(?.?? USD)`;
  }

  li.appendChild(codeSpan);
  li.appendChild(qtySpan);
  li.appendChild(valueSpan);
  dom.balanceList.appendChild(li);
}

/**
 * Updates the balance pane HTML with fetched account data and prices.
 * Partitions into Main/Dust, sorts, and renders with collapsible dust section.
 * @param {Array} accounts - Array of account objects from the API.
 * @param {Map<string, number>} prices - Map of currency codes (UPPERCASE) to their initial USD prices.
 */
function updateBalancePaneUI(accounts, prices) {
  if (!dom.balanceList || !dom.balanceTotalValue || !dom.balancePartialNotice) {
    console.error("Balance pane DOM elements not found for UI update.");
    return;
  }
  dom.balanceList.innerHTML = ""; // Clear previous list items
  dom.balanceList.classList.remove(DUST_VISIBLE_CLASS);
  let totalUsdValue = 0;
  let partialTotal = false;

  if (!Array.isArray(accounts)) {
    dom.balanceList.innerHTML =
      '<li class="error">Invalid account data structure received.</li>';
    console.error("updateBalancePaneUI expected an array, got:", accounts);
    accounts = [];
  }

  const ZERO_THRESHOLD = 1e-9;
  const mainBalances = [];
  const dustBalances = [];

  // 1. Map accounts, calculate values, and partition into main/dust
  accounts.forEach((acc) => {
    const currency = acc?.currency?.toUpperCase();
    const availableString = acc?.available_balance?.value ?? "0";
    const holdString = acc?.hold?.value ?? "0";
    const availableBalance = parseFloat(availableString);
    const holdBalance = parseFloat(holdString);

    if (!currency || isNaN(availableBalance) || isNaN(holdBalance)) {
      return; // Skip invalid account data
    }

    const totalBalance = availableBalance + holdBalance;

    if (Math.abs(totalBalance) < ZERO_THRESHOLD) {
      return; // Skip zero balance
    }

    let usdValue = null;
    if (currency === "USD") {
      usdValue = totalBalance;
    } else if (currency === "USDT" || currency === "USDC") {
      usdValue = totalBalance * 1.0;
    } else {
      const price = prices.get(currency); // Use initial prices map here
      if (price !== undefined && price !== null && Number.isFinite(price)) {
        usdValue = totalBalance * price;
      } else {
        partialTotal = true;
      }
    }

    // Accumulate total value (do this *before* partitioning)
    if (usdValue !== null && Number.isFinite(usdValue)) {
      totalUsdValue += usdValue;
    }

    const processedAcc = {
      ...acc,
      currency,
      totalBalance,
      usdValue, // Initial USD value
    };

    // Partition based on USD value
    if (
      usdValue !== null &&
      Number.isFinite(usdValue) &&
      usdValue < BALANCE_DUST_THRESHOLD_USD
    ) {
      dustBalances.push(processedAcc);
    } else {
      mainBalances.push(processedAcc);
    }
  });

  // 2. Sort the main balances
  mainBalances.sort((a, b) => {
    if (a.currency === "USD") return -1;
    if (b.currency === "USD") return 1;
    const valueA = a.usdValue ?? -Infinity;
    const valueB = b.usdValue ?? -Infinity;
    if (valueB !== valueA) return valueB - valueA; // Desc value
    return (a.currency || "").localeCompare(b.currency || ""); // Asc currency
  });

  // 3. Sort the dust balances
  dustBalances.sort((a, b) => {
    return (a.currency || "").localeCompare(b.currency || ""); // Asc currency
  });

  // 4. Render Main Balances
  mainBalances.forEach((acc) => renderBalanceItem(acc, false));

  // 5. Render Dust Section
  if (dustBalances.length > 0) {
    const dustLi = document.createElement("li");
    dustLi.classList.add(DUST_SUMMARY_CLASS);
    dustLi.innerHTML = `
          <span class="asset-code">Dust</span>
          <span class="asset-qty">(${dustBalances.length} items)</span>
          <span class="asset-value">(click to show)</span> <!-- Initial text -->
      `;
    dom.balanceList.appendChild(dustLi);
    dustBalances.forEach((acc) => renderBalanceItem(acc, true));
  }

  // --- Final UI Updates ---
  if (dom.balanceList.children.length === 0) {
    dom.balanceList.innerHTML = '<li class="info">No balances found.</li>';
  } else if (mainBalances.length === 0 && dustBalances.length === 0) {
    dom.balanceList.innerHTML =
      '<li class="info">No non-zero balances found.</li>';
  }

  dom.balanceTotalValue.textContent = formatCurrency(totalUsdValue);
  dom.balancePartialNotice.style.display = partialTotal ? "inline" : "none";
}

/**
 * Updates ONLY the USD values and total in the already rendered balance list.
 * Reads quantities and currencies from data attributes.
 * Uses latest prices from the global state.
 */
export function updateBalanceValuesUI() {
  if (!dom.balanceList || !dom.balanceTotalValue || !dom.balancePartialNotice) {
    // console.warn("Cannot update balance values: UI elements missing.");
    return;
  }
  // console.log("Updating balance values..."); // Debug

  let newTotalUsdValue = 0;
  let partialTotal = false; // Re-evaluate if any prices are missing now

  const listItems = dom.balanceList.querySelectorAll(
    "li[data-currency][data-quantity]"
  );

  listItems.forEach((li) => {
    const currency = li.dataset.currency;
    const quantity = parseFloat(li.dataset.quantity);
    const valueSpan = li.querySelector(".asset-value");

    if (!currency || isNaN(quantity) || !valueSpan) {
      console.warn(
        "Skipping update for list item, missing data or element:",
        li
      );
      return; // Skip malformed items
    }

    let usdValue = null;
    if (currency === "USD") {
      usdValue = quantity;
    } else if (currency === "USDT" || currency === "USDC") {
      usdValue = quantity * 1.0;
    } else {
      // Get the LATEST price from global state
      const price = state.latestPrices.get(currency);

      if (price !== undefined && price !== null && Number.isFinite(price)) {
        usdValue = quantity * price;
      } else {
        // console.log(`No valid price found in state for ${currency}`); // Debug
        partialTotal = true; // If price is missing now, total is partial
      }
    }

    // Update the value span text
    if (usdValue !== null && Number.isFinite(usdValue)) {
      valueSpan.textContent = formatCurrency(usdValue);
      newTotalUsdValue += usdValue; // Add to the new total
    } else {
      valueSpan.textContent = `(?.?? USD)`; // Keep placeholder if value unknown
    }

    // Re-check dust partitioning? (More complex - maybe skip for now)
    // If an item *becomes* dust or *stops being* dust due to price changes,
    // it would require moving the element in the DOM or re-rendering.
    // For simplicity, let's just update values in place for now.
    // Re-partitioning could be added later if needed.
  });

  // Update the total value display
  dom.balanceTotalValue.textContent = formatCurrency(newTotalUsdValue);
  dom.balancePartialNotice.style.display = partialTotal ? "inline" : "none";
}

/**
 * Attaches the click listener for the dust category toggle using event delegation.
 */
function attachDustToggleListener() {
  if (!dom.balanceList) return;
  dom.balanceList.removeEventListener("click", handleDustClick);
  dom.balanceList.addEventListener("click", handleDustClick);
  console.log("Dust toggle listener attached.");
}

/**
 * Handles clicks on the balance list, specifically toggling dust visibility.
 * @param {Event} event - The click event object.
 */
function handleDustClick(event) {
  const summaryItem = event.target.closest(`.${DUST_SUMMARY_CLASS}`);
  if (summaryItem) {
    dom.balanceList.classList.toggle(DUST_VISIBLE_CLASS);
    // console.log("Dust visibility toggled:", dom.balanceList.classList.contains(DUST_VISIBLE_CLASS));
    const valueSpan = summaryItem.querySelector(".asset-value");
    if (valueSpan) {
      valueSpan.textContent = dom.balanceList.classList.contains(
        DUST_VISIBLE_CLASS
      )
        ? "(click to hide)"
        : "(click to show)";
    }
  }
}

/**
 * Main function to orchestrate fetching account data AND necessary ticker prices,
 * then updating the balance pane UI. Exported for use in main.js.
 */
export async function initializeBalances() {
  console.log("Initializing balances...");
  if (dom.balanceList)
    dom.balanceList.innerHTML = '<li class="loading">Loading balances...</li>';
  if (dom.balanceTotalValue) dom.balanceTotalValue.textContent = "--.--";
  if (dom.balancePartialNotice) dom.balancePartialNotice.style.display = "none";

  attachDustToggleListener();

  try {
    // 1. Fetch Accounts
    const accountsResponse = await fetch("http://localhost:5000/api/accounts");
    const accountsResult = await (async () => {
      const status = accountsResponse.status;
      try {
        const data = await accountsResponse.json();
        if (data && data.accounts && Array.isArray(data.accounts)) {
          return {
            ok: accountsResponse.ok,
            status: status,
            data: data.accounts,
          };
        } else if (Array.isArray(data)) {
          return { ok: accountsResponse.ok, status: status, data: data };
        } else {
          throw new Error("API response does not contain an accounts array.");
        }
      } catch (e) {
        console.error(
          "Failed to parse accounts response or invalid format:",
          e
        );
        let textResponse = "(Could not read text)";
        try {
          textResponse = await accountsResponse.text();
        } catch {}
        throw new Error(
          `Received non-JSON or invalid response (Status: ${status}). Body: ${textResponse}`
        );
      }
    })();

    if (!accountsResult.ok) {
      throw new Error(
        accountsResult.data?.error ||
          `Account API Error (${accountsResult.status})`
      );
    }
    const accounts = accountsResult.data;

    // 2. Identify non-zero crypto assets needing prices
    const cryptoAssetsToPrice = new Set();
    const ZERO_THRESHOLD = 1e-9;
    const stablecoins = new Set(["USD", "USDT", "USDC", "EUR", "GBP"]);

    accounts.forEach((acc) => {
      const currency = acc?.currency?.toUpperCase();
      const availableString = acc?.available_balance?.value ?? "0";
      const holdString = acc?.hold?.value ?? "0";
      const availableBalance = parseFloat(availableString);
      const holdBalance = parseFloat(holdString);

      if (isNaN(availableBalance) || isNaN(holdBalance)) return;
      const totalBalance = availableBalance + holdBalance;

      const isPricableCrypto = currency && !stablecoins.has(currency);
      const isNonZero = Math.abs(totalBalance) >= ZERO_THRESHOLD;

      if (isPricableCrypto && isNonZero) {
        cryptoAssetsToPrice.add(currency);
      }
    });
    console.log("Assets to Fetch Prices For:", Array.from(cryptoAssetsToPrice));

    // 3. Fetch prices concurrently
    const pricePromises = Array.from(cryptoAssetsToPrice).map((currency) => {
      const productId = `${currency}-USD`;
      return fetchTickerPrice(productId).then((price) => ({ currency, price }));
    });
    const priceResults = await Promise.all(pricePromises);

    // 4. Create Price Map AND Update Global State
    const initialPrices = new Map();
    priceResults.forEach((result) => {
      if (result.price !== null && Number.isFinite(result.price)) {
        initialPrices.set(result.currency, result.price);
        // ---> Populate global state with initial prices <---
        updateLatestPrice(result.currency, result.price);
      }
    });
    // Add stablecoins to global state map (price is 1.0)
    updateLatestPrice("USD", 1.0);
    updateLatestPrice("USDC", 1.0);
    updateLatestPrice("USDT", 1.0);
    // Add others if needed

    console.log("Fetched Valid Prices:", Object.fromEntries(initialPrices));
    console.log(
      "Initial Global Prices State:",
      Object.fromEntries(state.latestPrices)
    );

    // 5. Update UI using the initial prices map
    updateBalancePaneUI(accounts, initialPrices);
  } catch (error) {
    console.error("Error initializing balances:", error);
    if (dom.balanceList)
      dom.balanceList.innerHTML = `<li class="error">Error loading balances: ${error.message}</li>`;
    if (dom.balanceTotalValue)
      dom.balanceTotalValue.textContent = formatCurrency(0);
    if (dom.balancePartialNotice)
      dom.balancePartialNotice.style.display = "none";
  }
}

```
--- END FILE: js/balance.js ---


--- START FILE: js/config.js ---
```js
// js/config.js

// Chart configuration constants
export const ZOOM_FACTOR_X = 0.1;
export const ZOOM_FACTOR_Y = 0.1;
export const MIN_VISIBLE_CANDLES = 5;
export const DEFAULT_RESET_CANDLE_COUNT = 100;
export const MIN_PRICE_RANGE_SPAN = 0.1; // Smallest linear price diff allowed
export const Y_AXIS_PRICE_PADDING_FACTOR = 0.05; // Linear scale padding (used for initial load, maybe keep?)
export const Y_AXIS_LOG_PADDING_FACTOR = 0.08; // Multiplicative padding for log scale (used for initial load, maybe keep?)
export const Y_AXIS_RESET_FILL_FACTOR = 0.85; // Target fill % of chart height on double-click reset (e.g., 85%)
export const BALANCE_DUST_THRESHOLD_USD = 0.5; // USD value below which balances are considered "dust"
export const Y_AXIS_DRAG_SENSITIVITY = 2.0;
export const X_AXIS_DRAG_SENSITIVITY = 2.0;
export const MOUSE_MOVE_THROTTLE = 16; // ~60fps
export const DEBOUNCE_DELAY = 100; // Resize debounce
export const TOOLTIP_SHOW_DELAY = 300; // ms delay before showing tooltip
export const TOOLTIP_HIDE_DELAY = 100; // ms delay before hiding tooltip

// API Defaults (used in main.js)
export const DEFAULT_GRANULARITY = 3600; // 1 hour (must be a number)
export const DEFAULT_PRODUCT_ID = "BTC-USD"; // This should be a string

```
--- END FILE: js/config.js ---


--- START FILE: js/domElements.js ---
```js
// js/domElements.js

// Layout Structure
export const mainLayout = document.querySelector(".main-layout");
export const headerArea = document.querySelector(".header-area");
export const contentArea = document.getElementById("content-area");
export const chartPane = document.getElementById("chart-pane");
export const resizer = document.getElementById("resizer");
export const bottomPane = document.getElementById("bottom-pane");

// Chart Specific
export const chartContainer = document.getElementById("chart-container");
export const chartWrapper = chartContainer?.querySelector(".chart-wrapper");
export const chartArea = document.getElementById("chart-area");
export const gridContainer = document.getElementById("grid-container");
export const yAxisLabelsContainer = document.getElementById("y-axis-labels");
export const xAxisLabelsContainer = document.getElementById("x-axis-labels");
export const chartMessage = document.getElementById("chart-message");
export const currentPriceLine = document.getElementById("current-price-line");
export const currentPriceLabel = document.getElementById("current-price-label");
export const chartTooltip = document.getElementById("chart-tooltip");
export const crosshairLineX = document.getElementById("crosshair-line-x");
export const crosshairLabelY = document.getElementById("crosshair-label-y");

// Volume/Depth elements REMOVED

// Controls (Header / Settings Menu)
export const headerControls = document.querySelector(".header-controls");
export const granularityControls = document.getElementById(
  "granularity-controls"
);
export const settingsButton = document.getElementById("settings-button");
export const settingsDropdown = document.getElementById("settings-dropdown");

// Switches (Now potentially inside dropdown)
export const themeToggle = document.getElementById("theme-checkbox");
export const logScaleToggle = document.getElementById("log-scale-checkbox");
export const timeFormatToggle = document.getElementById("time-format-checkbox");

// Other UI
export const apiStatusIndicator = document.getElementById(
  "api-status-indicator"
);

// Bottom Pane Tabs
export const bottomTabBar = document.getElementById("bottom-tab-bar");
export const positionsContent = document.getElementById("positions-content");
export const openOrdersContent = document.getElementById("open-orders-content");
export const orderHistoryContent = document.getElementById(
  "order-history-content"
);
export const promptContent = document.getElementById("prompt-content");
export const promptTextarea = document.getElementById("prompt-textarea");

// Balance Pane Specific (Now inside positionsContent)
export const balanceList = document.getElementById("balance-list");
export const balanceTotalValue = document.getElementById("total-usd-value");
export const balancePartialNotice = document.getElementById(
  "total-usd-partial-notice"
);

// Exported map for checkElements to get names
const elementMap = {
  mainLayout,
  headerArea,
  contentArea,
  chartPane,
  resizer,
  bottomPane, // Layout
  chartContainer,
  chartWrapper,
  chartArea,
  gridContainer,
  yAxisLabelsContainer, // Chart Core
  xAxisLabelsContainer,
  chartMessage,
  currentPriceLine,
  currentPriceLabel,
  chartTooltip,
  crosshairLineX,
  crosshairLabelY,
  // volumeChartContainer, volumeChartCanvas, // REMOVED
  headerControls,
  granularityControls,
  settingsButton,
  settingsDropdown, // Header/Settings
  themeToggle,
  logScaleToggle,
  timeFormatToggle, // Switches
  apiStatusIndicator, // Other UI
  bottomTabBar,
  positionsContent,
  openOrdersContent,
  orderHistoryContent,
  promptContent, // Tabs
  promptTextarea, // Prompt Input
  balanceList,
  balanceTotalValue,
  balancePartialNotice, // Balance List (nested)
};

export function checkElements() {
  const missingElements = Object.entries(elementMap)
    .filter(([name, el]) => !el)
    .map(([name]) => name);

  if (missingElements.length > 0) {
    const missingNames = missingElements.join(", ");
    console.error(
      `Initialization failed: Essential DOM elements missing: ${missingNames}`
    );
    if (chartMessage) {
      chartMessage.textContent = `Error: Missing DOM elements! (${missingNames})`;
      chartMessage.style.display = "block";
      chartMessage.style.color = "red";
    } else {
      alert(
        `Error: Critical DOM elements missing: ${missingNames}! Cannot initialize app. Check console.`
      );
    }
    return false;
  }
  console.log("All essential DOM elements found.");
  return true;
}

```
--- END FILE: js/domElements.js ---


--- START FILE: js/drawing.js ---
```js
// js/drawing.js

import * as config from "./config.js";
import state from "./state.js";
import * as dom from "./domElements.js";
import {
  calculateNiceStep,
  formatTimestamp,
  formatDate,
  getYCoordinate,
  MIN_LOG_VALUE, // <<<--- IMPORT HERE
} from "./utils.js";
// Volume/Depth chart drawing is disabled

const SECONDS_PER_DAY = 86400;
const MIN_PIXELS_PER_LABEL = 60;
const Y_AXIS_MAX_ITERATIONS = 500; // Safety limit for Y-axis loop

// --- Live Price Indicator ---
function updateLivePriceIndicatorUI(price, chartHeight) {
  if (
    !dom.currentPriceLabel ||
    !dom.currentPriceLine ||
    isNaN(price) ||
    !Number.isFinite(price) ||
    !chartHeight ||
    chartHeight <= 0
  ) {
    if (dom.currentPriceLabel) dom.currentPriceLabel.style.display = "none";
    if (dom.currentPriceLine) dom.currentPriceLine.style.display = "none";
    return;
  }

  // getYCoordinate internally handles log/linear scaling for position
  const y = getYCoordinate(price, chartHeight);

  if (y !== null && Number.isFinite(y)) {
    // Adjust decimal places based on price magnitude for better readability
    let decimals = 0;
    if (price < 0.01) decimals = 6;
    else if (price < 1) decimals = 4;
    else if (price < 100) decimals = 2;
    else if (price < 10000) decimals = 1;
    else decimals = 0; // Or potentially use localeString for larger numbers
    decimals = Math.max(0, decimals);

    dom.currentPriceLabel.textContent = price.toFixed(decimals);
    dom.currentPriceLabel.style.top = `${y.toFixed(1)}px`;
    dom.currentPriceLine.style.top = `${y.toFixed(1)}px`;
    dom.currentPriceLabel.style.display = "block";
    dom.currentPriceLine.style.display = "block";
  } else {
    // Hide if Y coordinate is invalid
    dom.currentPriceLabel.style.display = "none";
    dom.currentPriceLine.style.display = "none";
  }
}

// --- Helper to draw a single Y-axis tick/label ---
// This function takes the *value* to display and uses the global state's
// isLogScale setting (via getYCoordinate) to determine the *position*.
function drawYTick(priceValue, chartHeight, minVisible, maxVisible) {
  // Skip drawing if price is essentially zero or negative
  // Crucial for log scale, harmless for linear.
  if (priceValue <= MIN_LOG_VALUE) return;

  // Get position using the scale-aware function
  const y = getYCoordinate(priceValue, chartHeight);

  // Only draw if y is a valid number
  if (y === null || !Number.isFinite(y)) {
    // console.warn("Skipped drawing Y grid/label for price:", priceValue, "due to invalid Y:", y);
    return;
  }

  // Draw grid line slightly outside main chart area too
  if (y >= -chartHeight * 0.1 && y <= chartHeight * 1.1) {
    const hLine = document.createElement("div");
    hLine.className = "grid-line horizontal";
    hLine.style.top = `${y.toFixed(1)}px`;
    dom.gridContainer.appendChild(hLine);
  }

  // Draw label only if clearly within or very near chart height
  if (y >= -5 && y <= chartHeight + 5) {
    const yLabel = document.createElement("div");
    yLabel.className = "axis-label y-axis-label";
    yLabel.style.top = `${y.toFixed(1)}px`;

    // Determine decimals based on price magnitude
    let decimals = 0;
    if (priceValue < 0.01) decimals = 6;
    else if (priceValue < 1) decimals = 4;
    else if (priceValue < 100) decimals = 2;
    else if (priceValue < 10000) decimals = 1;
    else decimals = 0;
    decimals = Math.max(0, decimals); // Ensure non-negative

    yLabel.textContent = priceValue.toFixed(decimals);
    dom.yAxisLabelsContainer.appendChild(yLabel);
  }
}

// --- Main Chart Redraw ---
export function redrawChart() {
  if (
    !dom.chartArea ||
    !dom.gridContainer ||
    !dom.yAxisLabelsContainer ||
    !dom.xAxisLabelsContainer
  ) {
    console.error(
      "Cannot redraw main chart: Essential drawing containers missing."
    );
    return;
  }

  // Clear previous content
  dom.chartArea.innerHTML = "";
  dom.gridContainer.innerHTML = "";
  dom.yAxisLabelsContainer.innerHTML = "";
  dom.xAxisLabelsContainer.innerHTML = "";

  const chartHeight = dom.chartArea.offsetHeight;
  const chartWidth = dom.chartArea.offsetWidth;

  // Validate chart dimensions and data
  if (!state.fullData || chartHeight <= 0 || chartWidth <= 0) {
    console.warn("Main chart redraw skipped: No data or invalid dimensions.");
    return;
  }

  const {
    minVisiblePrice,
    maxVisiblePrice,
    isLogScale, // We still need this for positioning via getYCoordinate
    visibleStartIndex,
    visibleEndIndex,
  } = state;
  const visibleCount = visibleEndIndex - visibleStartIndex;

  // More robust validation of price range state
  if (
    isNaN(minVisiblePrice) ||
    isNaN(maxVisiblePrice) ||
    !Number.isFinite(minVisiblePrice) ||
    !Number.isFinite(maxVisiblePrice) ||
    maxVisiblePrice <= minVisiblePrice ||
    (isLogScale && minVisiblePrice <= 0) // Log scale requires positive min price
  ) {
    console.error("Redraw failed: Invalid price range in state!", {
      minVisiblePrice,
      maxVisiblePrice,
      isLogScale,
    });
    if (dom.chartMessage) {
      dom.chartMessage.textContent = "Error: Invalid Price Range";
      dom.chartMessage.style.display = "block";
      dom.chartMessage.style.color = "red";
    }
    return; // Stop drawing
  }

  if (visibleCount <= 0) {
    console.warn("Redraw skipped: No visible candles.");
    return; // Nothing to draw
  }

  // Constants for candle drawing
  const candleTotalWidth = chartWidth / visibleCount;
  const candleBodyWidthRatio = 0.7; // Relative width of body to total candle space
  const candleWidth = Math.max(1, candleTotalWidth * candleBodyWidthRatio);
  const candleMargin = Math.max(0.5, (candleTotalWidth - candleWidth) / 2);

  // --- Draw Grid & Y-Axis ---
  try {
    const yTickDensity = Math.max(3, Math.round(chartHeight / 40));
    let iterationCount = 0;

    // --- Calculate Tick Values using LINEAR logic REGARDLESS of scale type ---
    const linearRange = maxVisiblePrice - minVisiblePrice;
    const linearTicks =
      linearRange > 0 && Number.isFinite(linearRange)
        ? calculateNiceStep(linearRange, yTickDensity)
        : 1; // Fallback step

    if (!linearTicks || linearTicks <= 0 || !Number.isFinite(linearTicks)) {
      console.error(
        "Y-Axis drawing aborted: Invalid linear tick step calculated.",
        linearTicks
      );
    } else {
      let firstLinearTick;
      // Find the first linear tick >= minVisiblePrice
      if (minVisiblePrice >= 0) {
        firstLinearTick =
          linearTicks > 0
            ? Math.ceil(minVisiblePrice / linearTicks) * linearTicks
            : minVisiblePrice;
      } else {
        // Handle negative minVisiblePrice (though unlikely for price charts)
        firstLinearTick =
          linearTicks > 0
            ? Math.floor(minVisiblePrice / linearTicks) * linearTicks
            : minVisiblePrice;
      }
      // Adjust if the first tick is too far above minVisiblePrice
      if (
        linearTicks > 0 &&
        firstLinearTick - minVisiblePrice > linearTicks * 0.99
      ) {
        firstLinearTick -= linearTicks;
      }
      // Ensure first tick isn't below zero if min price is positive
      if (minVisiblePrice > 0 && firstLinearTick < 0) {
        firstLinearTick = 0;
      }

      const loopUpperBound = maxVisiblePrice + linearTicks * 0.1; // Loop slightly beyond max

      // --- Loop using LINEAR price increments ---
      for (
        let currentPrice = firstLinearTick;
        currentPrice <= loopUpperBound &&
        iterationCount < Y_AXIS_MAX_ITERATIONS;
        currentPrice =
          linearTicks > 0 ? currentPrice + linearTicks : loopUpperBound + 1 // Add linear step, break if step invalid
      ) {
        iterationCount++;

        // --- Draw Tick using the scale-aware helper function ---
        // The drawYTick function will use getYCoordinate which checks
        // state.isLogScale to determine the CORRECT POSITION.
        // The value displayed will be `currentPrice`.
        drawYTick(currentPrice, chartHeight, minVisiblePrice, maxVisiblePrice);

        // Safety break if price isn't increasing
        if (
          linearTicks > Number.EPSILON &&
          currentPrice + linearTicks <= currentPrice
        ) {
          console.warn("Y-Axis loop safety break: Price not increasing.", {
            currentPrice,
            linearTicks,
          });
          break;
        }
      } // End for loop

      if (iterationCount >= Y_AXIS_MAX_ITERATIONS) {
        console.warn("Y-Axis drawing loop hit max iteration limit.");
      }
    } // End else (valid linearTicks)
  } catch (e) {
    console.error("Error drawing Y grid/axis:", e);
  }

  // --- Draw X-Axis & Separators --- (No changes needed here)
  try {
    const xTickDensity = Math.max(3, Math.round(chartWidth / 70));
    // Ensure visibleCount is positive for step calculation
    const xTicks =
      visibleCount > 0
        ? Math.max(1, calculateNiceStep(visibleCount, xTickDensity))
        : 1;
    let lastLabelX = -Infinity;

    for (let i = 0; i < visibleCount; i++) {
      const dataIndex = visibleStartIndex + i;
      if (dataIndex < 0 || dataIndex >= state.fullData.length) continue;

      const candleData = state.fullData[dataIndex];
      if (!candleData || candleData.length < 1 || isNaN(candleData[0]))
        continue; // Check timestamp
      const timestamp = candleData[0];

      // Decide if this index should have a label
      const isFirst = i === 0;
      const isLast = i === visibleCount - 1;
      // Simple modulo check for ticks (ensure xTicks is positive)
      const isTick = xTicks > 0 && (i + Math.floor(xTicks / 2)) % xTicks === 0;

      if (isFirst || isLast || isTick) {
        const x = (i + 0.5) * candleTotalWidth; // Center label on candle

        // Prevent labels overlapping too much
        if (x - lastLabelX > MIN_PIXELS_PER_LABEL || isFirst || isLast) {
          // Only draw if within reasonable bounds of the chart width
          if (x >= -candleTotalWidth && x <= chartWidth + candleTotalWidth) {
            const xLabel = document.createElement("div");
            xLabel.className = "axis-label x-axis-label";
            xLabel.style.left = `${x.toFixed(1)}px`;
            xLabel.textContent = formatTimestamp(timestamp); // Use state-aware formatter
            dom.xAxisLabelsContainer.appendChild(xLabel);
            lastLabelX = x;
          }
        }
      }
    }
  } catch (e) {
    console.error("Error drawing X grid/axis:", e);
  }

  // --- Draw Candles --- (No changes needed here)
  try {
    const fragment = document.createDocumentFragment(); // Use fragment for performance

    for (let i = 0; i < visibleCount; i++) {
      const dataIndex = visibleStartIndex + i;
      if (dataIndex < 0 || dataIndex >= state.fullData.length) continue;

      const candle = state.fullData[dataIndex];
      // Ensure candle data is valid (time, low, high, open, close)
      if (
        !candle ||
        candle.length < 5 ||
        candle.slice(0, 5).some((v) => isNaN(v) || !Number.isFinite(v))
      ) {
        // console.warn(`Skipping candle at index ${dataIndex}: Invalid data`, candle);
        continue;
      }

      const [timestamp, low, high, open, close] = candle;

      // Calculate Y coordinates using the robust utility function
      // getYCoordinate internally handles log/linear based on state.isLogScale
      const wickHighY = getYCoordinate(high, chartHeight);
      const wickLowY = getYCoordinate(low, chartHeight);
      const bodyOpenY = getYCoordinate(open, chartHeight);
      const bodyCloseY = getYCoordinate(close, chartHeight);

      // *** CRITICAL CHECK: Ensure all coordinates are valid finite numbers ***
      if (
        wickHighY === null ||
        !Number.isFinite(wickHighY) ||
        wickLowY === null ||
        !Number.isFinite(wickLowY) ||
        bodyOpenY === null ||
        !Number.isFinite(bodyOpenY) ||
        bodyCloseY === null ||
        !Number.isFinite(bodyCloseY)
      ) {
        // console.warn(`Skipping candle index ${dataIndex}: Invalid Y coordinate calculated.`);
        // console.warn({wickHighY, wickLowY, bodyOpenY, bodyCloseY});
        continue; // Skip this candle entirely if any coordinate is invalid
      }

      const bodyTopY = Math.min(bodyOpenY, bodyCloseY);
      const bodyBottomY = Math.max(bodyOpenY, bodyCloseY);

      // Calculate heights, ensuring minimum of 1px if coordinates are valid
      // Also check that wickLowY >= wickHighY and bodyBottomY >= bodyTopY
      const wickHeight = Math.max(1, wickLowY - wickHighY);
      const bodyHeight = Math.max(1, bodyBottomY - bodyTopY);

      const isUp = close >= open;

      // Create candle elements
      const candleElement = document.createElement("div");
      candleElement.className = "candle";
      candleElement.style.width = `${candleWidth.toFixed(1)}px`;
      // Position based on the center of the candle slot
      const candleLeft = i * candleTotalWidth + candleMargin;
      candleElement.style.left = `${candleLeft.toFixed(1)}px`;

      // Wick Element (only draw if height is valid)
      if (wickHeight >= 1 && wickLowY >= wickHighY) {
        const wickElement = document.createElement("div");
        wickElement.className = "wick";
        wickElement.style.top = `${wickHighY.toFixed(1)}px`;
        wickElement.style.height = `${wickHeight.toFixed(1)}px`;
        candleElement.appendChild(wickElement);
      }

      // Body Element (only draw if height is valid)
      if (bodyHeight >= 1 && bodyBottomY >= bodyTopY) {
        const bodyElement = document.createElement("div");
        bodyElement.className = `body ${isUp ? "color-up" : "color-down"}`;
        bodyElement.style.top = `${bodyTopY.toFixed(1)}px`;
        bodyElement.style.height = `${bodyHeight.toFixed(1)}px`;
        candleElement.appendChild(bodyElement);
      }

      // Only append candleElement if it has a body or wick
      if (candleElement.childNodes.length > 0) {
        fragment.appendChild(candleElement); // Append to fragment
      }
    }

    dom.chartArea.appendChild(fragment); // Append fragment once
  } catch (e) {
    console.error("Error drawing candles:", e);
  }

  // --- Update Live Price Indicator --- (No changes needed here)
  let priceForIndicator = state.lastTickerPrice;
  // Fallback to last candle's close if ticker price isn't available
  if (
    (priceForIndicator === null || !Number.isFinite(priceForIndicator)) &&
    state.fullData.length > 0
  ) {
    const lastCandle = state.fullData[state.fullData.length - 1];
    if (
      lastCandle &&
      lastCandle.length >= 5 &&
      Number.isFinite(lastCandle[4])
    ) {
      priceForIndicator = lastCandle[4]; // Use close price
    }
  }

  // Check again if price is valid before updating UI
  if (priceForIndicator !== null && Number.isFinite(priceForIndicator)) {
    updateLivePriceIndicatorUI(priceForIndicator, chartHeight);
  } else {
    // Ensure it's hidden if no valid price
    if (dom.currentPriceLabel) dom.currentPriceLabel.style.display = "none";
    if (dom.currentPriceLine) dom.currentPriceLine.style.display = "none";
  }
} // End of redrawChart function

```
--- END FILE: js/drawing.js ---


--- START FILE: js/interactions.js ---
```js
// js/interactions.js

import * as config from "./config.js"; // Import config
import state, { updateState } from "./state.js";
import * as dom from "./domElements.js";
import { redrawChart } from "./drawing.js";
import {
  calculateNiceStep,
  getYCoordinate,
  formatDate,
  formatTimestamp,
  getPriceFromYCoordinate,
  MIN_LOG_VALUE, // Import MIN_LOG_VALUE
} from "./utils.js"; // <<< ENSURE IMPORT IS HERE

// Tooltip State
let hoveredCandleIndex = null;
let tooltipShowTimeout = null;
let tooltipHideTimeout = null;

// Log Scale Helpers
const log = Math.log;
const exp = Math.exp;
// const MIN_LOG_VALUE = 1e-9; // Defined and imported from utils.js now
function safeLog(value) {
  return log(Math.max(MIN_LOG_VALUE, value));
}

// --- Tooltip Functions ---
// ... (showTooltip, hideTooltip - no changes needed) ...
function showTooltip(dataIndex, mouseX, mouseY) {
  if (!dom.chartTooltip || !dom.chartArea) return;

  if (dataIndex < 0 || dataIndex >= state.fullData.length) {
    hideTooltip();
    return;
  }

  const candleData = state.fullData[dataIndex];
  // Need timestamp[0], low[1], high[2], open[3], close[4] for tooltip
  if (
    !candleData ||
    candleData.length < 5 ||
    candleData.slice(0, 5).some((v) => isNaN(v) || !Number.isFinite(v))
  ) {
    hideTooltip();
    return;
  }

  const [timestamp, low, high, open, close] = candleData;
  const chartRect = dom.chartArea.getBoundingClientRect();
  const chartHeight = dom.chartArea.offsetHeight; // Use offsetHeight
  const chartContainerRect = dom.chartContainer.getBoundingClientRect(); // Use container for positioning relative to it

  // Formatting
  const dateStr = formatDate(timestamp);
  const timeStr = formatTimestamp(timestamp);
  const priceRange = state.maxVisiblePrice - state.minVisiblePrice;
  let decimals = 0;
  if (priceRange < 0.1) decimals = 4;
  else if (priceRange < 1) decimals = 3;
  else if (priceRange < 10 || close < 10) decimals = 2;
  else if (close < 1000) decimals = 1;
  else decimals = 0;
  decimals = Math.max(0, decimals); // Ensure non-negative

  // Update Tooltip Content
  dom.chartTooltip.innerHTML = `
    <div class="date">${dateStr}, ${timeStr}</div>
    <div><span class="label">O:</span> <span class="value">${open.toFixed(
      decimals
    )}</span></div>
    <div><span class="label">H:</span> <span class="value">${high.toFixed(
      decimals
    )}</span></div>
    <div><span class="label">L:</span> <span class="value">${low.toFixed(
      decimals
    )}</span></div>
    <div><span class="label">C:</span> <span class="value">${close.toFixed(
      decimals
    )}</span></div>
    `;
  // Optionally add Volume:
  // ${candleData.length > 5 && !isNaN(candleData[5]) && Number.isFinite(candleData[5]) ? `<div><span class="label">Vol:</span> <span class="value">${candleData[5].toLocaleString()}</span></div>` : ''}

  // Calculate Tooltip Position
  // Get tooltip dimensions *after* setting content
  const tooltipElementHeight = dom.chartTooltip.offsetHeight;
  const tooltipElementWidth = dom.chartTooltip.offsetWidth;

  // Default position: above and slightly to the right of the cursor
  let tooltipY = mouseY - tooltipElementHeight - 10; // 10px offset above
  let tooltipX = mouseX + 15; // 15px offset right

  // Adjust if too high (flip below cursor)
  if (tooltipY < 10) {
    // 10px margin from top of chart area
    tooltipY = mouseY + 20; // 20px offset below
  }

  // Adjust if too far right (flip left of cursor)
  // Calculate right boundary within the chart container (excluding Y axis label width)
  const yAxisWidth = dom.yAxisLabelsContainer?.offsetWidth || 55; // Estimate width if not available
  const rightBoundary = dom.chartContainer.offsetWidth - yAxisWidth - 10; // 10px margin
  if (tooltipX + tooltipElementWidth > rightBoundary) {
    tooltipX = mouseX - tooltipElementWidth - 15; // 15px offset left
  }

  // Adjust if too far left
  if (tooltipX < 10) {
    // 10px margin from left edge
    tooltipX = 10;
  }

  // Apply position relative to the chart container
  const containerRelativeX =
    tooltipX + chartRect.left - chartContainerRect.left;
  const containerRelativeY = tooltipY + chartRect.top - chartContainerRect.top;

  dom.chartTooltip.style.left = `${containerRelativeX.toFixed(0)}px`;
  dom.chartTooltip.style.top = `${containerRelativeY.toFixed(0)}px`;

  // Show Tooltip with fade-in effect
  dom.chartTooltip.style.display = "block"; // Make it take space for measurements if needed?
  dom.chartTooltip.style.visibility = "visible"; // Make it visible
  dom.chartTooltip.style.opacity = 1; // Start fade-in (or ensure it's fully visible)
  dom.chartTooltip.classList.add("visible"); // Add class if transition relies on it
}

function hideTooltip() {
  if (dom.chartTooltip) {
    dom.chartTooltip.style.opacity = 0;
    dom.chartTooltip.style.visibility = "hidden";
    dom.chartTooltip.classList.remove("visible");
  }
  hoveredCandleIndex = null; // Reset hovered index when hiding
}

// --- Crosshair Update Functions ---
// ... (updateCrosshair, hideCrosshair - no changes needed) ...
function updateCrosshair(mouseX, mouseY, chartHeight, chartWidth) {
  if (
    !dom.crosshairLineX ||
    !dom.crosshairLabelY ||
    mouseX === null ||
    mouseY === null ||
    chartHeight <= 0
  ) {
    hideCrosshair();
    return;
  }

  // Clamp mouse Y to chart boundaries for price calculation and line position
  const clampedMouseY = Math.max(0, Math.min(mouseY, chartHeight));

  const priceAtCursor = getPriceFromYCoordinate(clampedMouseY, chartHeight);

  if (priceAtCursor !== null && Number.isFinite(priceAtCursor)) {
    // Position horizontal line
    dom.crosshairLineX.style.top = `${clampedMouseY.toFixed(1)}px`;
    dom.crosshairLineX.style.display = "block";

    // Update and position price label
    const priceRange = state.maxVisiblePrice - state.minVisiblePrice;
    let decimals = 0;
    if (priceRange < 0.1) decimals = 4;
    else if (priceRange < 1) decimals = 3;
    else if (priceRange < 10 || priceAtCursor < 10) decimals = 2;
    else if (priceAtCursor < 1000) decimals = 1;
    else decimals = 0;
    decimals = Math.max(0, decimals); // Ensure non-negative

    dom.crosshairLabelY.textContent = priceAtCursor.toFixed(decimals);
    dom.crosshairLabelY.style.top = `${clampedMouseY.toFixed(1)}px`; // Align label with line
    dom.crosshairLabelY.style.display = "block";
  } else {
    // Hide if price calculation failed
    hideCrosshair();
  }
}

function hideCrosshair() {
  if (dom.crosshairLineX) dom.crosshairLineX.style.display = "none";
  if (dom.crosshairLabelY) dom.crosshairLabelY.style.display = "none";
}

// --- Interaction Handlers ---
// ... (handleMouseMoveForTooltip, handleMouseLeaveChartArea - no changes needed) ...
function handleMouseMoveForTooltip(event) {
  if (!dom.chartArea) return;

  const chartRect = dom.chartArea.getBoundingClientRect();
  const mouseX = event.clientX - chartRect.left;
  const mouseY = event.clientY - chartRect.top;
  const chartWidth = dom.chartArea.offsetWidth;
  const chartHeight = dom.chartArea.offsetHeight;

  // Hide crosshair and tooltip immediately if panning/dragging
  if (state.isPanning || state.isDraggingXAxis || state.isDraggingYAxis) {
    hideCrosshair();
    clearTimeout(tooltipShowTimeout);
    clearTimeout(tooltipHideTimeout);
    tooltipHideTimeout = null; // Reset hide timeout flag
    hideTooltip();
    return;
  }

  // Check if mouse is within chart bounds
  const isInsideChart =
    mouseX >= 0 && mouseX <= chartWidth && mouseY >= 0 && mouseY <= chartHeight;

  if (
    isInsideChart &&
    chartWidth > 0 &&
    chartHeight > 0 &&
    state.fullData.length > 0
  ) {
    // Update Crosshair
    updateCrosshair(mouseX, mouseY, chartHeight, chartWidth);

    // --- Tooltip Logic ---
    const visibleCount = state.visibleEndIndex - state.visibleStartIndex;
    if (visibleCount <= 0) {
      hideTooltip(); // Hide if no candles visible
      return;
    }

    const candleTotalWidth = chartWidth / visibleCount;
    // Calculate index based on mouse position
    const currentSlotIndex = Math.floor(mouseX / candleTotalWidth);
    const currentDataIndex = state.visibleStartIndex + currentSlotIndex;

    // Check if the calculated index is valid
    if (currentDataIndex >= 0 && currentDataIndex < state.fullData.length) {
      if (currentDataIndex !== hoveredCandleIndex) {
        // Mouse moved to a new candle index
        clearTimeout(tooltipShowTimeout); // Cancel any pending show
        clearTimeout(tooltipHideTimeout); // Cancel any pending hide
        tooltipHideTimeout = null;
        hideTooltip(); // Hide previous tooltip immediately

        hoveredCandleIndex = currentDataIndex; // Update hovered index

        // Set timeout to show the new tooltip after a delay
        tooltipShowTimeout = setTimeout(() => {
          showTooltip(hoveredCandleIndex, mouseX, mouseY);
          tooltipShowTimeout = null; // Clear the timeout ID once shown
        }, config.TOOLTIP_SHOW_DELAY);
      } else {
        // Mouse is still over the same candle index
        clearTimeout(tooltipHideTimeout); // Cancel hide timeout if mouse re-enters quickly
        tooltipHideTimeout = null;
        // Optional: Update tooltip position while hovering over the same candle?
        // showTooltip(hoveredCandleIndex, mouseX, mouseY); // This would make it follow cursor exactly
      }
    } else {
      // Mouse is inside chart but not over a valid candle index (e.g., padding areas)
      clearTimeout(tooltipShowTimeout); // Cancel pending show
      tooltipShowTimeout = null;
      hoveredCandleIndex = null; // No candle is hovered

      // Start hide timeout if tooltip is currently visible
      if (dom.chartTooltip && dom.chartTooltip.style.visibility === "visible") {
        if (!tooltipHideTimeout) {
          // Only start hide timer if not already running
          tooltipHideTimeout = setTimeout(() => {
            hideTooltip();
            tooltipHideTimeout = null;
          }, config.TOOLTIP_HIDE_DELAY);
        }
      } else {
        hideTooltip(); // Hide immediately if not visible
      }
    }
  } else {
    // Mouse is outside chart bounds
    hideCrosshair();
    clearTimeout(tooltipShowTimeout); // Cancel pending show
    tooltipShowTimeout = null;
    clearTimeout(tooltipHideTimeout); // Cancel pending hide
    tooltipHideTimeout = null;
    hoveredCandleIndex = null; // No candle hovered
    hideTooltip(); // Hide immediately
  }
}

function handleMouseLeaveChartArea(event) {
  // Handles BOTH crosshair and tooltip when mouse leaves the specific chartArea element
  hideCrosshair();
  clearTimeout(tooltipShowTimeout);
  tooltipShowTimeout = null;
  clearTimeout(tooltipHideTimeout);
  tooltipHideTimeout = null;
  hoveredCandleIndex = null;
  hideTooltip();
}

// --- Chart Interaction Handlers (Zoom, Pan, Scale, Resize, DoubleClick) ---
// ... (handleZoom, handleMouseMove, handleMouseDownChart, etc. - no changes needed) ...
export function handleZoom(event) {
  event.preventDefault();
  if (!dom.chartArea) return;

  const chartRect = dom.chartArea.getBoundingClientRect();
  const mouseX = event.clientX - chartRect.left;
  const mouseY = event.clientY - chartRect.top;
  const chartHeight = dom.chartArea.offsetHeight;
  const chartWidth = dom.chartArea.offsetWidth;

  if (!chartHeight || !chartWidth || !state.fullData.length) return;

  const zoomDirection = event.deltaY < 0 ? -1 : 1; // -1 for zoom in, 1 for zoom out
  let newState = {};

  // --- Y-Axis Zoom ---
  const currentMinY = state.minVisiblePrice;
  const currentMaxY = state.maxVisiblePrice;

  if (state.isLogScale) {
    const logMin = safeLog(currentMinY);
    const logMax = safeLog(currentMaxY);
    const logRange = logMax - logMin;

    // Check if range is valid for zooming
    if (logRange > 0 && Number.isFinite(logRange)) {
      const logAtCursor = logMax - (mouseY / chartHeight) * logRange; // Price (in log space) at cursor Y
      const zoomAmountY = 1 + zoomDirection * config.ZOOM_FACTOR_Y;

      // Calculate new log min/max based on zooming around the cursor position
      let newLogMin = logAtCursor - (logAtCursor - logMin) * zoomAmountY;
      let newLogMax = logAtCursor + (logMax - logAtCursor) * zoomAmountY;

      // Convert back to linear scale and ensure min is positive
      newState.minVisiblePrice = Math.max(MIN_LOG_VALUE, exp(newLogMin));
      newState.maxVisiblePrice = exp(newLogMax);

      // Prevent excessive zoom-in (minimum ratio)
      if (newState.maxVisiblePrice / newState.minVisiblePrice < 1.001) {
        const midPriceLog = (newLogMin + newLogMax) / 2;
        const halfRangeLog = Math.log(1.0005); // ~0.05% ratio
        newState.minVisiblePrice = Math.max(
          MIN_LOG_VALUE,
          exp(midPriceLog - halfRangeLog)
        );
        newState.maxVisiblePrice = exp(midPriceLog + halfRangeLog);
      }
    }
  } else {
    // Linear Scale Zoom
    const linearRange = currentMaxY - currentMinY;

    if (linearRange > 0 && Number.isFinite(linearRange)) {
      const priceAtCursor = currentMaxY - (mouseY / chartHeight) * linearRange;
      const zoomAmountY = 1 + zoomDirection * config.ZOOM_FACTOR_Y;

      let newMin = priceAtCursor - (priceAtCursor - currentMinY) * zoomAmountY;
      let newMax = priceAtCursor + (currentMaxY - priceAtCursor) * zoomAmountY;

      // Ensure minimum price span and non-negative min
      if (newMax - newMin < config.MIN_PRICE_RANGE_SPAN) {
        const mid = (newMax + newMin) / 2;
        newMin = mid - config.MIN_PRICE_RANGE_SPAN / 2;
        newMax = mid + config.MIN_PRICE_RANGE_SPAN / 2;
      }
      newState.minVisiblePrice = Math.max(0, newMin); // Clamp min at 0
      newState.maxVisiblePrice = newMax;
    }
  }

  // --- X-Axis Zoom ---
  const currentVisibleCount = state.visibleEndIndex - state.visibleStartIndex;
  if (currentVisibleCount > 0) {
    // Calculate the data index under the cursor
    const indexAtCursorFloat =
      state.visibleStartIndex + (mouseX / chartWidth) * currentVisibleCount;
    const zoomAmountX = 1 + zoomDirection * config.ZOOM_FACTOR_X;

    // Calculate new number of visible candles
    let newVisibleCount = Math.round(currentVisibleCount * zoomAmountX);
    newVisibleCount = Math.max(
      config.MIN_VISIBLE_CANDLES,
      // Limit zoom out to maybe 5x the total data length? Prevents excessive range.
      Math.min(newVisibleCount, state.fullData.length * 5)
    );
    // Clamp further to not exceed total data length when zooming in fully
    newVisibleCount = Math.min(newVisibleCount, state.fullData.length);

    // Calculate new start index to keep the index under the cursor stationary
    let newStartIndex = Math.round(
      indexAtCursorFloat - (mouseX / chartWidth) * newVisibleCount
    );

    // Clamp start/end indices to valid range [0, fullData.length]
    newStartIndex = Math.max(0, newStartIndex);
    let newEndIndex = newStartIndex + newVisibleCount;

    // Adjust if end index exceeds data bounds
    if (newEndIndex > state.fullData.length) {
      newEndIndex = state.fullData.length;
      newStartIndex = Math.max(0, newEndIndex - newVisibleCount); // Recalculate start index based on clamped end
    }
    // Final clamp on start index (shouldn't be needed if logic above is correct, but safe)
    newStartIndex = Math.max(0, newStartIndex);

    newState.visibleStartIndex = newStartIndex;
    newState.visibleEndIndex = newEndIndex;
  }

  // Apply the combined state changes
  if (Object.keys(newState).length > 0) {
    updateState(newState);
    requestAnimationFrame(redrawChart);
  }
}

export function handleMouseMove(event) {
  if (!state.isPanning && !state.isDraggingYAxis && !state.isDraggingXAxis) {
    // If not dragging/panning, delegate to tooltip/crosshair handler
    // handleMouseMoveForTooltip(event); // This causes issues if mouse moves outside chartArea
    return;
  }

  // Throttle redraw calls during drag/pan
  const now = Date.now();
  if (now - state.lastDrawTime < config.MOUSE_MOVE_THROTTLE) return;

  let needsRedraw = false;
  let newState = {};
  const chartHeight = dom.chartArea?.offsetHeight;
  const chartWidth = dom.chartArea?.offsetWidth;

  // --- Y-Axis Scaling (Dragging Y Axis) ---
  if (state.isDraggingYAxis) {
    const deltaY = event.clientY - state.panStartY;
    if (!chartHeight || chartHeight <= 0) return;

    if (state.isLogScale) {
      const logMinStart = safeLog(state.panStartMinPrice);
      const logMaxStart = safeLog(state.panStartMaxPrice);
      const logRangeStart = logMaxStart - logMinStart;

      if (logRangeStart > 0 && Number.isFinite(logRangeStart)) {
        const midLogPrice = (logMaxStart + logMinStart) / 2;
        // Exponential scaling based on drag distance
        const scaleFactor = Math.pow(
          2,
          (deltaY / chartHeight) * config.Y_AXIS_DRAG_SENSITIVITY
        );
        let newLogRange = logRangeStart * scaleFactor;

        // Prevent excessive zoom-in (minimum ratio ~0.1%)
        if (exp(newLogRange) < 1.001) {
          newLogRange = log(1.001);
        }

        const newLogMin = midLogPrice - newLogRange / 2;
        const newLogMax = midLogPrice + newLogRange / 2;

        const newMin = Math.max(MIN_LOG_VALUE, exp(newLogMin));
        const newMax = exp(newLogMax);

        // Check if changes are significant enough to redraw
        if (
          Math.abs(newMin - state.minVisiblePrice) > 1e-9 ||
          Math.abs(newMax - state.maxVisiblePrice) > 1e-9
        ) {
          newState.minVisiblePrice = newMin;
          newState.maxVisiblePrice = newMax;
          needsRedraw = true;
        }
      }
    } else {
      // Linear Scale Y-Axis Drag
      const initialRange = state.panStartMaxPrice - state.panStartMinPrice;
      if (initialRange > 0 && Number.isFinite(initialRange)) {
        const midPrice = (state.panStartMaxPrice + state.panStartMinPrice) / 2;
        const scaleFactor = Math.pow(
          2,
          (deltaY / chartHeight) * config.Y_AXIS_DRAG_SENSITIVITY
        );
        let newRange = initialRange * scaleFactor;
        newRange = Math.max(config.MIN_PRICE_RANGE_SPAN, newRange); // Enforce min span

        const newMin = midPrice - newRange / 2;
        const newMax = midPrice + newRange / 2;

        // Check if changes are significant
        if (
          Math.abs(newMin - state.minVisiblePrice) > 1e-9 ||
          Math.abs(newMax - state.maxVisiblePrice) > 1e-9
        ) {
          newState.minVisiblePrice = Math.max(0, newMin); // Clamp min at 0
          newState.maxVisiblePrice = newMax;
          needsRedraw = true;
        }
      }
    }
  }
  // --- X-Axis Scaling (Dragging X Axis) ---
  else if (state.isDraggingXAxis) {
    const deltaX = event.clientX - state.panStartX;
    if (!chartWidth || chartWidth <= 0 || state.panStartVisibleCount <= 0)
      return;

    const centerIndex =
      state.panStartVisibleIndex + state.panStartVisibleCount / 2;
    const scaleFactor = Math.pow(
      2,
      (deltaX / chartWidth) * config.X_AXIS_DRAG_SENSITIVITY
    );

    let newVisibleCount = Math.round(state.panStartVisibleCount * scaleFactor);
    // Clamp new count: min candles, max data length * factor, max total data length
    newVisibleCount = Math.max(config.MIN_VISIBLE_CANDLES, newVisibleCount);
    newVisibleCount = Math.min(newVisibleCount, state.fullData.length * 5); // Limit zoom out
    newVisibleCount = Math.min(newVisibleCount, state.fullData.length); // Cannot show more than exist

    let newStartIndex = Math.round(centerIndex - newVisibleCount / 2);

    // Clamp start/end indices
    newStartIndex = Math.max(0, newStartIndex);
    let newEndIndex = newStartIndex + newVisibleCount;
    if (newEndIndex > state.fullData.length) {
      newEndIndex = state.fullData.length;
      newStartIndex = Math.max(0, newEndIndex - newVisibleCount);
    }
    newStartIndex = Math.max(0, newStartIndex); // Final start clamp

    // Check if indices changed
    if (
      newStartIndex !== state.visibleStartIndex ||
      newEndIndex !== state.visibleEndIndex
    ) {
      newState.visibleStartIndex = newStartIndex;
      newState.visibleEndIndex = newEndIndex;
      needsRedraw = true;
    }
  }
  // --- Chart Panning ---
  else if (state.isPanning) {
    const deltaX = event.clientX - state.panStartX;
    const deltaY = event.clientY - state.panStartY;
    if (!chartWidth || !chartHeight || chartWidth <= 0 || chartHeight <= 0)
      return;

    let changedX = false;
    let changedY = false;

    // Pan X (Time)
    if (state.panStartVisibleCount > 0) {
      const indexDelta = (deltaX / chartWidth) * state.panStartVisibleCount;
      let newStartIndex = state.panStartVisibleIndex - Math.round(indexDelta);

      // Clamp panning within data bounds [0, N - visibleCount]
      const maxStartIndex = state.fullData.length - state.panStartVisibleCount;
      newStartIndex = Math.max(0, Math.min(newStartIndex, maxStartIndex));

      if (newStartIndex !== state.visibleStartIndex) {
        newState.visibleStartIndex = newStartIndex;
        newState.visibleEndIndex = newStartIndex + state.panStartVisibleCount;
        changedX = true;
      }
    }

    // Pan Y (Price)
    if (state.isLogScale) {
      const logMinStart = safeLog(state.panStartMinPrice);
      const logMaxStart = safeLog(state.panStartMaxPrice);
      const logRangeStart = logMaxStart - logMinStart;

      if (logRangeStart > 0 && Number.isFinite(logRangeStart)) {
        const logDelta = (deltaY / chartHeight) * logRangeStart;
        const newLogMin = logMinStart + logDelta;
        const newLogMax = logMaxStart + logDelta;

        const newMin = Math.max(MIN_LOG_VALUE, exp(newLogMin));
        const newMax = exp(newLogMax);

        // Check for significant change
        if (
          Math.abs(newMin - state.minVisiblePrice) > 1e-9 ||
          Math.abs(newMax - state.maxVisiblePrice) > 1e-9
        ) {
          newState.minVisiblePrice = newMin;
          newState.maxVisiblePrice = newMax;
          changedY = true;
        }
      }
    } else {
      // Linear Scale Pan Y
      const initialPriceRange = state.panStartMaxPrice - state.panStartMinPrice;
      if (initialPriceRange > 0 && Number.isFinite(initialPriceRange)) {
        const priceDelta = (deltaY / chartHeight) * initialPriceRange;
        const newMinPrice = state.panStartMinPrice + priceDelta;
        const newMaxPrice = state.panStartMaxPrice + priceDelta;

        // Check for significant change
        if (
          Math.abs(newMinPrice - state.minVisiblePrice) > 1e-9 ||
          Math.abs(newMaxPrice - state.maxVisiblePrice) > 1e-9
        ) {
          newState.minVisiblePrice = Math.max(0, newMinPrice); // Clamp min at 0
          newState.maxVisiblePrice = newMaxPrice;
          changedY = true;
        }
      }
    }
    needsRedraw = changedX || changedY;
  }

  // If changes occurred, update state and request redraw
  if (needsRedraw) {
    updateState({ ...newState, lastDrawTime: now });
    requestAnimationFrame(redrawChart);
  }
}

export function handleMouseDownChart(event) {
  // Only initiate panning if the click is directly on the chart area/wrapper
  // or potentially on grid lines, but NOT on axis labels or other controls within container
  const target = event.target;
  if (!dom.chartArea || !dom.chartWrapper || !dom.gridContainer) return;

  if (
    target === dom.chartArea ||
    target === dom.chartWrapper ||
    target === dom.gridContainer ||
    target.classList.contains("grid-line") ||
    target.classList.contains("candle")
  ) {
    updateState({
      isPanning: true,
      isDraggingYAxis: false,
      isDraggingXAxis: false,
      panStartX: event.clientX,
      panStartY: event.clientY,
      panStartVisibleIndex: state.visibleStartIndex,
      panStartMinPrice: state.minVisiblePrice,
      panStartMaxPrice: state.maxVisiblePrice,
      panStartVisibleCount: state.visibleEndIndex - state.visibleStartIndex,
    });
    if (dom.chartContainer) dom.chartContainer.classList.add("panning");
  } else {
    // If click wasn't on a pannable element, ensure panning state is false
    if (state.isPanning) {
      updateState({ isPanning: false });
      if (dom.chartContainer) dom.chartContainer.classList.remove("panning");
    }
  }
}

export function handleMouseDownYAxis(event) {
  event.stopPropagation(); // Prevent chart panning
  updateState({
    isDraggingYAxis: true,
    isPanning: false,
    isDraggingXAxis: false,
    panStartY: event.clientY,
    panStartMinPrice: state.minVisiblePrice,
    panStartMaxPrice: state.maxVisiblePrice,
    // No need for X axis pan start info here
  });
}

export function handleMouseDownXAxis(event) {
  event.stopPropagation(); // Prevent chart panning
  updateState({
    isDraggingXAxis: true,
    isPanning: false,
    isDraggingYAxis: false,
    panStartX: event.clientX,
    panStartVisibleIndex: state.visibleStartIndex,
    panStartVisibleCount: state.visibleEndIndex - state.visibleStartIndex,
    // No need for Y axis pan start info here
  });
}

export function handleMouseUpOrLeave(event) {
  // This handles mouseup anywhere on the window or leaving the window
  if (state.isPanning || state.isDraggingYAxis || state.isDraggingXAxis) {
    updateState({
      isPanning: false,
      isDraggingYAxis: false,
      isDraggingXAxis: false,
    });
    if (dom.chartContainer) dom.chartContainer.classList.remove("panning");
  }
  // Note: handleMouseLeaveChartArea handles leaving the specific chart drawing area
  // for hiding tooltips/crosshairs. This handler is for drag/pan state globally.
}

let resizeTimeout;
export function handleResize() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    // Redrawing handles canvas resizing internally now
    requestAnimationFrame(redrawChart);
  }, config.DEBOUNCE_DELAY);
}

// --- Double Click Handler with Dynamic Y-Axis Scaling ---
export function handleDoubleClick(event) {
  if (!state.fullData.length || !dom.chartArea) return;
  const chartHeight = dom.chartArea.offsetHeight;
  if (!chartHeight || chartHeight <= 0) return; // Need height for scaling

  // --- Reset X-Axis (Time) ---
  const totalDataCount = state.fullData.length;
  let newVisibleCount = Math.min(
    config.DEFAULT_RESET_CANDLE_COUNT,
    totalDataCount
  );
  let newEndIndex = totalDataCount; // Show up to the latest candle
  let newStartIndex = Math.max(0, newEndIndex - newVisibleCount);
  newVisibleCount = newEndIndex - newStartIndex; // Recalculate actual count

  // --- Find Actual Data Range (Y-Axis) in the New Time Window ---
  let newMinY = Infinity,
    newMaxY = -Infinity;
  for (let i = newStartIndex; i < newEndIndex; i++) {
    if (!state.fullData[i] || state.fullData[i].length < 5) continue;
    const low = state.fullData[i][1];
    const high = state.fullData[i][2];
    if (!isNaN(low) && Number.isFinite(low)) {
      newMinY = Math.min(newMinY, low);
    }
    if (!isNaN(high) && Number.isFinite(high)) {
      newMaxY = Math.max(newMaxY, high);
    }
  }

  // Handle cases where range couldn't be determined or is invalid
  let dataRangeY;
  const minValidRange = 1e-9; // A very small number to represent effectively zero range

  if (
    newMinY === Infinity ||
    newMaxY === -Infinity ||
    newMaxY - newMinY < minValidRange
  ) {
    console.warn(
      "Could not determine valid price range for reset view or range too small, using fallback."
    );
    // Center around last price or a default value
    const lastCandle = state.fullData[state.fullData.length - 1];
    const centerPrice =
      lastCandle && lastCandle.length >= 5 && Number.isFinite(lastCandle[4])
        ? lastCandle[4]
        : (state.minVisiblePrice + state.maxVisiblePrice) / 2 || 100;

    // Use a small default span based on scale type
    if (state.isLogScale) {
      newMinY = Math.max(MIN_LOG_VALUE, centerPrice / 1.01); // +/- 1%
      newMaxY = centerPrice * 1.01;
    } else {
      const halfSpan = config.MIN_PRICE_RANGE_SPAN / 2 || 0.05;
      newMinY = Math.max(0, centerPrice - halfSpan);
      newMaxY = centerPrice + halfSpan;
    }
    dataRangeY = newMaxY - newMinY; // Recalculate data range for fallback
    if (dataRangeY < minValidRange) dataRangeY = minValidRange; // Ensure positive range
  } else {
    dataRangeY = newMaxY - newMinY;
  }

  // Ensure minimums are positive for log scale calculations
  newMinY = Math.max(MIN_LOG_VALUE, newMinY);
  newMaxY = Math.max(newMinY + minValidRange, newMaxY); // Ensure max > min

  // --- Calculate Required Total Y-Range for Target Fill ---
  let newMinPrice, newMaxPrice;
  const targetFill = config.Y_AXIS_RESET_FILL_FACTOR; // e.g., 0.85
  const inverseFill = 1.0 / targetFill;

  if (state.isLogScale) {
    // Log Scale Calculation
    const safeMinY = Math.max(MIN_LOG_VALUE, newMinY);
    const safeMaxY = Math.max(safeMinY * 1.0001, newMaxY); // Ensure Max > Min slightly

    const logDataRangeY = safeLog(safeMaxY) - safeLog(safeMinY);

    if (!Number.isFinite(logDataRangeY) || logDataRangeY <= 0) {
      // Fallback if log range calculation fails
      console.warn(
        "Log range calculation failed in reset, using simple padding."
      );
      const logPadding = 1 + config.Y_AXIS_LOG_PADDING_FACTOR;
      newMinPrice = Math.max(MIN_LOG_VALUE, safeMinY / logPadding);
      newMaxPrice = safeMaxY * logPadding;
    } else {
      const logTotalRange = logDataRangeY * inverseFill;
      const logPaddingTotal = logTotalRange - logDataRangeY;
      const logPaddingAmount = logPaddingTotal / 2.0;

      const newLogMin = safeLog(safeMinY) - logPaddingAmount;
      const newLogMax = safeLog(safeMaxY) + logPaddingAmount;

      newMinPrice = Math.max(MIN_LOG_VALUE, exp(newLogMin));
      newMaxPrice = exp(newLogMax);

      // Ensure minimum range ratio after calculation
      if (newMaxPrice / newMinPrice < 1.01) {
        const midLog = (newLogMax + newLogMin) / 2;
        const halfRangeLog = Math.log(1.005);
        newMinPrice = Math.max(MIN_LOG_VALUE, exp(midLog - halfRangeLog));
        newMaxPrice = exp(midLog + halfRangeLog);
      }
    }
  } else {
    // Linear Scale Calculation
    if (dataRangeY <= 0) {
      // Should be handled by fallback above, but double check
      console.warn("Linear range is zero in reset, using simple padding.");
      const halfSpan = config.MIN_PRICE_RANGE_SPAN / 2 || 0.05;
      newMinPrice = Math.max(0, newMinY - halfSpan);
      newMaxPrice = newMaxY + halfSpan;
    } else {
      const totalRange = dataRangeY * inverseFill;
      const paddingTotal = totalRange - dataRangeY;
      const paddingAmount = paddingTotal / 2.0;

      newMinPrice = Math.max(0, newMinY - paddingAmount); // Clamp at 0
      newMaxPrice = newMaxY + paddingAmount;

      // Ensure minimum linear range span
      if (newMaxPrice - newMinPrice < config.MIN_PRICE_RANGE_SPAN) {
        const mid = (newMaxPrice + newMinPrice) / 2;
        newMinPrice = Math.max(0, mid - config.MIN_PRICE_RANGE_SPAN / 2);
        newMaxPrice = mid + config.MIN_PRICE_RANGE_SPAN / 2;
      }
    }
  }

  // Update state with new X and Y ranges
  updateState({
    visibleStartIndex: newStartIndex,
    visibleEndIndex: newEndIndex,
    minVisiblePrice: newMinPrice,
    maxVisiblePrice: newMaxPrice,
    // DO NOT reset isLogScale or is12HourFormat here
  });

  // Request redraw with the new state
  requestAnimationFrame(redrawChart);
}
// --- End of Double Click Handler ---

export function handleLogScaleToggle() {
  const isChecked = dom.logScaleToggle.checked;
  updateState({ isLogScale: isChecked });
  localStorage.setItem("logScalePref", isChecked.toString());
  // Recalculate Y range based on the center price of the *current* view
  // to make the transition smoother.
  const centerY = dom.chartArea.offsetHeight / 2;
  const centerPrice = getPriceFromYCoordinate(
    centerY,
    dom.chartArea.offsetHeight
  );

  if (centerPrice !== null && Number.isFinite(centerPrice)) {
    const currentMin = state.minVisiblePrice;
    const currentMax = state.maxVisiblePrice;
    let newMin, newMax;

    if (isChecked) {
      // Switching TO Log
      const linearRange = currentMax - currentMin;
      const logCenter = safeLog(centerPrice);
      // Estimate equivalent log range (this is approximate)
      const logRangeEstimate = safeLog(currentMax) - safeLog(currentMin); // Use current log range

      if (Number.isFinite(logRangeEstimate) && logRangeEstimate > 0) {
        const halfLogRange = logRangeEstimate / 2;
        newMin = Math.max(MIN_LOG_VALUE, exp(logCenter - halfLogRange));
        newMax = exp(logCenter + halfLogRange);
      } else {
        // Fallback if range fails
        newMin = Math.max(MIN_LOG_VALUE, centerPrice / 1.1);
        newMax = centerPrice * 1.1;
      }
      // Ensure min log ratio
      if (newMax / newMin < 1.01) {
        const midLog = (safeLog(newMax) + safeLog(newMin)) / 2;
        newMin = Math.max(MIN_LOG_VALUE, exp(midLog - Math.log(1.005)));
        newMax = exp(midLog + Math.log(1.005));
      }
    } else {
      // Switching TO Linear
      const logRange = safeLog(currentMax) - safeLog(currentMin);
      // Estimate equivalent linear range based on center price (approximate)
      const linearRatio = currentMax / currentMin; // Ratio
      const linearRangeEstimate = centerPrice * (linearRatio - 1); // Very rough estimate
      let halfLinearRange = linearRangeEstimate / 2;

      // Use a more stable fallback if estimate is bad
      if (
        !Number.isFinite(halfLinearRange) ||
        halfLinearRange <= config.MIN_PRICE_RANGE_SPAN / 2
      ) {
        halfLinearRange =
          (currentMax - currentMin) / 2 || config.MIN_PRICE_RANGE_SPAN; // Use current linear diff or default
      }
      halfLinearRange = Math.max(
        config.MIN_PRICE_RANGE_SPAN / 2,
        halfLinearRange
      );

      newMin = Math.max(0, centerPrice - halfLinearRange);
      newMax = centerPrice + halfLinearRange;
      // Ensure min linear span
      if (newMax - newMin < config.MIN_PRICE_RANGE_SPAN) {
        const mid = (newMax + newMin) / 2;
        newMin = Math.max(0, mid - config.MIN_PRICE_RANGE_SPAN / 2);
        newMax = mid + config.MIN_PRICE_RANGE_SPAN / 2;
      }
    }

    updateState({ minVisiblePrice: newMin, maxVisiblePrice: newMax });
  } else {
    console.warn("Could not get center price for scale toggle adjustment.");
  }

  requestAnimationFrame(redrawChart);
}

export function handleTimeFormatToggle() {
  const isChecked = dom.timeFormatToggle.checked;
  updateState({ is12HourFormat: isChecked });
  localStorage.setItem("timeFormatPref", isChecked.toString());
  requestAnimationFrame(redrawChart); // Redraw to update X-axis labels
}

// --- Attach Listeners ---
export function attachInteractionListeners() {
  if (
    !dom.chartContainer ||
    !dom.yAxisLabelsContainer ||
    !dom.xAxisLabelsContainer ||
    !dom.chartArea
  ) {
    console.error(
      "Cannot attach interaction listeners: Essential chart DOM elements missing."
    );
    return;
  }

  // Chart container handles wheel (zoom), main panning mousedown, and double click reset
  dom.chartContainer.addEventListener("wheel", handleZoom, { passive: false });
  dom.chartContainer.addEventListener("mousedown", handleMouseDownChart);
  dom.chartContainer.addEventListener("dblclick", handleDoubleClick);

  // Axis labels handle scaling mousedown
  dom.yAxisLabelsContainer.addEventListener("mousedown", handleMouseDownYAxis);
  dom.xAxisLabelsContainer.addEventListener("mousedown", handleMouseDownXAxis);

  // Window handles mouse move (for drag/pan/scale) and mouseup (to end actions)
  window.addEventListener("mousemove", handleMouseMove);
  window.addEventListener("mouseup", handleMouseUpOrLeave);
  window.addEventListener("mouseleave", handleMouseUpOrLeave); // Handle mouse leaving window during drag

  // Window handles resize
  window.addEventListener("resize", handleResize);

  // Chart area handles mouse move and leave specifically for tooltips/crosshairs
  dom.chartArea.addEventListener("mousemove", handleMouseMoveForTooltip);
  dom.chartArea.addEventListener("mouseleave", handleMouseLeaveChartArea);

  // Settings toggles
  if (dom.logScaleToggle) {
    dom.logScaleToggle.addEventListener("change", handleLogScaleToggle);
  } else {
    console.warn("Log scale toggle checkbox not found.");
  }

  if (dom.timeFormatToggle) {
    dom.timeFormatToggle.addEventListener("change", handleTimeFormatToggle);
  } else {
    console.warn("Time format toggle checkbox not found.");
  }

  console.log("Chart interaction listeners attached.");
}

```
--- END FILE: js/interactions.js ---


--- START FILE: js/layout.js ---
```js
// js/layout.js
import * as dom from "./domElements.js";
import { redrawChart } from "./drawing.js"; // To redraw chart after pane resize

let isResizing = false;
let startY, startChartHeight, startBottomHeight;

// Constants from CSS (or define here)
const MIN_PANE_HEIGHT_PX = 100;
const RESIZER_HEIGHT_PX = 6;
const INITIAL_CHART_FLEX_BASIS = "67%"; // Keep initial percentages
const INITIAL_BOTTOM_FLEX_BASIS = "33%"; // Keep initial percentages

/**
 * Resets the pane heights to their initial percentage basis.
 */
function resetPaneHeights() {
  if (dom.chartPane && dom.bottomPane) {
    console.log("Resetting pane heights to initial percentages.");
    dom.chartPane.style.flexBasis = INITIAL_CHART_FLEX_BASIS;
    dom.bottomPane.style.flexBasis = INITIAL_BOTTOM_FLEX_BASIS;

    // We need to redraw the chart after the layout adjusts
    // Use a short timeout to allow the browser to recalculate layout first
    setTimeout(() => {
      requestAnimationFrame(redrawChart);
    }, 0);
  } else {
    console.error("Cannot reset pane heights: Pane elements not found.");
  }
}

function handleMouseDownResize(event) {
  event.preventDefault();
  isResizing = true;
  startY = event.clientY;

  // Get initial heights in pixels at the start of the drag
  startChartHeight = dom.chartPane.offsetHeight;
  startBottomHeight = dom.bottomPane.offsetHeight;

  document.body.classList.add("resizing");

  window.addEventListener("mousemove", handleMouseMoveResize);
  window.addEventListener("mouseup", handleMouseUpResize);
}

function handleMouseMoveResize(event) {
  if (!isResizing) return;

  const deltaY = event.clientY - startY;

  let newChartHeight = startChartHeight + deltaY;
  let newBottomHeight = startBottomHeight - deltaY;

  const totalPaneHeight = startChartHeight + startBottomHeight;

  // Enforce minimum heights
  if (newChartHeight < MIN_PANE_HEIGHT_PX) {
    newChartHeight = MIN_PANE_HEIGHT_PX;
    newBottomHeight = totalPaneHeight - newChartHeight;
  }
  if (newBottomHeight < MIN_PANE_HEIGHT_PX) {
    newBottomHeight = MIN_PANE_HEIGHT_PX;
    newChartHeight = totalPaneHeight - newBottomHeight;
  }
  if (newChartHeight < MIN_PANE_HEIGHT_PX) newChartHeight = MIN_PANE_HEIGHT_PX;

  // Apply new heights using flex-basis (pixels provide stability during drag)
  dom.chartPane.style.flexBasis = `${newChartHeight}px`;
  dom.bottomPane.style.flexBasis = `${newBottomHeight}px`;

  requestAnimationFrame(redrawChart);
}

function handleMouseUpResize() {
  if (isResizing) {
    isResizing = false;
    document.body.classList.remove("resizing");

    window.removeEventListener("mousemove", handleMouseMoveResize);
    window.removeEventListener("mouseup", handleMouseUpResize);
  }
}

/**
 * Handles the double-click event on the resizer.
 */
function handleDoubleClickResize(event) {
  event.preventDefault(); // Prevent any default dblclick behavior
  resetPaneHeights();
}

export function initializeResizer() {
  // Use the dom reference directly
  const resizer = dom.resizer;

  if (resizer && dom.chartPane && dom.bottomPane && dom.contentArea) {
    // Set initial heights using percentages
    dom.chartPane.style.flexBasis = INITIAL_CHART_FLEX_BASIS;
    dom.bottomPane.style.flexBasis = INITIAL_BOTTOM_FLEX_BASIS;
    console.log(
      `Initial flex-basis set to approx ${INITIAL_CHART_FLEX_BASIS}/${INITIAL_BOTTOM_FLEX_BASIS}`
    );

    // Attach mousedown listener for dragging
    resizer.addEventListener("mousedown", handleMouseDownResize);

    // Attach dblclick listener for resetting *** NEW ***
    resizer.addEventListener("dblclick", handleDoubleClickResize);

    console.log("Resizer initialized with drag and double-click reset.");

    // Removed the optional pixel update timeout as resetting to percentage works well
  } else {
    console.error(
      "Resizer initialization failed: Resizer, chartPane, or bottomPane not found in DOM."
    );
    if (!resizer) console.error("- Resizer missing");
    if (!dom.chartPane) console.error("- Chart Pane missing");
    if (!dom.bottomPane) console.error("- Bottom Pane missing");
    if (!dom.contentArea) console.error("- Content Area missing");
  }
}

```
--- END FILE: js/layout.js ---


--- START FILE: js/liveUpdate.js ---
```js
// js/liveUpdate.js

import state, { updateState, updateLatestPrice } from "./state.js"; // Import state functions
import { redrawChart } from "./drawing.js";
import { updateBalanceValuesUI } from "./balance.js"; // Import the new balance update function
import * as config from "./config.js";
import { getYCoordinate } from "./utils.js"; // Import shared utility
import * as dom from "./domElements.js"; // Import DOM elements

let ws = null;
let chartRedrawTimeout = null;
let balanceUpdateTimeout = null; // <<<--- ADDED: Timeout ID for balance updates
const CHART_REDRAW_THROTTLE_MS = 250;
const BALANCE_UPDATE_THROTTLE_MS = 1500; // <<<--- ADDED: Throttle delay for balances (e.g., 1.5 seconds)

const WEBSOCKET_URL = "wss://ws-feed.exchange.coinbase.com";
let currentProductId = config.DEFAULT_PRODUCT_ID; // Track main chart product ID

/**
 * Updates the UI for the live price indicator.
 * @param {number} price - The current price.
 */
function updateLivePriceIndicatorUI(price) {
  if (!dom.currentPriceLabel || !dom.currentPriceLine || isNaN(price)) {
    if (dom.currentPriceLabel) dom.currentPriceLabel.style.display = "none";
    if (dom.currentPriceLine) dom.currentPriceLine.style.display = "none";
    return;
  }
  const chartHeight = dom.chartArea?.offsetHeight; // Use optional chaining
  if (!chartHeight) return;
  const y = getYCoordinate(price, chartHeight); // Use utility

  if (y !== null && !isNaN(y)) {
    const decimals = price < 1 ? 4 : price < 100 ? 2 : price < 10000 ? 1 : 0;
    dom.currentPriceLabel.textContent = price.toFixed(decimals);
    dom.currentPriceLabel.style.top = `${y.toFixed(1)}px`;
    dom.currentPriceLine.style.top = `${y.toFixed(1)}px`;
    dom.currentPriceLabel.style.display = "block";
    dom.currentPriceLine.style.display = "block";
  } else {
    dom.currentPriceLabel.style.display = "none";
    dom.currentPriceLine.style.display = "none";
  }
}

function connectWebSocket() {
  // Use the product ID currently shown on the chart for the primary WS subscription
  const productIdToSubscribe =
    state.currentProductId || config.DEFAULT_PRODUCT_ID; // Use state or fallback
  console.log(
    `Attempting WS connect: ${WEBSOCKET_URL} for ${productIdToSubscribe}`
  );

  if (
    ws &&
    ws.readyState !== WebSocket.CLOSED &&
    ws.readyState !== WebSocket.CLOSING
  ) {
    console.log("Closing existing WebSocket connection.");
    ws.close(1000, "Reconnecting");
  }
  ws = null; // Clear previous instance

  // Clear any pending timeouts
  if (chartRedrawTimeout) clearTimeout(chartRedrawTimeout);
  if (balanceUpdateTimeout) clearTimeout(balanceUpdateTimeout);
  chartRedrawTimeout = null;
  balanceUpdateTimeout = null;

  ws = new WebSocket(WEBSOCKET_URL);

  ws.onopen = () => {
    console.log(`WS connected for ${productIdToSubscribe}. Subscribing...`);
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(
        JSON.stringify({
          type: "subscribe",
          product_ids: [productIdToSubscribe], // Subscribe only to the main chart's product ID
          channels: ["ticker"], // Only need ticker for live updates
        })
      );
    } else {
      console.warn("WS opened but readyState is not OPEN. Cannot subscribe.");
    }
  };

  ws.onmessage = (event) => {
    // console.log("WS Raw:", event.data); // Uncomment for intense debugging
    try {
      const message = JSON.parse(event.data);

      if (message.type === "ticker" && message.price) {
        const price = parseFloat(message.price);
        const productId = message.product_id; // e.g., "BTC-USD"
        const currencyCode = productId ? productId.split("-")[0] : null; // e.g., "BTC"
        const tickerTime = message.time
          ? new Date(message.time).getTime() / 1000
          : null;

        // --- Update Global Price State ---
        if (currencyCode && !isNaN(price)) {
          updateLatestPrice(currencyCode, price); // Update the price in our global state map

          // --- Trigger Throttled Balance UI Update ---
          if (!balanceUpdateTimeout) {
            balanceUpdateTimeout = setTimeout(() => {
              updateBalanceValuesUI(); // Call the specific UI update function
              balanceUpdateTimeout = null; // Clear timeout ID
            }, BALANCE_UPDATE_THROTTLE_MS);
          }
        }

        // --- Update Chart (Only if message matches the chart's product ID) ---
        if (productId === productIdToSubscribe && !isNaN(price)) {
          updateState({ lastTickerPrice: price }); // Update chart-specific last ticker price
          updateLivePriceIndicatorUI(price); // Update indicator immediately

          // Update last candle logic (if applicable)
          if (tickerTime && state.fullData.length > 0) {
            const lastCandleIndex = state.fullData.length - 1;
            const lastCandle = state.fullData[lastCandleIndex];
            if (lastCandle && lastCandle.length >= 5) {
              // Need at least timestamp and prices
              const candleStartTime = lastCandle[0];
              const candleEndTime = candleStartTime + state.currentGranularity;

              if (tickerTime >= candleStartTime && tickerTime < candleEndTime) {
                let changed = false;
                // Update close price
                if (lastCandle[4] !== price) {
                  lastCandle[4] = price;
                  changed = true;
                }
                // Update high price
                if (price > lastCandle[2]) {
                  lastCandle[2] = price;
                  changed = true;
                }
                // Update low price
                if (price < lastCandle[1]) {
                  lastCandle[1] = price;
                  changed = true;
                }

                // Trigger throttled chart redraw if data changed
                if (changed && !chartRedrawTimeout) {
                  chartRedrawTimeout = setTimeout(() => {
                    requestAnimationFrame(redrawChart);
                    chartRedrawTimeout = null;
                  }, CHART_REDRAW_THROTTLE_MS);
                }
              }
            }
          }
        }
      } else if (message.type === "subscriptions") {
        console.log("WS Subscriptions:", message.channels);
      } else if (message.type === "error") {
        console.error("WS Error Msg:", message.message);
      }
    } catch (error) {
      console.error("Error processing WS msg:", error, event.data);
    }
  };

  ws.onerror = (error) => {
    console.error("WS Error Event:", error);
  };

  ws.onclose = (event) => {
    console.log(
      `WS closed. Code: ${event.code}, Reason: ${
        event.reason || "(No reason provided)"
      }, Clean: ${event.wasClean}`
    );
    ws = null;
    // Clear any pending timeouts on close
    if (chartRedrawTimeout) clearTimeout(chartRedrawTimeout);
    if (balanceUpdateTimeout) clearTimeout(balanceUpdateTimeout);
    chartRedrawTimeout = null;
    balanceUpdateTimeout = null;

    // Hide price indicator
    if (dom.currentPriceLabel) dom.currentPriceLabel.style.display = "none";
    if (dom.currentPriceLine) dom.currentPriceLine.style.display = "none";
    updateState({ lastTickerPrice: null });

    // Optional: Reconnect logic (only if not closed intentionally)
    if (event.code !== 1000) {
      // 1000 = Normal closure
      console.log("Attempting WS reconnect in 5s...");
      setTimeout(connectWebSocket, 5000);
    }
  };
}

// Initialize or Reconnect WebSocket for the main chart product
export function initializeWebSocket(productId = config.DEFAULT_PRODUCT_ID) {
  currentProductId = productId; // Update the tracked product ID
  connectWebSocket(); // Connect/reconnect using the current product ID
}

// Close WebSocket connection manually
export function closeWebSocket() {
  if (ws) {
    console.log("Closing WS manually.");
    // Clear timeouts before closing
    if (chartRedrawTimeout) clearTimeout(chartRedrawTimeout);
    if (balanceUpdateTimeout) clearTimeout(balanceUpdateTimeout);
    chartRedrawTimeout = null;
    balanceUpdateTimeout = null;
    ws.close(1000, "Client initiated closure"); // Use code 1000 for normal closure
    ws = null;
  }
  // UI cleanup might already happen in onclose, but can be done here too
  if (dom.currentPriceLabel) dom.currentPriceLabel.style.display = "none";
  if (dom.currentPriceLine) dom.currentPriceLine.style.display = "none";
  updateState({ lastTickerPrice: null });
}

// Function to update subscription if product ID changes (e.g., if user could select pairs later)
// NOTE: Currently we only subscribe to one product ID (the main chart's).
// If we needed live prices for ALL balances, we'd need to subscribe to multiple product_ids.
export function updateWebSocketSubscription(
  newProductId = config.DEFAULT_PRODUCT_ID
) {
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    console.log(`WS not open or ready, reconnecting for ${newProductId}.`);
    initializeWebSocket(newProductId); // Reconnect with the new product ID
    return;
  }

  if (newProductId !== currentProductId) {
    console.log(
      `Product change detected. Resubscribing from ${currentProductId} to ${newProductId}.`
    );
    // Unsubscribe from the old product ID
    ws.send(
      JSON.stringify({
        type: "unsubscribe",
        product_ids: [currentProductId],
        channels: ["ticker"],
      })
    );
    // Subscribe to the new product ID
    ws.send(
      JSON.stringify({
        type: "subscribe",
        product_ids: [newProductId],
        channels: ["ticker"],
      })
    );
    currentProductId = newProductId; // Update the tracked product ID
    updateState({ currentProductId: newProductId }); // Update state if needed elsewhere
  }
}

```
--- END FILE: js/liveUpdate.js ---


--- START FILE: js/main.js ---
```js
// js/main.js

import * as dom from "./domElements.js";
import state, { updateState } from "./state.js";
import * as config from "./config.js";
import { initializeTheme } from "./theme.js";
import { redrawChart } from "./drawing.js";
import { attachInteractionListeners } from "./interactions.js";
import {
  initializeWebSocket,
  closeWebSocket,
  updateWebSocketSubscription,
} from "./liveUpdate.js";
import { initializeBalances } from "./balance.js";
import { initializeResizer } from "./layout.js";
import { initializeSettingsMenu } from "./settingsMenu.js";
import { initializeTabs } from "./tabs.js";
import { initializePromptTab } from "./promptTab.js";
import { MIN_LOG_VALUE } from "./utils.js"; // <<<--- ENSURE IMPORT IS HERE
// import { initializeVolumeChart } from './volumeChart.js'; // Import volume chart initialization <-- COMMENTED OUT

// Define MIN_LOG_VALUE if not imported and needed locally
// const localMinLogValue = 1e-9; // <<<--- REMOVE LOCAL DEFINITION

// --- Status Indicator ---
function updateApiStatusIndicator(loaded, message = null) {
  if (!dom.apiStatusIndicator) return;
  dom.apiStatusIndicator.className = loaded ? "loaded" : "error";
  dom.apiStatusIndicator.textContent = message || (loaded ? "Loaded" : "Error");
}
function checkApiStatus() {
  if (!dom.apiStatusIndicator) return;
  dom.apiStatusIndicator.textContent = "Checking...";
  dom.apiStatusIndicator.className = "loading";
  fetch("http://localhost:5000/api/status")
    .then((response) => {
      if (!response.ok) {
        return response
          .json()
          .catch(() => {
            throw new Error(`HTTP error ${response.status}`);
          })
          .then((errData) => {
            throw new Error(errData.error || `HTTP error ${response.status}`);
          });
      }
      return response.json();
    })
    .then((data) => {
      if (data.credentials_loaded) {
        updateApiStatusIndicator(true);
      } else {
        updateApiStatusIndicator(false, "Creds Failed");
      }
    })
    .catch((error) => {
      console.error("Error checking API status:", error);
      updateApiStatusIndicator(false, "Unavailable");
    });
}

// --- Initialize Chart View State ---
function initializeChartView(data) {
  if (!data || !data.length) {
    console.warn("initializeChartView skipped: No data provided.");
    return;
  }

  // Determine if log scale preference is set
  const savedLogPref = localStorage.getItem("logScalePref") === "true";
  const savedTimeFormatPref = localStorage.getItem("timeFormatPref") === "true";

  const totalDataCount = data.length;
  const initialVisibleCount = Math.min(
    config.DEFAULT_RESET_CANDLE_COUNT,
    totalDataCount
  );
  const initialStartIndex = Math.max(0, totalDataCount - initialVisibleCount);
  const initialEndIndex = totalDataCount;

  // Find min/max low/high in the initial visible range
  let initialMinY = Infinity,
    initialMaxY = -Infinity;
  for (let i = initialStartIndex; i < initialEndIndex; i++) {
    if (!data[i] || data[i].length < 5) continue; // Need low[1] and high[2]
    const low = data[i][1];
    const high = data[i][2];
    if (!isNaN(low) && Number.isFinite(low)) {
      initialMinY = Math.min(initialMinY, low);
    }
    if (!isNaN(high) && Number.isFinite(high)) {
      initialMaxY = Math.max(initialMaxY, high);
    }
  }

  // Handle cases where min/max couldn't be determined
  if (
    initialMinY === Infinity ||
    initialMaxY === -Infinity ||
    initialMinY <= 0
  ) {
    // Try to get a fallback from the last candle's close price if available
    const lastCandle = data[data.length - 1];
    const lastClose =
      lastCandle && lastCandle.length >= 5 && Number.isFinite(lastCandle[4])
        ? lastCandle[4]
        : 100; // Default fallback
    initialMinY = lastClose * 0.9;
    initialMaxY = lastClose * 1.1;
    console.warn(
      "Could not determine initial Y range from visible data, using fallback range.",
      { initialMinY, initialMaxY }
    );
  }
  // Ensure min is positive for log scale calculations later
  initialMinY = Math.max(MIN_LOG_VALUE, initialMinY); // Use imported constant
  if (initialMaxY <= initialMinY) {
    initialMaxY = initialMinY * 1.1; // Ensure max > min
  }

  // --- Apply Padding based on Scale Type ---
  let initialMinPrice, initialMaxPrice;

  if (savedLogPref) {
    // Log Scale: Apply multiplicative padding
    const logPadding = 1 + config.Y_AXIS_LOG_PADDING_FACTOR;
    initialMinPrice = Math.max(MIN_LOG_VALUE, initialMinY / logPadding); // Use imported constant
    initialMaxPrice = initialMaxY * logPadding; // Multiply max by (1 + factor)

    // Ensure minimum range ratio for log scale
    if (initialMaxPrice / initialMinPrice < 1.01) {
      const midLog =
        (Math.log(initialMaxPrice) + Math.log(initialMinPrice)) / 2;
      const halfRangeLog = Math.log(1.005); // ~0.5% range
      initialMinPrice = Math.max(
        MIN_LOG_VALUE,
        Math.exp(midLog - halfRangeLog)
      ); // Use imported constant
      initialMaxPrice = Math.exp(midLog + halfRangeLog);
    }
  } else {
    // Linear Scale: Apply additive padding
    const linearPadding = Math.max(
      config.MIN_PRICE_RANGE_SPAN * 0.1, // Ensure padding is at least something
      (initialMaxY - initialMinY) * config.Y_AXIS_PRICE_PADDING_FACTOR
    );
    initialMinPrice = Math.max(0, initialMinY - linearPadding); // Cannot go below 0
    initialMaxPrice = initialMaxY + linearPadding;

    // Ensure minimum linear range span
    if (initialMaxPrice - initialMinPrice < config.MIN_PRICE_RANGE_SPAN) {
      const mid = (initialMaxPrice + initialMinPrice) / 2;
      initialMinPrice = Math.max(0, mid - config.MIN_PRICE_RANGE_SPAN / 2); // Clamp at 0
      initialMaxPrice = mid + config.MIN_PRICE_RANGE_SPAN / 2;
    }
  }

  // Update the global state
  updateState({
    visibleStartIndex: initialStartIndex,
    visibleEndIndex: initialEndIndex,
    minVisiblePrice: initialMinPrice,
    maxVisiblePrice: initialMaxPrice,
    isLogScale: savedLogPref,
    is12HourFormat: savedTimeFormatPref,
  });

  // Update UI toggles to match loaded state
  if (dom.logScaleToggle) dom.logScaleToggle.checked = savedLogPref;
  if (dom.timeFormatToggle) dom.timeFormatToggle.checked = savedTimeFormatPref;

  console.log("Initialized chart view state:", {
    startIndex: initialStartIndex,
    endIndex: initialEndIndex,
    minPrice: initialMinPrice,
    maxPrice: initialMaxPrice,
    isLog: savedLogPref,
  });
}

// --- Fetch/Redraw Chart Data ---
function fetchAndRedraw(granularitySeconds) {
  updateState({ currentGranularity: granularitySeconds });
  const currentProductID = config.DEFAULT_PRODUCT_ID; // Use default for now
  const apiUrl = `http://localhost:5000/api/candles?granularity=${granularitySeconds}&product_id=${currentProductID}`;
  console.log(
    `Fetching chart data for ${currentProductID} at ${granularitySeconds}s interval from: ${apiUrl}`
  );
  if (dom.chartMessage) {
    dom.chartMessage.textContent = `Loading ${currentProductID} ${Math.round(
      granularitySeconds / 60
    )}m data...`;
    dom.chartMessage.style.display = "block";
  }
  closeWebSocket(); // Close previous connection before fetching new data

  fetch(apiUrl)
    .then((response) => {
      if (!response.ok) {
        // Try to get error details from response body
        return response
          .json()
          .catch(() => ({
            // Fallback if body isn't JSON
            error: `HTTP error ${response.status} (${response.statusText})`,
            details: response.statusText,
          }))
          .then((errData) => {
            // Throw an error object with more info
            const error = new Error(
              errData.error || `API Error ${response.status}`
            );
            error.details = errData.details || `Status: ${response.status}`;
            throw error;
          });
      }
      return response.json();
    })
    .then((data) => {
      if (!Array.isArray(data)) {
        throw new Error("Invalid data format: API response was not an array.");
      }
      if (data.length === 0) {
        console.warn(
          `No chart data returned for ${currentProductID} at ${granularitySeconds}s interval.`
        );
        updateState({ fullData: [] }); // Clear data
        if (dom.chartMessage)
          dom.chartMessage.textContent = `No data available for this interval.`;
        redrawChart(); // Redraw empty chart
        return; // Stop processing
      }

      console.log(
        `Loaded ${data.length} chart data points for ${granularitySeconds}s interval.`
      );

      // Data Format: [timestamp, low, high, open, close, volume]
      // Ensure data is sorted oldest to newest (ascending timestamp)
      let processedData = data;
      if (data.length > 1 && data[0][0] > data[data.length - 1][0]) {
        console.warn("Chart data received newest-first. Reversing array.");
        processedData = data.slice().reverse(); // Create reversed copy
      } else {
        console.log("Chart data received oldest-first (expected).");
      }

      // Update state with the new, sorted data
      updateState({ fullData: processedData });

      // Set up the initial view based on the new data and preferences
      initializeChartView(processedData); // <<< THIS NOW HANDLES PADDING

      // Hide loading message and redraw
      if (dom.chartMessage) dom.chartMessage.style.display = "none";
      requestAnimationFrame(redrawChart);

      // Reconnect WebSocket for the current product ID
      initializeWebSocket(currentProductID);
    })
    .catch((error) => {
      console.error("Chart Data Fetch Error:", error);
      if (dom.chartMessage) {
        dom.chartMessage.textContent = `Error loading chart data: ${
          error.message
        }${error.details ? ` (${error.details})` : ""}`;
        dom.chartMessage.style.display = "block";
        dom.chartMessage.style.color = "red";
      }
      updateState({ fullData: [] }); // Clear data on error
      redrawChart(); // Redraw empty chart
    });
}

// --- Main Execution ---
document.addEventListener("DOMContentLoaded", () => {
  if (!dom.checkElements()) {
    console.error("Essential DOM elements missing. Aborting initialization.");
    // Maybe display a user-facing error message here
    document.body.innerHTML =
      '<div style="padding: 20px; text-align: center; color: red; font-size: 1.2em;">Error: Application cannot start. Required HTML elements are missing. Check the console for details.</div>';
    return;
  }

  initializeTheme();
  initializeSettingsMenu();
  initializeTabs("#bottom-tab-bar", ".tab-content-area");
  initializePromptTab();
  // initializeVolumeChart(); // Initialize the volume chart module <-- COMMENTED OUT
  attachInteractionListeners();
  initializeResizer();
  checkApiStatus(); // Check backend/credentials status
  initializeBalances(); // Fetch account balances

  // Setup Granularity Controls
  if (dom.granularityControls) {
    dom.granularityControls.addEventListener("click", (event) => {
      if (event.target.tagName === "BUTTON" && !event.target.disabled) {
        const newGranularity = parseInt(event.target.dataset.granularity, 10);
        if (
          !isNaN(newGranularity) &&
          newGranularity !== state.currentGranularity
        ) {
          // Update UI
          const currentActive =
            dom.granularityControls.querySelector("button.active");
          if (currentActive) currentActive.classList.remove("active");
          event.target.classList.add("active");

          // Fetch and redraw with new granularity
          fetchAndRedraw(newGranularity);
        }
      }
    });

    // Set initial active button based on default state granularity
    const initialActiveButton = dom.granularityControls.querySelector(
      `button[data-granularity="${state.currentGranularity}"]`
    );
    if (
      initialActiveButton &&
      !initialActiveButton.classList.contains("active")
    ) {
      // Ensure only one is active if the default wasn't marked initially
      const currentActive =
        dom.granularityControls.querySelector("button.active");
      if (currentActive) currentActive.classList.remove("active");
      initialActiveButton.classList.add("active");
    } else if (!initialActiveButton) {
      console.warn(
        `No granularity button found for default: ${state.currentGranularity}`
      );
      // Optionally activate the first button as a fallback
      const firstButton = dom.granularityControls.querySelector("button");
      if (firstButton) firstButton.classList.add("active");
    }
  } else {
    console.warn(
      "Granularity controls element (#granularity-controls) not found."
    );
  }

  // Initial data fetch
  fetchAndRedraw(state.currentGranularity);

  // Add cleanup for WebSocket on page unload
  window.addEventListener("beforeunload", () => {
    closeWebSocket(); // Use the specific function, no argument needed
  });

  console.log("GeminiTrader Frontend Initialized.");
});

```
--- END FILE: js/main.js ---


--- START FILE: js/promptTab.js ---
```js
// js/promptTab.js
import * as dom from "./domElements.js";

const STORAGE_KEY = "geminiTraderPromptText"; // Key for localStorage
const DEBOUNCE_DELAY = 300; // ms delay before saving after user stops typing

let saveTimeout = null;

/**
 * Saves the current content of the prompt textarea to localStorage.
 */
function savePromptText() {
  if (dom.promptTextarea) {
    try {
      localStorage.setItem(STORAGE_KEY, dom.promptTextarea.value);
      // console.log("Prompt text saved."); // Optional: for debugging
    } catch (error) {
      console.error("Error saving prompt text to localStorage:", error);
      // Handle potential storage errors (e.g., quota exceeded)
    }
  }
}

/**
 * Debounced version of the save function.
 */
function debouncedSavePromptText() {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(savePromptText, DEBOUNCE_DELAY);
}

/**
 * Loads saved prompt text from localStorage on initialization.
 */
function loadPromptText() {
  if (dom.promptTextarea) {
    try {
      const savedText = localStorage.getItem(STORAGE_KEY);
      if (savedText !== null) {
        // Check for null, empty string is valid
        dom.promptTextarea.value = savedText;
        console.log("Prompt text loaded from localStorage.");
      } else {
        console.log("No saved prompt text found in localStorage.");
      }
    } catch (error) {
      console.error("Error loading prompt text from localStorage:", error);
    }
  }
}

/**
 * Initializes the prompt tab functionality: loads saved text and sets up auto-saving.
 */
export function initializePromptTab() {
  if (!dom.promptTextarea) {
    console.warn(
      "Prompt textarea not found. Skipping prompt tab initialization."
    );
    return;
  }

  // Load any previously saved text
  loadPromptText();

  // Add event listener to save text on input (debounced)
  dom.promptTextarea.addEventListener("input", debouncedSavePromptText);

  console.log("Prompt tab initialized.");
}

```
--- END FILE: js/promptTab.js ---


--- START FILE: js/settingsMenu.js ---
```js
// js/settingsMenu.js
import * as dom from "./domElements.js";

/**
 * Initializes the settings dropdown menu functionality.
 */
export function initializeSettingsMenu() {
  // Check if elements exist right at the start
  if (!dom.settingsButton) {
    console.error("Settings Button (#settings-button) not found!");
    return;
  }
  if (!dom.settingsDropdown) {
    console.error("Settings Dropdown (#settings-dropdown) not found!");
    return;
  }
  console.log(
    "Settings menu elements found:",
    dom.settingsButton,
    dom.settingsDropdown
  ); // Log found elements

  // --- Toggle Dropdown on Button Click ---
  dom.settingsButton.addEventListener("click", (event) => {
    console.log("Settings button clicked."); // Log click
    event.stopPropagation(); // Prevent the window click listener from closing it immediately

    const isCurrentlyShown = dom.settingsDropdown.classList.contains("show");
    console.log(`Dropdown 'show' class before toggle: ${isCurrentlyShown}`);

    dom.settingsDropdown.classList.toggle("show");

    const isNowShown = dom.settingsDropdown.classList.contains("show");
    console.log(`Dropdown 'show' class after toggle: ${isNowShown}`); // Log state after toggle
  });

  // --- Close Dropdown on Click Outside ---
  window.addEventListener("click", (event) => {
    // Only run if the dropdown is currently shown
    if (dom.settingsDropdown.classList.contains("show")) {
      // Check if the click was outside the dropdown AND outside the button
      const clickedOutside =
        !dom.settingsDropdown.contains(event.target) &&
        !dom.settingsButton.contains(event.target);

      // console.log("Window clicked while dropdown is shown. Clicked outside:", clickedOutside); // Debug log

      if (clickedOutside) {
        console.log("Clicked outside, removing 'show' class."); // Log closing action
        dom.settingsDropdown.classList.remove("show");
      }
    }
  });

  console.log("Settings menu event listeners attached.");
}

```
--- END FILE: js/settingsMenu.js ---


--- START FILE: js/state.js ---
```js
// js/state.js
import * as config from "./config.js";

const chartState = {
  fullData: [],
  visibleStartIndex: 0,
  visibleEndIndex: 0,
  minVisiblePrice: 0,
  maxVisiblePrice: 1,
  isLogScale: false,
  currentGranularity: config.DEFAULT_GRANULARITY,
  is12HourFormat: false, // Default to 24-hour format
  isPanning: false,
  isDraggingYAxis: false,
  isDraggingXAxis: false,
  panStartX: 0,
  panStartY: 0,
  panStartVisibleIndex: 0,
  panStartVisibleCount: 0,
  panStartMinPrice: 0,
  panStartMaxPrice: 0,
  lastDrawTime: 0,
  lastTickerPrice: null, // Store last known ticker price (for main chart indicator)
  latestPrices: new Map(), // <<<--- ADDED: Map to store latest price for each asset { 'BTC': 65000.12, 'ETH': 3400.50, ... }
};

export function updateState(newState) {
  Object.assign(chartState, newState);
}
export function getState() {
  return { ...chartState };
}
// Helper to update a single price in the map
export function updateLatestPrice(currencyCode, price) {
  if (
    currencyCode &&
    typeof currencyCode === "string" &&
    price !== null &&
    Number.isFinite(price)
  ) {
    chartState.latestPrices.set(currencyCode.toUpperCase(), price);
    // console.log(`Updated price for ${currencyCode}: ${price}`); // Optional debug
  }
}

export default chartState;

```
--- END FILE: js/state.js ---


--- START FILE: js/tabs.js ---
```js
// js/tabs.js

/**
 * Initializes tab switching functionality for a given container.
 * @param {string} tabBarSelector - CSS selector for the tab bar container (e.g., '#bottom-tab-bar').
 * @param {string} contentAreaSelector - CSS selector for the area containing the tab content panes (e.g., '.tab-content-area').
 */
export function initializeTabs(tabBarSelector, contentAreaSelector) {
  const tabBar = document.querySelector(tabBarSelector);
  const contentArea = document.querySelector(contentAreaSelector);

  if (!tabBar) {
    console.error(
      `Tab initialization failed: Tab bar not found with selector "${tabBarSelector}"`
    );
    return;
  }
  if (!contentArea) {
    console.error(
      `Tab initialization failed: Content area not found with selector "${contentAreaSelector}"`
    );
    return;
  }

  const tabButtons = tabBar.querySelectorAll(".tab-button");
  const contentPanes = contentArea.querySelectorAll(".tab-content");

  if (tabButtons.length === 0 || contentPanes.length === 0) {
    console.warn(
      "Tab initialization: No tab buttons or content panes found within the specified containers."
    );
    return;
  }

  // Add click listener to the tab bar (event delegation)
  tabBar.addEventListener("click", (event) => {
    const clickedButton = event.target.closest(".tab-button");
    if (!clickedButton) {
      return; // Click was not on a button
    }

    const targetId = clickedButton.dataset.target;
    if (!targetId) {
      console.warn("Clicked tab button is missing 'data-target' attribute.");
      return;
    }

    const targetPane = contentArea.querySelector(`#${targetId}`);
    if (!targetPane) {
      console.warn(`Target content pane with ID "${targetId}" not found.`);
      return;
    }

    // --- Deactivate currently active elements ---
    const currentActiveButton = tabBar.querySelector(".tab-button.active");
    const currentActivePane = contentArea.querySelector(".tab-content.active");

    if (currentActiveButton) {
      currentActiveButton.classList.remove("active");
    }
    if (currentActivePane) {
      currentActivePane.classList.remove("active");
    }

    // --- Activate the new elements ---
    clickedButton.classList.add("active");
    targetPane.classList.add("active");

    console.log(`Switched tab to: ${targetId}`);

    // Optional: Trigger fetch/refresh logic when a tab becomes active
    // Example: if (targetId === 'open-orders-content') { fetchOpenOrders(); }
  });

  console.log(`Tabs initialized for container: ${tabBarSelector}`);
}

```
--- END FILE: js/tabs.js ---


--- START FILE: js/theme.js ---
```js
// js/theme.js
import { themeToggle } from "./domElements.js";

export function initializeTheme() {
  const userPrefersDark =
    window.matchMedia &&
    window.matchMedia("(prefers-color-scheme: dark)").matches;
  const currentTheme = localStorage.getItem("theme");
  let theme = "light";
  if (currentTheme) {
    theme = currentTheme;
  } else if (userPrefersDark) {
    theme = "dark";
  }
  document.documentElement.setAttribute("data-theme", theme);
  if (themeToggle && theme === "dark") {
    themeToggle.checked = true;
  }
  if (themeToggle) {
    themeToggle.addEventListener("change", function () {
      if (this.checked) {
        document.documentElement.setAttribute("data-theme", "dark");
        localStorage.setItem("theme", "dark");
      } else {
        document.documentElement.setAttribute("data-theme", "light");
        localStorage.setItem("theme", "light");
      }
    });
  }
  window
    .matchMedia("(prefers-color-scheme: dark)")
    .addEventListener("change", (e) => {
      if (!localStorage.getItem("theme")) {
        const newTheme = e.matches ? "dark" : "light";
        document.documentElement.setAttribute("data-theme", newTheme);
        if (themeToggle) themeToggle.checked = newTheme === "dark";
      }
    });
}

```
--- END FILE: js/theme.js ---


--- START FILE: js/utils.js ---
```js
// js/utils.js
import state from "./state.js";
import * as config from "./config.js"; // Import config for MIN_PRICE_RANGE_SPAN

export const MIN_LOG_VALUE = 1e-9; // <<<--- ADD export HERE
const MIN_LINEAR_RANGE_EPSILON = 1e-9; // Small value to check against zero range
const MIN_LOG_RANGE_EPSILON = 1e-9; // Small value for log range

export function getYCoordinate(price, chartHeight) {
  if (
    isNaN(price) ||
    isNaN(chartHeight) ||
    chartHeight <= 0 ||
    price < 0 // Allow price to be 0 on linear scale, but handle below
  ) {
    // console.warn("getYCoordinate: Invalid input price or chartHeight", { price, chartHeight });
    return null;
  }

  const { minVisiblePrice, maxVisiblePrice, isLogScale } = state;

  // Stricter validation of the visible price range
  if (
    isNaN(minVisiblePrice) ||
    isNaN(maxVisiblePrice) ||
    !Number.isFinite(minVisiblePrice) ||
    !Number.isFinite(maxVisiblePrice) ||
    maxVisiblePrice <= minVisiblePrice
  ) {
    // console.warn("getYCoordinate: Invalid visible price range in state", { minVisiblePrice, maxVisiblePrice });
    return null;
  }

  if (isLogScale) {
    const safeMinVisiblePrice = Math.max(MIN_LOG_VALUE, minVisiblePrice);
    const safeMaxVisiblePrice = Math.max(MIN_LOG_VALUE, maxVisiblePrice);
    // Ensure price itself is also treated as positive for log calculation
    const safePrice = Math.max(MIN_LOG_VALUE, price);

    if (safeMaxVisiblePrice <= safeMinVisiblePrice) return null; // Should be caught above, but double-check

    const logMin = Math.log(safeMinVisiblePrice);
    const logMax = Math.log(safeMaxVisiblePrice);
    const logPrice = Math.log(safePrice);

    if (
      !Number.isFinite(logMin) ||
      !Number.isFinite(logMax) ||
      !Number.isFinite(logPrice)
    ) {
      // console.warn("getYCoordinate (Log): Non-finite log value", { logMin, logMax, logPrice });
      return null;
    }

    const logRange = logMax - logMin;

    // Check for near-zero or invalid log range
    if (!Number.isFinite(logRange) || logRange < MIN_LOG_RANGE_EPSILON) {
      // If range is effectively zero, map based on comparison to min/max
      if (logPrice <= logMin) return chartHeight;
      if (logPrice >= logMax) return 0;
      return chartHeight / 2; // Fallback for prices within the zero range
    }

    const logScaleY = chartHeight / logRange;
    const yPos = chartHeight - (logPrice - logMin) * logScaleY;

    if (!Number.isFinite(yPos)) {
      // console.warn("getYCoordinate (Log): Calculated yPos is not finite", { price, yPos });
      return null;
    }
    return yPos;
  } else {
    // Linear Scale
    const priceRange = maxVisiblePrice - minVisiblePrice;

    // Check for near-zero or invalid linear range
    if (!Number.isFinite(priceRange) || priceRange < MIN_LINEAR_RANGE_EPSILON) {
      // If range is effectively zero, map based on comparison to min/max
      if (price <= minVisiblePrice) return chartHeight;
      if (price >= maxVisiblePrice) return 0;
      return chartHeight / 2; // Fallback for prices within the zero range
    }

    const scaleY = chartHeight / priceRange;
    const yPos = chartHeight - (price - minVisiblePrice) * scaleY;

    if (!Number.isFinite(yPos)) {
      // console.warn("getYCoordinate (Linear): Calculated yPos is not finite", { price, yPos });
      return null;
    }
    // Let drawing clip if needed, just ensure it's finite
    return yPos;
  }
}

export function getPriceFromYCoordinate(yPos, chartHeight) {
  if (isNaN(yPos) || isNaN(chartHeight) || chartHeight <= 0) return null;

  const { minVisiblePrice, maxVisiblePrice, isLogScale } = state;

  // Stricter validation of the visible price range
  if (
    isNaN(minVisiblePrice) ||
    isNaN(maxVisiblePrice) ||
    !Number.isFinite(minVisiblePrice) ||
    !Number.isFinite(maxVisiblePrice) ||
    maxVisiblePrice <= minVisiblePrice
  ) {
    // console.warn("getPriceFromYCoordinate: Invalid visible price range", { minVisiblePrice, maxVisiblePrice });
    return null;
  }

  // Clamp Y position to chart boundaries before calculation
  const clampedYPos = Math.max(0, Math.min(yPos, chartHeight));
  const fraction = (chartHeight - clampedYPos) / chartHeight; // Fraction from bottom (0) to top (1)

  if (isLogScale) {
    const safeMinVisiblePrice = Math.max(MIN_LOG_VALUE, minVisiblePrice);
    const safeMaxVisiblePrice = Math.max(MIN_LOG_VALUE, maxVisiblePrice);

    if (safeMaxVisiblePrice <= safeMinVisiblePrice) return safeMinVisiblePrice;

    const logMin = Math.log(safeMinVisiblePrice);
    const logMax = Math.log(safeMaxVisiblePrice);

    if (!Number.isFinite(logMin) || !Number.isFinite(logMax)) return null;

    const logRange = logMax - logMin;

    if (!Number.isFinite(logRange) || logRange < MIN_LOG_RANGE_EPSILON) {
      // If range is negligible, return the min price
      return safeMinVisiblePrice;
    }

    const logPrice = logMin + fraction * logRange;
    const price = Math.exp(logPrice);

    // Ensure result is finite
    return Number.isFinite(price) ? price : null;
  } else {
    // Linear Scale
    const priceRange = maxVisiblePrice - minVisiblePrice;

    if (!Number.isFinite(priceRange) || priceRange < MIN_LINEAR_RANGE_EPSILON) {
      // If range is negligible, return the min price
      return minVisiblePrice;
    }

    const price = minVisiblePrice + fraction * priceRange;

    // Ensure price is not negative and is finite
    return Number.isFinite(price) ? Math.max(0, price) : null;
  }
}

export function calculateNiceStep(range, maxTicks) {
  if (
    isNaN(range) ||
    range <= 0 ||
    isNaN(maxTicks) ||
    maxTicks <= 0 ||
    !Number.isFinite(range)
  ) {
    return 1; // Return a default step if input is invalid
  }

  const roughStep = range / Math.max(1, maxTicks);
  if (roughStep <= 0 || isNaN(roughStep) || !Number.isFinite(roughStep)) {
    return 1; // Default if rough step calculation fails
  }

  // Handle extremely small rough steps that might cause log10 issues
  if (roughStep < Number.EPSILON) {
    return Number.EPSILON * 10;
  }

  const magnitude = Math.pow(10, Math.floor(Math.log10(roughStep)));
  if (magnitude <= 0 || !Number.isFinite(magnitude)) {
    // Fallback if magnitude calculation fails (e.g., extremely large range)
    return roughStep > 1 ? roughStep : 1;
  }

  const residual = roughStep / magnitude;

  let niceStep;
  if (residual > 5) niceStep = 10 * magnitude;
  else if (residual > 2) niceStep = 5 * magnitude;
  else if (residual > 1) niceStep = 2 * magnitude;
  else niceStep = magnitude;

  // Ensure the step is a reasonably small fraction of the range if range is tiny
  // and also ensure it's at least a minimum value to prevent near-zero steps.
  const minStep = Math.max(Number.EPSILON * 10, range * 1e-9);

  // Ensure niceStep is finite before returning
  return Number.isFinite(niceStep) ? Math.max(niceStep, minStep) : minStep;
}

// --- Time/Date Formatting --- (remain the same)
export function formatTimestamp(timestamp) {
  try {
    const date = new Date(timestamp * 1000);
    const options = {
      timeZone: "America/Chicago", // Consider making this configurable later
      hour: "numeric",
      minute: "2-digit",
      hour12: state.is12HourFormat,
    };
    // Check for invalid date
    if (isNaN(date.getTime())) {
      throw new Error("Invalid timestamp resulted in Invalid Date");
    }
    return date.toLocaleString("en-US", options);
  } catch (error) {
    console.error("Error formatting timestamp:", error, timestamp);
    // Provide a fallback, but indicate error
    const fallbackDate = new Date(timestamp * 1000);
    if (isNaN(fallbackDate.getTime())) return "??:??";
    const h = fallbackDate.getHours().toString().padStart(2, "0");
    const m = fallbackDate.getMinutes().toString().padStart(2, "0");
    return `${h}:${m}?`;
  }
}

export function formatDate(timestamp) {
  try {
    const date = new Date(timestamp * 1000);
    const options = {
      timeZone: "America/Chicago", // Consider making this configurable later
      month: "short",
      day: "numeric",
    };
    // Check for invalid date
    if (isNaN(date.getTime())) {
      throw new Error("Invalid timestamp resulted in Invalid Date");
    }
    return date.toLocaleDateString("en-US", options);
  } catch (error) {
    console.error("Error formatting date:", error, timestamp);
    return "Date Err";
  }
}

export function formatCurrency(value, currencySymbol = "$", decimals = 2) {
  if (isNaN(value) || value === null || !Number.isFinite(value)) {
    return `${currencySymbol}--.--`;
  }
  try {
    // Ensure decimals is a non-negative integer
    const safeDecimals = Math.max(0, Math.floor(decimals));
    return value
      .toLocaleString("en-US", {
        style: "currency",
        currency: "USD", // Assuming USD for now
        minimumFractionDigits: safeDecimals,
        maximumFractionDigits: safeDecimals,
      })
      .replace("USD", currencySymbol) // Replace if needed, though style: 'currency' often adds it
      .replace(/^\$/, currencySymbol); // Ensure correct symbol if default '$' is used
  } catch (e) {
    console.error("Currency formatting error:", e, { value, decimals });
    // Fallback formatting
    const safeDecimals = Math.max(0, Math.floor(decimals));
    return `${currencySymbol}${value.toFixed(safeDecimals)}`;
  }
}

export function formatQuantity(value) {
  if (isNaN(value) || value === null || !Number.isFinite(value)) return "--";

  const absValue = Math.abs(value);
  let decimals;

  // Determine decimals based on magnitude
  if (absValue === 0) decimals = 2; // Show 0.00 for zero
  else if (absValue < 0.000001) decimals = 8;
  else if (absValue < 0.001) decimals = 6; // Adjusted breakpoint
  else if (absValue < 1) decimals = 4;
  else if (absValue < 1000) decimals = 3; // More precision for values > 1
  else decimals = 2; // Standard for larger numbers

  try {
    // Ensure decimals is valid
    const safeDecimals = Math.max(0, Math.floor(decimals));
    return value.toLocaleString("en-US", {
      minimumFractionDigits: 2, // Always show at least two for consistency
      maximumFractionDigits: safeDecimals,
    });
  } catch (e) {
    console.error("Quantity formatting error:", e, { value, decimals });
    const safeDecimals = Math.max(0, Math.floor(decimals));
    return value.toFixed(safeDecimals); // Fallback
  }
}

```
--- END FILE: js/utils.js ---


--- START FILE: js/volumeChart.js ---
```js
// js/volumeChart.js
import * as dom from "./domElements.js";
import state from "./state.js"; // Need state for visible range and data

let ctx = null;
let canvasWidth = 0;
let canvasHeight = 0;

/**
 * Initializes the volume chart canvas context.
 */
export function initializeVolumeChart() {
  if (!dom.volumeChartCanvas) {
    console.error("Volume chart canvas not found.");
    return;
  }
  ctx = dom.volumeChartCanvas.getContext("2d");
  if (!ctx) {
    console.error("Failed to get 2D context for volume chart canvas.");
    return;
  }
  console.log("Volume chart initialized.");
}

/**
 * Draws the volume bars based on the main chart's visible data.
 *
 * @param {object} mainChartState - The main chart's state (including fullData, visibleStartIndex, visibleEndIndex).
 * @param {number} mainChartWidth - The width of the main chart drawing area (needed for alignment).
 */
export function drawVolumeChart(mainChartState, mainChartWidth) {
  // Ensure context and canvas element exist before proceeding
  if (!ctx || !dom.volumeChartCanvas) {
    console.warn(
      "Volume chart draw skipped: Context or Canvas element missing."
    );
    return;
  }

  canvasWidth = dom.volumeChartCanvas.offsetWidth;
  canvasHeight = dom.volumeChartCanvas.offsetHeight;

  // Ensure canvas has valid dimensions to draw on
  if (canvasWidth <= 0 || canvasHeight <= 0) {
    // console.warn("Volume chart draw skipped: Invalid canvas dimensions."); // Optional log
    // Ensure canvas is clear if dimensions are invalid
    if (dom.volumeChartCanvas.width > 0 || dom.volumeChartCanvas.height > 0) {
      dom.volumeChartCanvas.width = 0; // Explicitly clear if needed
      dom.volumeChartCanvas.height = 0;
    }
    return;
  }

  // Ensure canvas internal resolution matches display size
  if (
    dom.volumeChartCanvas.width !== canvasWidth ||
    dom.volumeChartCanvas.height !== canvasHeight
  ) {
    dom.volumeChartCanvas.width = canvasWidth;
    dom.volumeChartCanvas.height = canvasHeight;
    // console.log("Resized volume canvas:", canvasWidth, canvasHeight); // Optional log
  }

  // Clear the canvas for redrawing
  ctx.clearRect(0, 0, canvasWidth, canvasHeight);

  const { fullData, visibleStartIndex, visibleEndIndex } = mainChartState;
  const visibleCount = visibleEndIndex - visibleStartIndex;

  // Ensure there is data and visible candles to process
  if (
    !fullData ||
    visibleCount <= 0 ||
    fullData.length === 0 ||
    mainChartWidth <= 0
  ) {
    // console.warn("Volume chart draw skipped: No visible data or invalid main chart width."); // Optional log
    return; // Nothing to draw
  }

  // --- Calculate Volume Scale ---
  let maxVisibleVolume = 0;
  for (let i = visibleStartIndex; i < visibleEndIndex; i++) {
    // Robust check: ensure array exists, has enough elements, and volume is a number
    if (
      fullData[i] &&
      fullData[i].length > 5 &&
      typeof fullData[i][5] === "number" &&
      !isNaN(fullData[i][5])
    ) {
      maxVisibleVolume = Math.max(maxVisibleVolume, fullData[i][5]);
    }
  }

  // Avoid division by zero if max volume is zero or less (shouldn't be <0, but safe check)
  if (maxVisibleVolume <= 0) {
    // console.warn("Volume chart draw skipped: Max visible volume is zero or negative."); // Optional log
    return;
  }

  // Calculate scale factor AFTER confirming maxVisibleVolume > 0
  const volumeScaleY = canvasHeight / maxVisibleVolume;

  // --- Calculate Bar Width and Alignment ---
  const barTotalWidth = mainChartWidth / visibleCount;
  const barWidthRatio = 0.7;
  const barWidth = Math.max(1, barTotalWidth * barWidthRatio);

  // --- Get Colors and Opacity ---
  const styles = getComputedStyle(document.documentElement);
  const colorUp = styles.getPropertyValue("--candle-up").trim();
  const colorDown = styles.getPropertyValue("--candle-down").trim();
  const barOpacity = parseFloat(
    styles.getPropertyValue("--volume-bar-opacity").trim() || 0.7
  );

  // Apply opacity once if using globalAlpha
  ctx.globalAlpha = barOpacity;

  // --- Draw Bars ---
  for (let i = 0; i < visibleCount; i++) {
    const dataIndex = visibleStartIndex + i;
    // Basic bounds check (already somewhat covered by loop condition)
    if (dataIndex < 0 || dataIndex >= fullData.length) continue;

    const candle = fullData[dataIndex];
    // More robust check for essential data points needed for coloring and volume
    if (
      !candle ||
      candle.length < 6 ||
      typeof candle[3] !== "number" ||
      isNaN(candle[3]) || // open
      typeof candle[4] !== "number" ||
      isNaN(candle[4]) || // close
      typeof candle[5] !== "number" ||
      isNaN(candle[5])
    ) {
      // volume
      // console.warn(`Skipping volume bar at index ${dataIndex}: Invalid candle data`, candle); // Debug log
      continue;
    }

    const open = candle[3];
    const close = candle[4];
    const volume = candle[5];

    // Skip drawing if volume is essentially zero
    if (volume <= 1e-9) continue;

    // Calculate height, ensuring a minimum visual height of 1px
    const barHeight = Math.max(1, volume * volumeScaleY);
    const isUp = close >= open;

    // Calculate X position
    const barCenterX = (i + 0.5) * barTotalWidth;
    const barLeft = barCenterX - barWidth / 2;

    // Set fill color
    ctx.fillStyle = isUp ? colorUp : colorDown;

    // Draw the rectangle
    // Prevent drawing outside canvas bounds (Y coordinate)
    const yPos = Math.max(0, canvasHeight - barHeight); // Ensure Y doesn't go negative
    const drawHeight = Math.min(barHeight, canvasHeight); // Ensure height doesn't exceed canvas height
    ctx.fillRect(barLeft, yPos, barWidth, drawHeight);
  }

  // Reset global alpha after drawing all bars
  ctx.globalAlpha = 1.0;
}

```
--- END FILE: js/volumeChart.js ---


--- START FILE: server.py ---
```py
# server.py

import os
import json
import requests
import datetime
import time

# Import the correct SDK client
from coinbase.rest import RESTClient

from flask import Flask, request, jsonify
from flask_cors import CORS

# --- Configuration ---
CREDENTIALS_FILE_NAME = "cdp_api_key.json"
CREDENTIALS_FOLDER = "credentials"
PUBLIC_BASE_URL = "https://api.exchange.coinbase.com"  # For candles & public ticker
DEFAULT_PRODUCT_ID = "BTC-USD"
DEFAULT_GRANULARITY = 3600

# --- Load Credentials & Init SDK Client ---
COINBASE_API_KEY_NAME = None
COINBASE_API_PRIVATE_KEY_PEM = None
credentials_loaded = False
rest_client = None
try:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    credentials_path = os.path.join(
        script_dir, CREDENTIALS_FOLDER, CREDENTIALS_FILE_NAME)
    print(f"Attempting to load Cloud API Key from: {credentials_path}")
    if not os.path.exists(credentials_path):
        raise FileNotFoundError(f"File not found: {credentials_path}")
    with open(credentials_path, 'r') as f:
        credentials_data = json.load(f)
    COINBASE_API_KEY_NAME = credentials_data.get('name')
    COINBASE_API_PRIVATE_KEY_PEM = credentials_data.get('privateKey')
    if not COINBASE_API_KEY_NAME or not COINBASE_API_PRIVATE_KEY_PEM:
        raise ValueError("Missing 'name' or 'privateKey' in JSON")
    print("Cloud API Key credentials successfully read from file.")
    credentials_loaded = True
    print(f"  API Key Name: {COINBASE_API_KEY_NAME}")
    # Initialize Client only if credentials loaded
    try:
        print("Initializing coinbase.rest.RESTClient with Cloud Key...")
        rest_client = RESTClient(
            api_key=COINBASE_API_KEY_NAME,
            api_secret=COINBASE_API_PRIVATE_KEY_PEM
        )
        print("REST Client initialized successfully.")
    except Exception as client_e:
        print(f"!!! ERROR Initializing REST Client: {client_e}")
        import traceback
        traceback.print_exc()
        rest_client = None
        credentials_loaded = False  # Failed init means not ready
except Exception as e:
    print(f"\n!!! ERROR Loading Credentials or Initializing Client: {e}\n")
    credentials_loaded = False
if not credentials_loaded or not rest_client:
    print("WARNING: Credentials loading or client initialization failed. Authenticated endpoints will fail.")

# --- Flask App Setup ---
app = Flask(__name__)
CORS(app)

# --- API Status Endpoint ---


@app.route('/api/status')
def get_api_status():
    client_ready = credentials_loaded and (rest_client is not None)
    return jsonify({"credentials_loaded": client_ready})

# --- API Endpoint for Chart Data (Public) ---


@app.route('/api/candles')
def get_candles():
    """ Fetches candlestick data (Public). """
    product_id = request.args.get('product_id', DEFAULT_PRODUCT_ID)
    try:
        granularity = int(request.args.get('granularity', DEFAULT_GRANULARITY))
    except ValueError:
        return jsonify({"error": "Invalid granularity value"}), 400
    start_iso = request.args.get('start', None)
    end_iso = request.args.get('end', None)
    endpoint = f"/products/{product_id}/candles"
    url = PUBLIC_BASE_URL + endpoint
    params = {"granularity": granularity}
    if start_iso:
        params["start"] = start_iso
    if end_iso:
        params["end"] = end_iso
    print(f"Fetching candles: {url} with params {params}")
    try:
        response = requests.get(url, params=params, timeout=15)
        response.raise_for_status()
        candles_data = response.json()
        print(f"Coinbase returned {len(candles_data)} candles.")
        return jsonify(candles_data)

    # --- CORRECTED ERROR HANDLING for /api/candles ---
    except requests.exceptions.HTTPError as err:
        print(f"HTTP error fetching candles: {err}")
        details = f"HTTP Error {err.response.status_code}"  # Default
        try:
            details_json = err.response.json()
            details = details_json.get('message', details_json)
        except json.JSONDecodeError:
            try:
                details = err.response.text
            except:
                pass  # Ignore if text cannot be accessed
        return jsonify({"error": f"API error {err.response.status_code}", "details": details}), err.response.status_code

    except requests.exceptions.RequestException as err:
        print(f"Request error fetching candles: {err}")
        return jsonify({"error": f"Connection error: {err}"}), 502

    except Exception as e:
        print(f"Unexpected error fetching candles: {e}")
        return jsonify({"error": f"Server error: {e}"}), 500
    # --- END CORRECTION ---


# --- NEW: Public Ticker Endpoint ---
@app.route('/api/ticker')
def get_ticker():
    """ Fetches public ticker data for a specific product ID. """
    product_id = request.args.get('product_id')
    if not product_id:
        return jsonify({"error": "Missing 'product_id' query parameter"}), 400
    endpoint = f"/products/{product_id}/ticker"
    url = PUBLIC_BASE_URL + endpoint
    print(f"Fetching public ticker: {url}")
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        ticker_data = response.json()
        price = ticker_data.get('price')
        if price is None:
            return jsonify({"error": f"Could not find price for {product_id}"}), 404
        return jsonify({"product_id": product_id, "price": price})

    # --- CORRECTED ERROR HANDLING for /api/ticker ---
    except requests.exceptions.HTTPError as err:
        status_code = err.response.status_code
        print(f"HTTP error fetching ticker for {product_id}: {err}")
        if status_code == 404:
            return jsonify({"error": f"Product ID '{product_id}' not found."}), 404
        details = f"HTTP Error {status_code}"  # Default
        try:
            details_json = err.response.json()
            details = details_json.get('message', details_json)
        except json.JSONDecodeError:
            try:
                details = err.response.text
            except:
                pass
        return jsonify({"error": f"API error {status_code}", "details": details}), status_code
    # --- END CORRECTION ---

    except requests.exceptions.RequestException as err:
        print(f"Request error fetching ticker for {product_id}: {err}")
        return jsonify({"error": f"Connection error: {err}"}), 502
    except Exception as e:
        print(f"Unexpected error fetching ticker for {product_id}: {e}")
        return jsonify({"error": f"Server error: {e}"}), 500

# --- Accounts Endpoint (Implemented with SDK) ---


@app.route('/api/accounts', methods=['GET'])
def get_accounts():
    """ Fetches account balances using coinbase-advanced-py SDK (Cloud Key Auth). """
    print("Received request for /api/accounts")
    if not rest_client:
        print("-> REST Client not initialized, returning 503.")
        return jsonify({"error": "API Client not ready on server.", "accounts": []}), 503
    try:
        print("Attempting client.get_accounts()...")
        sdk_response = rest_client.get_accounts()
        print(f"Successfully processed SDK response for accounts.")
        account_list = []
        if hasattr(sdk_response, 'accounts') and hasattr(sdk_response.accounts, '__iter__'):
            for account_sdk_obj in sdk_response.accounts:
                if hasattr(account_sdk_obj, 'to_dict'):
                    account_list.append(account_sdk_obj.to_dict())
                elif isinstance(account_sdk_obj, dict):
                    account_list.append(account_sdk_obj)
                else:
                    account_list.append(repr(account_sdk_obj))
            print(f"  -> Found {len(account_list)} accounts in response.")
            return jsonify({"accounts": account_list})
        else:
            print(
                f"Warning: Unexpected response structure from get_accounts(): {type(sdk_response)}")
            return jsonify({"accounts": []})

    # --- CORRECTED ERROR HANDLING for /api/accounts ---
    except Exception as e:
        print(f"!!! ERROR during SDK call (get_accounts): {e}")
        error_message = f"Failed to fetch accounts via SDK: {str(e)}"
        status_code = 500
        # Check if the exception 'e' has a 'response' attribute (like SDK/requests exceptions)
        if hasattr(e, 'response') and e.response is not None:
            status_code = e.response.status_code
            # --- CORRECTED INNER TRY/EXCEPT ---
            try:
                error_details = e.response.json()  # Try parsing JSON first
            except json.JSONDecodeError:
                try:
                    error_details = e.response.text  # Fallback to text
                except:
                    # Final fallback
                    error_details = "(Could not get error details)"
            # --- END CORRECTION ---
            print(f"--- SDK API Error Details (Status: {status_code}) ---")
            print(error_details)
            if status_code == 401:
                error_message = f"SDK Auth failed (401): Check Cloud Key Permissions/Clock."
            elif status_code == 429:
                error_message = "SDK Rate Limit Exceeded (429)."
            else:
                error_message = f"SDK API Error ({status_code})"
        else:
            # If it's a general Python error, print traceback
            import traceback
            traceback.print_exc()
        return jsonify({"error": error_message, "accounts": []}), status_code
    # --- END CORRECTION ---

# --- Orders Endpoint (Still Not Implemented) ---


@app.route('/api/orders', methods=['POST'])
def place_order():
    print("Received request for /api/orders")
    if not rest_client:
        return jsonify({"error": "API Client not ready."}), 503
    print("-> Actual /api/orders call using SDK not implemented. Returning 501.")
    return jsonify({"error": "Order placement not implemented."}), 501


# --- Run App ---
if __name__ == '__main__':
    print("Starting Flask server...")
    app.run(host='0.0.0.0', port=5000, debug=True)

```
--- END FILE: server.py ---


--- START FILE: style.css ---
```css
/* --- General Setup & CSS Variables --- */
:root {
  --bg-color: #f0f0f0;
  --text-color: #333;
  --subtle-text-color: #555;
  --card-bg: #ffffff;
  --border-color: #e0e0e0;
  --grid-color: #eeeeee;
  --axis-label-bg: rgba(255, 255, 255, 0.85);
  --switch-bg: #ccc;
  --switch-slider: #fff;
  --switch-slider-checked: #26a69a; /* Active tab color */
  --candle-up: #26a69a;
  --candle-down: #ef5350;
  --candle-wick: #555;
  --shadow-color: rgba(0, 0, 0, 0.05);
  --border-radius-sm: 4px;
  --border-radius-md: 6px;
  --current-price-color: #2962ff;
  --current-price-text-color: #ffffff;
  --resizer-color: #cccccc;
  --resizer-hover-color: #aaaaaa;
  --header-height: auto;
  --resizer-height: 6px;
  --min-pane-height: 100px;
  --tab-button-hover-bg: rgba(0, 0, 0, 0.05);
  /* Volume/Depth variables removed */
}

html[data-theme="dark"] {
  --bg-color: #1e1e1e;
  --text-color: #e0e0e0;
  --subtle-text-color: #aaaaaa;
  --card-bg: #2a2a2a;
  --border-color: #444444;
  --grid-color: #383838;
  --axis-label-bg: rgba(42, 42, 42, 0.85);
  --switch-bg: #555;
  --switch-slider: #ccc;
  /* --switch-slider-checked remains teal */
  --candle-wick: #bbbbbb;
  --shadow-color: rgba(0, 0, 0, 0.2);
  --current-price-color: #448aff;
  --current-price-text-color: #1e1e1e;
  --resizer-color: #444444;
  --resizer-hover-color: #666666;
  --tab-button-hover-bg: rgba(255, 255, 255, 0.08);
  /* Volume/Depth variables removed */
}

/* --- Core Layout --- */
html,
body {
  height: 100%;
  margin: 0;
  overflow: hidden;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  background-color: var(--bg-color);
  color: var(--text-color);
  transition: background-color 0.3s ease, color 0.3s ease;
}
.main-layout {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
}

/* --- Header Area --- */
.header-area {
  flex-shrink: 0;
  padding: 5px 15px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--card-bg);
  position: relative;
  z-index: 110;
  box-shadow: 0 1px 3px var(--shadow-color);
  display: flex;
  justify-content: space-between;
  align-items: center;
  min-height: 50px;
  flex-wrap: wrap;
  gap: 10px;
}
.header-content {
  text-align: center;
  flex-grow: 1;
  min-width: 200px;
}
.header-area h1 {
  margin: 0 0 2px 0;
  font-size: 1.3em;
  font-weight: 600;
  line-height: 1.2;
}
.header-area p.instructions {
  margin: 0;
  font-size: 0.8em;
  color: var(--subtle-text-color);
  line-height: 1.2;
}
.header-controls {
  display: flex;
  align-items: center;
  gap: 15px;
  flex-shrink: 0;
}
.granularity-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: nowrap;
}
.granularity-controls span {
  margin-right: 5px;
  font-size: 0.85em;
  color: var(--subtle-text-color);
  white-space: nowrap;
}
.granularity-controls button {
  padding: 5px 10px;
  font-size: 0.85em;
  background-color: var(--card-bg);
  color: var(--subtle-text-color);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  cursor: pointer;
  transition: background-color 0.2s ease, color 0.2s ease,
    border-color 0.2s ease;
}
.granularity-controls button:hover {
  border-color: var(--text-color);
  color: var(--text-color);
}
.granularity-controls button.active {
  background-color: var(--switch-slider-checked);
  color: var(--card-bg);
  border-color: var(--switch-slider-checked);
  font-weight: 500;
}

/* --- Settings Button & Dropdown --- */
.settings-group {
  position: relative;
}
.icon-button {
  background: none;
  border: 1px solid transparent;
  color: var(--subtle-text-color);
  font-size: 1.4em;
  padding: 4px 8px;
  cursor: pointer;
  border-radius: var(--border-radius-sm);
  line-height: 1;
  transition: color 0.2s ease, background-color 0.2s ease;
}
.icon-button:hover {
  color: var(--text-color);
  background-color: var(--grid-color);
}
.dropdown-menu {
  position: absolute;
  top: calc(100% + 5px);
  right: 0;
  background-color: var(--card-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-md);
  box-shadow: 0 3px 8px var(--shadow-color);
  padding: 10px 15px;
  min-width: 240px;
  z-index: 120;
  display: none;
  transition: background-color 0.3s ease, border-color 0.3s ease;
}
.dropdown-menu.show {
  display: block;
}
.dropdown-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
  border-bottom: 1px solid var(--grid-color);
  font-size: 0.9em;
  transition: border-color 0.3s ease;
}
.dropdown-item:last-child {
  border-bottom: none;
}
.dropdown-item span {
  margin-right: 15px;
  white-space: nowrap;
}
.dropdown-item .theme-switch-wrapper,
.dropdown-item .log-scale-switch-wrapper,
.dropdown-item .time-format-switch-wrapper {
  align-items: center;
}
.theme-switch {
  position: relative;
  display: inline-block;
  width: 44px;
  height: 24px;
}
.theme-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}
.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--switch-bg);
  transition: 0.4s;
  border-radius: 24px;
}
.slider:before {
  position: absolute;
  content: "";
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: var(--switch-slider);
  transition: 0.4s;
  border-radius: 50%;
}
input:checked + .slider {
  background-color: var(--switch-slider-checked);
}
input:focus + .slider {
  box-shadow: 0 0 1px var(--switch-slider-checked);
}
input:checked + .slider:before {
  transform: translateX(20px);
}

/* --- Top-Left Info --- */
.top-left-info {
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 115;
  background-color: var(--axis-label-bg);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  padding: 5px 8px;
  box-shadow: 0 1px 3px var(--shadow-color);
}
.status-indicator {
  font-size: 0.8em;
  color: var(--subtle-text-color);
  white-space: nowrap;
}
#api-status-indicator {
  font-weight: bold;
}
#api-status-indicator.loaded {
  color: var(--candle-up);
}
#api-status-indicator.error {
  color: var(--candle-down);
}
#api-status-indicator.loading {
  font-style: italic;
}

/* --- Content Area --- */
.content-area {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* --- Chart Pane (Reverted to simple flex container) --- */
.chart-pane {
  flex-grow: 1;
  flex-shrink: 1;
  overflow: hidden;
  position: relative;
  min-height: var(--min-pane-height);
  display: flex; /* Ensure chart-container fills it */
  /* Removed flex-direction */
  background-color: var(--card-bg);
}

/* Main Candlestick Chart Container */
.chart-container {
  width: 100%;
  flex-grow: 1;
  background-color: var(--card-bg);
  border: none;
  padding: 10px 55px 40px 10px;
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
  cursor: grab;
  user-select: none;
  display: flex;
  /* Removed min-height */
}
.chart-container.panning {
  cursor: grabbing;
}
.chart-wrapper {
  width: 100%;
  height: 100%;
  position: relative;
}
.chart-area {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  cursor: default;
  overflow: hidden;
}
.grid-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 0;
}
.grid-line {
  position: absolute;
  background-color: var(--grid-color);
  transition: background-color 0.3s ease;
}
.grid-line.horizontal {
  width: 100%;
  height: 1px;
  left: 0;
}
.y-axis-labels,
.x-axis-labels {
  position: absolute;
  font-size: 11px;
  color: var(--subtle-text-color);
  z-index: 10;
  overflow: hidden;
  background-color: var(--card-bg);
  transition: background-color 0.3s ease, border-color 0.3s ease,
    color 0.3s ease;
}
.y-axis-labels {
  top: 0;
  right: -55px;
  width: 53px;
  height: 100%;
  cursor: ns-resize;
  border-left: 1px solid var(--border-color);
  padding-left: 2px;
}
.x-axis-labels {
  bottom: -40px;
  left: 0;
  width: 100%;
  height: 38px;
  cursor: ew-resize;
  border-top: 1px solid var(--border-color);
  padding-top: 2px;
}
.axis-label {
  position: absolute;
  padding: 1px 4px;
  white-space: nowrap;
  pointer-events: none;
  border-radius: var(--border-radius-sm);
  z-index: 11;
}
.y-axis-label {
  right: 5px;
  transform: translateY(-50%);
  background-color: var(--axis-label-bg);
  transition: background-color 0.3s ease;
}
.x-axis-label {
  top: 2px;
  transform: translateX(-50%);
  color: var(--subtle-text-color);
  background-color: transparent;
}
.x-axis-date-label {
  bottom: 2px;
  transform: translateX(-50%);
  color: var(--text-color);
  font-weight: 500;
  background-color: var(--card-bg);
  padding: 1px 6px;
  z-index: 12;
  border: 1px solid var(--border-color);
  transition: background-color 0.3s ease, border-color 0.3s ease,
    color 0.3s ease;
}
.day-separator-line {
  position: absolute;
  top: 0;
  height: 100%;
  width: 1px;
  border-left: 1px dashed var(--border-color);
  opacity: 0.6;
  pointer-events: none;
  z-index: 0;
}
.month-separator-line {
  border-left-style: solid;
  opacity: 0.8;
}
.year-separator-line {
  border-left-style: solid;
  border-left-width: 2px;
  opacity: 1;
}
.current-price-line {
  position: absolute;
  left: 0;
  width: 100%;
  height: 1px;
  background-color: var(--current-price-color);
  opacity: 0.75;
  pointer-events: none;
  z-index: 15;
  transition: top 0.1s linear;
}
.current-price-label {
  position: absolute;
  right: -55px;
  width: 53px;
  padding: 1px 4px;
  font-size: 11px;
  font-weight: 500;
  text-align: center;
  background-color: var(--current-price-color);
  color: var(--current-price-text-color);
  pointer-events: none;
  z-index: 20;
  border-radius: var(--border-radius-sm);
  box-sizing: border-box;
  transform: translateY(-50%);
  transition: top 0.1s linear;
  white-space: nowrap;
}
html[data-theme="dark"] .current-price-label {
  color: var(--bg-color);
}
.crosshair-line-x {
  position: absolute;
  left: 0;
  right: 0;
  height: 1px;
  border-top: 1px dashed var(--subtle-text-color);
  pointer-events: none;
  z-index: 20;
  opacity: 0.7;
}
.crosshair-label-y {
  position: absolute;
  right: -55px;
  width: 53px;
  padding: 1px 4px;
  font-size: 11px;
  font-weight: 500;
  text-align: center;
  background-color: var(--subtle-text-color);
  color: var(--card-bg);
  pointer-events: none;
  z-index: 21;
  border-radius: var(--border-radius-sm);
  box-sizing: border-box;
  transform: translateY(-50%);
  white-space: nowrap;
  transition: background-color 0.3s ease, color 0.3s ease;
}
.candle {
  position: absolute;
  box-sizing: border-box;
  z-index: 1;
}
.wick {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: 1px;
  background-color: var(--candle-wick);
}
.body {
  position: absolute;
  width: 80%;
  left: 10%;
  box-sizing: border-box;
  border-radius: 1px;
}
.color-up {
  background-color: var(--candle-up);
}
.color-down {
  background-color: var(--candle-down);
}
#chart-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--subtle-text-color);
  font-style: italic;
  z-index: 25;
  background-color: var(--axis-label-bg);
  padding: 8px 15px;
  border-radius: var(--border-radius-sm);
  border: 1px solid var(--border-color);
  user-select: text !important;
  cursor: text;
  transition: background-color 0.3s ease, border-color 0.3s ease,
    color 0.3s ease;
}
.chart-tooltip {
  position: absolute;
  background-color: var(--axis-label-bg);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-md);
  padding: 8px 12px;
  font-size: 11px;
  line-height: 1.4;
  white-space: pre;
  pointer-events: none;
  box-shadow: 0 2px 5px var(--shadow-color);
  z-index: 100;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.15s ease-in-out, visibility 0s linear 0.15s;
}
.chart-tooltip.visible {
  opacity: 1;
  visibility: visible;
  transition: opacity 0.15s ease-in-out;
}
.chart-tooltip .date {
  font-weight: bold;
  margin-bottom: 4px;
  color: var(--text-color);
}
.chart-tooltip .label {
  color: var(--subtle-text-color);
  display: inline-block;
  min-width: 25px;
}
.chart-tooltip .value {
  font-weight: 500;
  font-family: monospace;
  margin-left: 5px;
}

/* Styles for volume chart container and canvas removed */

/* --- Resizer Handle --- */
.resizer {
  flex-shrink: 0;
  height: var(--resizer-height);
  background-color: var(--resizer-color);
  cursor: row-resize;
  width: 100%;
  transition: background-color 0.2s ease;
  z-index: 50;
}
.resizer:hover {
  background-color: var(--resizer-hover-color);
}

/* --- Bottom Pane (Tab Container) --- */
.tab-container {
  flex-shrink: 0;
  overflow: hidden;
  background-color: var(--card-bg);
  border-top: 1px solid var(--border-color);
  box-shadow: 0 -1px 3px var(--shadow-color);
  z-index: 40;
  display: flex;
  flex-direction: column;
  min-height: var(--min-pane-height);
  transition: background-color 0.3s ease, border-color 0.3s ease;
}
.tab-bar {
  display: flex;
  flex-shrink: 0;
  border-bottom: 1px solid var(--border-color);
  padding: 0 10px;
  background-color: var(--card-bg);
  transition: background-color 0.3s ease, border-color 0.3s ease;
}
.tab-button {
  padding: 8px 16px;
  font-size: 0.9em;
  font-weight: 500;
  color: var(--subtle-text-color);
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  cursor: pointer;
  transition: color 0.2s ease, border-bottom-color 0.2s ease,
    background-color 0.2s ease;
  margin-bottom: -1px;
}
.tab-button:hover {
  background-color: var(--tab-button-hover-bg);
  color: var(--text-color);
}
.tab-button.active {
  color: var(--switch-slider-checked);
  border-bottom-color: var(--switch-slider-checked);
}
.tab-content-area {
  flex-grow: 1;
  overflow: hidden;
  position: relative;
}
.tab-content {
  display: none;
  width: 100%;
  height: 100%;
  overflow: auto;
  padding: 10px;
  box-sizing: border-box;
}
.tab-content.active {
  display: block;
}
.pane-placeholder {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100%;
  color: var(--subtle-text-color);
  font-style: italic;
}
.pane-placeholder p {
  margin-bottom: 5px;
}

/* Prompt Tab Specific Styling */
#prompt-content {
  padding: 5px;
}
#prompt-textarea {
  width: 100%;
  height: 100%;
  box-sizing: border-box;
  resize: none;
  background-color: var(--bg-color);
  color: var(--text-color);
  border: 1px solid var(--border-color);
  border-radius: var(--border-radius-sm);
  padding: 8px;
  font-family: inherit;
  font-size: 0.9em;
  line-height: 1.4;
  outline: none;
  transition: background-color 0.3s ease, color 0.3s ease,
    border-color 0.3s ease;
}
#prompt-textarea:focus {
  border-color: var(--switch-slider-checked);
}

/* Positions/Balance Tab Content Styling */
#positions-content.active {
  padding: 0;
  display: flex;
  flex-direction: column;
}
#positions-content .balance-content {
  flex-grow: 1;
  display: flex;
  overflow: hidden;
  height: 100%;
}
#positions-content .balance-list {
  list-style: none;
  margin: 0;
  padding: 10px 15px;
  overflow-y: auto;
  flex-grow: 1;
  font-size: 0.85em;
}
.balance-list li {
  display: flex;
  justify-content: space-between;
  padding: 4px 0;
  border-bottom: 1px solid var(--grid-color);
  transition: border-color 0.3s ease;
}
.balance-list li:last-child {
  border-bottom: none;
}
.balance-list li span {
  padding: 0 5px;
  white-space: nowrap;
}
.balance-list li .asset-code {
  font-weight: 600;
  min-width: 45px;
  flex-basis: 45px;
  flex-shrink: 0;
}
.balance-list li .asset-qty {
  text-align: right;
  flex-grow: 1;
  margin: 0 10px;
  font-family: monospace;
}
.balance-list li .asset-value {
  min-width: 90px;
  flex-basis: 90px;
  flex-shrink: 0;
  text-align: right;
  color: var(--subtle-text-color);
  font-family: monospace;
  transition: color 0.3s ease;
}
.balance-list li.loading,
.balance-list li.error,
.balance-list li.info {
  justify-content: center;
  color: var(--subtle-text-color);
  font-style: italic;
  border-bottom: none;
  padding: 10px 0;
}
.balance-list li.error {
  color: var(--candle-down);
  font-style: normal;
}
#positions-content .balance-total {
  flex-shrink: 0;
  width: 200px;
  padding: 10px 15px;
  border-left: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: flex-end;
  font-size: 0.9em;
  transition: border-color 0.3s ease;
  background-color: var(--card-bg);
}
.balance-total span:first-child {
  color: var(--subtle-text-color);
  margin-bottom: 5px;
  transition: color 0.3s ease;
}
#total-usd-value {
  font-size: 1.2em;
  font-weight: 600;
  font-family: monospace;
}
#total-usd-partial-notice {
  font-size: 0.8em;
  color: var(--subtle-text-color);
  font-style: italic;
  transition: color 0.3s ease;
}

/* --- Balance Dust Category Styles --- */
.balance-list-dust-summary {
  cursor: pointer;
  /* font-style: italic; Removed */
  color: var(--subtle-text-color);
  border-top: 1px dashed var(--grid-color); /* Separator above dust */
  /* margin-top: 5px; Removed */
  /* padding-top: 5px; Removed */
  /* Inherit default li padding instead */
}
.balance-list-dust-summary .asset-code {
  font-size: 0.9em; /* Slightly smaller font */
  font-weight: 500;
  /* font-style: normal; Removed */
}
.balance-list-dust-summary:hover {
  color: var(--text-color);
}

/* Remove triangle indicator */
/* .balance-list-dust-summary::before { ... } REMOVED */
/* .balance-list.dust-visible .balance-list-dust-summary::before { ... } REMOVED */

.balance-list-dust-item {
  display: none; /* Hidden by default */
  /* Optional: add subtle style when visible */
  opacity: 0.8;
  font-size: 0.95em; /* Slightly smaller than main items */
}
/* Show dust items when parent list has the 'dust-visible' class */
/* Ensure this selector is specific enough */
ul#balance-list.dust-visible .balance-list-dust-item {
  display: flex; /* Or 'block' if preferred, should match normal li */
}
/* Explicitly hide when class is not present (for robustness) */
ul#balance-list:not(.dust-visible) .balance-list-dust-item {
  display: none;
}

/* --- Body cursor change during resize --- */
body.resizing,
body.resizing * {
  cursor: row-resize !important;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}

```
--- END FILE: style.css ---


--- START FILE: test_coinbase_sdk.py ---
```py
# test_coinbase_sdk.py

import os
import json
# Import the correct SDK client
from coinbase.rest import RESTClient
import time

# --- Configuration ---
CREDENTIALS_FILE_NAME = "cdp_api_key.json"  # Ensure this matches your file
CREDENTIALS_FOLDER = "credentials"

# --- Load Credentials ---
api_key_name = None
private_key_pem = None
credentials_loaded = False

try:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    credentials_path = os.path.join(
        script_dir, CREDENTIALS_FOLDER, CREDENTIALS_FILE_NAME)
    print(f"--- Loading Credentials from: {credentials_path} ---")

    if not os.path.exists(credentials_path):
        raise FileNotFoundError(f"File not found at {credentials_path}")

    with open(credentials_path, 'r') as f:
        credentials_data = json.load(f)

    # Use the keys as expected by RESTClient
    # 'name' from JSON goes to 'api_key'
    api_key_name = credentials_data.get('name')
    # 'privateKey' from JSON goes to 'api_secret'
    private_key_pem = credentials_data.get('privateKey')

    if not api_key_name or not private_key_pem:
        raise ValueError("Credentials file is missing 'name' or 'privateKey'.")

    print("Credentials successfully read from file.")
    print(f"  API Key Name (used as api_key): {api_key_name}")
    credentials_loaded = True

except Exception as e:
    print(f"!!! ERROR Loading Credentials: {e}")
    exit(1)


# --- Initialize SDK Client (Using coinbase-advanced-py/RESTClient) ---
rest_client = None  # Renamed variable for clarity
if credentials_loaded:
    try:
        print("\n--- Initializing coinbase.rest.RESTClient ---")
        # Initialize using the correct Client class and arguments
        rest_client = RESTClient(
            api_key=api_key_name,      # 'name' from JSON
            api_secret=private_key_pem  # PEM string from JSON
        )
        print("REST Client initialized successfully.")
    except Exception as e:
        print(f"!!! ERROR Initializing REST Client: {e}")
        import traceback
        traceback.print_exc()
        rest_client = None
else:
    print("Skipping client initialization as credentials failed to load.")


# --- Test API Call (List Accounts) ---
if rest_client:
    try:
        print("\n--- Attempting to List Accounts (client.get_accounts) ---")
        # Use the SDK's get_accounts method
        accounts_data = rest_client.get_accounts()

        # The documentation suggests get_accounts returns a dict directly
        # matching the API response structure, often including an 'accounts' list
        if isinstance(accounts_data, dict) and 'accounts' in accounts_data:
            account_list = accounts_data.get('accounts', [])
            print(f"SUCCESS: Fetched {len(account_list)} accounts.")
            print("--- Accounts Data ---")
            # Pretty print the JSON-like structure
            print(json.dumps(accounts_data, indent=2))

            # Specifically find and print USDT/USD balance if present
            usdt_balance = "Not Found"
            usd_balance = "Not Found"
            for acc in account_list:
                # Accessing values directly based on typical V3 structure
                currency = acc.get('currency')
                # Balances are usually nested under 'available_balance' or similar
                # Use available for trading? Or 'balance'? Check response!
                balance_info = acc.get('available_balance', {})
                value = balance_info.get('value', 'N/A')

                if currency == 'USDT':
                    usdt_balance = value
                elif currency == 'USD':
                    usd_balance = value

            print("\n--- Specific Balances ---")
            print(f"  USD Available Balance: {usd_balance}")
            print(f"  USDT Available Balance: {usdt_balance}")

        else:
            # If the structure is different, print the raw response
            print("SUCCESS: Received response (Unexpected structure?):")
            print(accounts_data)

    except Exception as e:
        print(f"\n!!! ERROR during API call (get_accounts): {e}")
        # Check if the error object has response details (common with requests-based errors)
        if hasattr(e, 'response') and e.response is not None:
            try:
                error_details = e.response.json()
                print("--- API Error Details ---")
                print(json.dumps(error_details, indent=2))
                if e.response.status_code == 401:
                    print(
                        "!!! NOTE: 401 Unauthorized - Check API Key Permissions on CDP Portal (need View/Read for accounts) or Clock Skew.")
            except:
                print(
                    f"--- API Raw Error Response Text (Status: {e.response.status_code}) ---")
                print(e.response.text)
        else:
            # Print general exception info if no response details attached
            import traceback
            traceback.print_exc()

else:
    print("\n--- Skipping API call as REST Client was not initialized. ---")

print("\n--- Test Script Finished ---")

```
--- END FILE: test_coinbase_sdk.py ---


--- START FILE: test_manual_jwt.py ---
```py
# test_manual_jwt.py

import os
import json
import http.client  # Use Python's built-in library
import time
import uuid

# Use PyJWT for JWT creation
import jwt
# Cryptography for loading the key
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.serialization import load_pem_private_key
import datetime  # Need this for JWT timestamps

# --- Configuration ---
CREDENTIALS_FILE_NAME = "cdp_api_key.json"  # Ensure this matches
CREDENTIALS_FOLDER = "credentials"
API_HOST = "api.coinbase.com"  # Host for http.client
SERVICE_NAME = "retail_rest_api_proxy"  # Audience for JWT

# --- Load Credentials ---
api_key_name = None
private_key_pem = None
private_key_obj = None  # Store the loaded key object
credentials_loaded = False

try:
    script_dir = os.path.dirname(os.path.abspath(__file__))
    credentials_path = os.path.join(
        script_dir, CREDENTIALS_FOLDER, CREDENTIALS_FILE_NAME)
    print(f"--- Loading Credentials from: {credentials_path} ---")

    if not os.path.exists(credentials_path):
        raise FileNotFoundError(f"File not found: {credentials_path}")

    with open(credentials_path, 'r') as f:
        credentials_data = json.load(f)
    api_key_name = credentials_data.get('name')
    private_key_pem = credentials_data.get('privateKey')
    if not api_key_name or not private_key_pem:
        raise ValueError("Missing 'name' or 'privateKey'")

    # Load the private key *object*
    try:
        private_key_obj = load_pem_private_key(
            private_key_pem.encode('utf-8'), password=None)
        print("Private key object loaded successfully.")
    except Exception as key_error:
        raise ValueError(f"Could not load key object: {key_error}")

    print("Credentials successfully read.")
    print(f"  API Key Name (kid): {api_key_name}")
    credentials_loaded = True

except Exception as e:
    print(f"!!! ERROR Loading Credentials: {e}")
    exit(1)


# --- Helper Function to Generate JWT ---
def generate_jwt_manual(method, request_path):
    """ Generates a JWT for Coinbase Cloud API authentication (Manual Version). """
    if not credentials_loaded or not private_key_obj:
        print("Error: Cannot generate JWT.")
        return None
    try:
        # e.g., "GET /api/v3/brokerage/accounts"
        uri = f"{method.upper()} {request_path}"
        payload = {
            'sub': api_key_name, 'iss': "coinbase-cloud",
            'nbf': datetime.datetime.now(tz=datetime.timezone.utc),
            'exp': datetime.datetime.now(tz=datetime.timezone.utc) + datetime.timedelta(minutes=2),
            'aud': [SERVICE_NAME], 'uri': uri
        }
        headers = {'alg': 'ES256', 'kid': api_key_name,
                   'nonce': uuid.uuid4().hex}
        token = jwt.encode(payload, private_key_obj,
                           algorithm="ES256", headers=headers)
        # Avoid printing full token
        print(f"--- Generated JWT (first 10 chars): {token[:10]}... ---")
        return token
    except Exception as e:
        print(f"Error generating JWT: {e}")
        return None


# --- Make the Authenticated API Call ---
if credentials_loaded:
    try:
        method = "GET"
        # Define the specific path WITH query parameters if needed
        request_path_with_query = "/api/v3/brokerage/accounts"  # Start with base path
        # Add query params like limit=1 ?
        # query_params = "?limit=1" # Optional: Add query parameters here
        # request_path_with_query += query_params

        print(
            f"\n--- Generating JWT for: {method} {request_path_with_query} ---")
        auth_token = generate_jwt_manual(method, request_path_with_query)

        if not auth_token:
            raise Exception("Failed to generate JWT token.")

        print(
            f"--- Making Request: {method} https://{API_HOST}{request_path_with_query} ---")
        conn = http.client.HTTPSConnection(API_HOST)

        # Prepare headers, including the generated JWT
        request_headers = {
            'Authorization': f'Bearer {auth_token}',  # Use JWT as Bearer token
            'Content-Type': 'application/json'  # Still needed even for GET
        }
        # Don't log token
        print(
            f"  Headers: {{'Authorization': 'Bearer ...', 'Content-Type': ...}}")

        # Make the request (payload is empty for GET)
        payload = ''
        conn.request(method, request_path_with_query, payload, request_headers)

        # Get and process the response
        res = conn.getresponse()
        status = res.status
        reason = res.reason
        print(f"\n--- Response Status: {status} {reason} ---")

        data = res.read()
        conn.close()  # Close the connection

        print("--- Response Body (Decoded) ---")
        response_body_str = data.decode("utf-8")
        print(response_body_str)

        # Try parsing JSON and extracting info
        if 200 <= status < 300:
            print("\n--- SUCCESS ---")
            try:
                response_json = json.loads(response_body_str)
                # Look for USD/USDT
                usd_balance = "Not Found"
                usdt_balance = "Not Found"
                for acc in response_json.get('accounts', []):
                    currency = acc.get('currency')
                    balance_info = acc.get('available_balance', {})
                    value = balance_info.get('value', 'N/A')
                    if currency == 'USD':
                        usd_balance = value
                    elif currency == 'USDT':
                        usdt_balance = value
                print(f"  USD Available: {usd_balance}")
                print(f"  USDT Available: {usdt_balance}")
            except json.JSONDecodeError:
                print("  (Could not parse response body as JSON)")
        else:
            print("\n--- FAILED ---")
            if status == 401:
                print(
                    "!!! NOTE: 401 Unauthorized - Check API Key Permissions or Clock Skew.")
            # Further error details are already printed in the body

    except Exception as e:
        print(f"\n!!! ERROR during API call: {e}")
        import traceback
        traceback.print_exc()

else:
    print("\n--- Skipping API call as credentials failed to load. ---")

print("\n--- Test Script Finished ---")

```
--- END FILE: test_manual_jwt.py ---


--- END ALL OTHER PROJECT FILES ---

